{"map":"{\"version\":3,\"sources\":[],\"names\":[],\"mappings\":\"\"}","code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[,function(module,exports,__webpack_require__){\"use strict\";eval('var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\\n\\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2), __webpack_require__(4), __webpack_require__(3)], __WEBPACK_AMD_DEFINE_RESULT__ = (function ($, count, show) {\\n    // require([\\'./move\\']);\\n    $(function () {\\n\\n        function guid() {\\n            return \\'xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx\\'.replace(/[xy]/g, function (c) {\\n                var r = Math.random() * 16 | 0,\\n                    v = c == \\'x\\' ? r : r & 0x3 | 0x8;\\n                return v.toString(16);\\n            });\\n        }\\n        $(\\'.addlist\\').on(\"click\", function () {\\n            for (var i = 0; i < 1000; i++) {\\n                var content = i;\\n\\n                var old = localStorage.getItem(\"myplan\");\\n                if (!old) {\\n                    var obj = {};\\n                    obj.content = content;\\n                    obj.done = false;\\n                    obj.listatus = false;\\n                    obj.id = guid();\\n                    var str = JSON.stringify(obj);\\n                    localStorage.setItem(\"myplan\", \\'[\\' + str + \\']\\');\\n                } else {\\n                    var obj = JSON.parse(old);\\n                    obj.push({\\n                        \"content\": content,\\n                        \"done\": false,\\n                        \"listatus\": false,\\n                        \"id\": guid()\\n                    });\\n                    var str = JSON.stringify(obj);\\n                    localStorage.setItem(\"myplan\", str);\\n                }\\n            }\\n            show.showplans();\\n            count.count();\\n        });\\n\\n        function safeStr(str) {\\n            return str.replace(/</g, \\'&lt;\\').replace(/>/g, \\'&gt;\\').replace(/\"/g, \"&quot;\").replace(/\\'/g, \"&#039;\");\\n        }\\n        $(\"body\").on(\"keydown\", \"#todoinput\", function (e) {\\n\\n            if (e.keyCode == 13) {\\n                var content = $(\\'#todoinput\\').val();\\n                content = safeStr(content);\\n                if (content.length > 0) {\\n                    var old = localStorage.getItem(\"myplan\");\\n                    if (!old) {\\n                        var obj = {};\\n                        obj.content = content;\\n                        obj.done = false;\\n                        obj.listatus = false;\\n                        obj.id = guid();\\n\\n                        var str = JSON.stringify(obj);\\n                        localStorage.setItem(\"myplan\", \\'[\\' + str + \\']\\');\\n                    } else {\\n                        var obj = JSON.parse(old);\\n                        obj.push({\\n                            \"content\": content,\\n                            \"done\": false,\\n                            \"listatus\": false,\\n                            \"id\": guid()\\n                        });\\n                        var str = JSON.stringify(obj);\\n                        localStorage.setItem(\"myplan\", str);\\n                    }\\n                    show.showplan();\\n                    count.count();\\n                } else {\\n                    alert(\"请输入数据\");\\n                }\\n                $(\\'#todoinput\\').val(\"\");\\n            }\\n        });\\n\\n        $(\\'body\\').on(\\'click\\', \".list ul li\", function () {\\n            var key = $(this).prop(\\'id\\');\\n            var data = localStorage.getItem(\"myplan\");\\n            data = JSON.parse(data);\\n            for (var i = 0; i < data.length; i++) {\\n                if (data[i].id == key) {\\n                    if (data[i].listatus == false) {\\n                        data[i].listatus = true;\\n                        //$(this).prop(\\'class\\', \\'liborder\\');\\n                        $(this).addClass(\\'liborder\\');\\n                    } else {\\n                        data[i].listatus = false;\\n                        //$(this).prop(\\'class\\', \\'liborder2\\');\\n                        $(this).removeClass(\\'liborder\\');\\n                    }\\n                }\\n            }\\n            var str = JSON.stringify(data);\\n            localStorage.setItem(\"myplan\", str);\\n            var data = localStorage.getItem(\"myplan\");\\n            data = JSON.parse(data);\\n        });\\n\\n        $(\\'body\\').on(\\'click\\', \".list ul li input\", function (e) {\\n            e.stopPropagation();\\n        });\\n        // 点击未完成计划列表input\\n        $(\"body .todolist .list #ullist\").on(\"click\", \"li input\", function () {\\n\\n            if ($(this).prop(\"checked\") == true) {\\n                var key = $(this).parent().parent().prop(\"id\");\\n                $(\"#\" + key).fadeOut(function () {\\n                    $(\"#\" + key).remove();\\n                });\\n                var data = localStorage.getItem(\"myplan\");\\n                data = JSON.parse(data);\\n                for (var i = 0; i < data.length; i++) {\\n                    if (data[i].id == key) {\\n                        data[i].done = true;\\n                        var str = JSON.stringify(data);\\n                        localStorage.setItem(\"myplan\", str);\\n                        var data = localStorage.getItem(\"myplan\");\\n                        data = JSON.parse(data);\\n                        console.log(data[i].listatus);\\n                        $(\\'<li id=\\' + data[i].id + \\'><span><span></span><input type=\"checkbox\"  style=\"zoom:200%\" checked=\"checked\"/><span>\\' + data[i].content + \\'</span></span><span class=\"del\">X</span></li>\\').appendTo($(\".todolist .list2>ul\"));\\n                        var datatem = data[i];\\n                        data.splice(i, 1);\\n                        data.push(datatem);\\n                        var str = JSON.stringify(data);\\n                        localStorage.setItem(\"myplan\", str);\\n                        count.count();\\n                        return;\\n                    }\\n                }\\n            }\\n        });\\n        // 点击已完成列表input\\n        $(\"body .todolist .list #donelist\").on(\"click\", \"li input\", function () {\\n            if ($(this).prop(\"checked\") == false) {\\n                var key = $(this).parent().parent().prop(\"id\");\\n                $(\"#\" + key).remove();\\n                var data = localStorage.getItem(\"myplan\");\\n                data = JSON.parse(data);\\n                for (var i = 0; i < data.length; i++) {\\n                    if (data[i].id == key) {\\n                        data[i].done = false;\\n                        var str = JSON.stringify(data);\\n                        localStorage.setItem(\"myplan\", str);\\n                        var data = localStorage.getItem(\"myplan\");\\n                        data = JSON.parse(data);\\n                        $(\\'<li id=\\' + data[i].id + \\'  ondrop=\"drop(event,this)\" ondragover=\"allowDrop(event)\" draggable=\"true\" ondragstart=\"drag(event, this)\" ><span><span></span><input type=\"checkbox\" style=\"zoom:200%\" /><span>\\' + data[i].content + \\'</span></span><span class=\"del\">X</span></li>\\').appendTo($(\".todolist .list1>ul\"));\\n                        //$(\"#\" + data[i].id).find(\"*\");\\n                        var datatem = data[i];\\n                        // console.log(datatem)\\n                        data.splice(i, 1);\\n                        data.push(datatem);\\n                        var str = JSON.stringify(data);\\n                        localStorage.setItem(\"myplan\", str);\\n                        count.count();\\n                        return;\\n                    }\\n                }\\n            }\\n        });\\n        // 点击删除按钮\\n        $(\"body\").on(\"click\", \".del\", function () {\\n            var key = $(this).parent().prop(\"id\");\\n            $(\"#\" + key).fadeOut(function () {\\n                $(\"#\" + key).remove();\\n            });\\n            var data = localStorage.getItem(\"myplan\");\\n            data = JSON.parse(data);\\n            var index = 0;\\n            for (var i = 0; i < data.length; i++) {\\n                if (key == data[i].id) {\\n                    index = i;\\n                    data.splice(index, 1);\\n                }\\n            }\\n            var str = JSON.stringify(data);\\n            localStorage.setItem(\"myplan\", str);\\n            count.count();\\n            return false;\\n        });\\n        count.count();\\n        show.showallplan();\\n    });\\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\\n\\t\\t\\t\\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wdWJsaWMvamF2YXNjcmlwdHMvdG9kb2xpc3QuanM/YzFhZSJdLCJuYW1lcyI6WyIkIiwiY291bnQiLCJzaG93IiwiZ3VpZCIsInJlcGxhY2UiLCJjIiwiciIsIk1hdGgiLCJyYW5kb20iLCJ2IiwidG9TdHJpbmciLCJvbiIsImkiLCJjb250ZW50Iiwib2xkIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsIm9iaiIsImRvbmUiLCJsaXN0YXR1cyIsImlkIiwic3RyIiwiSlNPTiIsInN0cmluZ2lmeSIsInNldEl0ZW0iLCJwYXJzZSIsInB1c2giLCJzaG93cGxhbnMiLCJzYWZlU3RyIiwiZSIsImtleUNvZGUiLCJ2YWwiLCJsZW5ndGgiLCJzaG93cGxhbiIsImFsZXJ0Iiwia2V5IiwicHJvcCIsImRhdGEiLCJhZGRDbGFzcyIsInJlbW92ZUNsYXNzIiwic3RvcFByb3BhZ2F0aW9uIiwicGFyZW50IiwiZmFkZU91dCIsInJlbW92ZSIsImNvbnNvbGUiLCJsb2ciLCJhcHBlbmRUbyIsImRhdGF0ZW0iLCJzcGxpY2UiLCJpbmRleCIsInNob3dhbGxwbGFuIl0sIm1hcHBpbmdzIjoiOztBQUFBLGlDQUFPLENBQUMsc0JBQUQsRUFBYSxzQkFBYixFQUF3QixzQkFBeEIsQ0FBUCxtQ0FBMEMsVUFBU0EsQ0FBVCxFQUFZQyxLQUFaLEVBQW1CQyxJQUFuQixFQUF5QjtBQUMvRDtBQUNBRixNQUFFLFlBQVc7O0FBRVQsaUJBQVNHLElBQVQsR0FBZ0I7QUFDWixtQkFBTyxtQ0FBbUNDLE9BQW5DLENBQTJDLE9BQTNDLEVBQW9ELFVBQVNDLENBQVQsRUFBWTtBQUNuRSxvQkFBSUMsSUFBSUMsS0FBS0MsTUFBTCxLQUFnQixFQUFoQixHQUFxQixDQUE3QjtBQUFBLG9CQUNJQyxJQUFJSixLQUFLLEdBQUwsR0FBV0MsQ0FBWCxHQUFnQkEsSUFBSSxHQUFKLEdBQVUsR0FEbEM7QUFFQSx1QkFBT0csRUFBRUMsUUFBRixDQUFXLEVBQVgsQ0FBUDtBQUNI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QUwsQ0FBV1ksSUFBWCxDQUFQO0FBQ0EsZ0JBQUlZLFFBQVEsQ0FBWjtBQUNBLGlCQUFLLElBQUlyQyxJQUFJLENBQWIsRUFBZ0JBLElBQUl5QixLQUFLTCxNQUF6QixFQUFpQ3BCLEdBQWpDLEVBQXNDO0FBQ2xDLG9CQUFJdUIsT0FBT0UsS0FBS3pCLENBQUwsRUFBUVEsRUFBbkIsRUFBdUI7QUFDbkI2Qiw0QkFBUXJDLENBQVI7QUFDQXlCLHlCQUFLVyxNQUFMLENBQVlDLEtBQVosRUFBbUIsQ0FBbkI7QUFDSDtBQUNKO0FBQ0QsZ0JBQUk1QixNQUFNQyxLQUFLQyxTQUFMLENBQWVjLElBQWYsQ0FBVjtBQUNBdEIseUJBQWFTLE9BQWIsQ0FBcUIsUUFBckIsRUFBK0JILEdBQS9CO0FBQ0FwQixrQkFBTUEsS0FBTjtBQUNBLG1CQUFPLEtBQVA7QUFDSCxTQWxCRDtBQW1CQUEsY0FBTUEsS0FBTjtBQUNBQyxhQUFLZ0QsV0FBTDtBQUNILEtBMUxEO0FBOExILENBaE1EO0FBQUEiLCJmaWxlIjoiMS5qcyIsInNvdXJjZXNDb250ZW50IjpbImRlZmluZShbJy4vanF1ZXJ5JywgJy4vY291bnQnLCAnLi9zaG93J10sIGZ1bmN0aW9uKCQsIGNvdW50LCBzaG93KSB7XHJcbiAgICAvLyByZXF1aXJlKFsnLi9tb3ZlJ10pO1xyXG4gICAgJChmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gZ3VpZCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICd4eHh4eHh4eHh4eHg0eHh4eXh4eHh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbihjKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgciA9IE1hdGgucmFuZG9tKCkgKiAxNiB8IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgdiA9IGMgPT0gJ3gnID8gciA6IChyICYgMHgzIHwgMHg4KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2LnRvU3RyaW5nKDE2KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgICQoJy5hZGRsaXN0Jykub24oXCJjbGlja1wiLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxMDAwOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBjb250ZW50ID0gaTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgb2xkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJteXBsYW5cIik7XHJcbiAgICAgICAgICAgICAgICBpZiAoIW9sZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvYmogPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICBvYmouY29udGVudCA9IGNvbnRlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgb2JqLmRvbmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBvYmoubGlzdGF0dXMgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBvYmouaWQgPSBndWlkKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0ciA9IEpTT04uc3RyaW5naWZ5KG9iaik7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJteXBsYW5cIiwgJ1snICsgc3RyICsgJ10nKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9iaiA9IEpTT04ucGFyc2Uob2xkKTtcclxuICAgICAgICAgICAgICAgICAgICBvYmoucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiY29udGVudFwiOiBjb250ZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcImRvbmVcIjogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwibGlzdGF0dXNcIjogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiaWRcIjogZ3VpZCgpLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHIgPSBKU09OLnN0cmluZ2lmeShvYmopO1xyXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwibXlwbGFuXCIsIHN0cik7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNob3cuc2hvd3BsYW5zKCk7XHJcbiAgICAgICAgICAgIGNvdW50LmNvdW50KCk7XHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gc2FmZVN0cihzdHIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC88L2csICcmbHQ7JykucmVwbGFjZSgvPi9nLCAnJmd0OycpLnJlcGxhY2UoL1wiL2csIFwiJnF1b3Q7XCIpLnJlcGxhY2UoLycvZywgXCImIzAzOTtcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgICQoXCJib2R5XCIpLm9uKFwia2V5ZG93blwiLCBcIiN0b2RvaW5wdXRcIiwgZnVuY3Rpb24oZSkge1xyXG5cclxuICAgICAgICAgICAgaWYgKGUua2V5Q29kZSA9PSAxMykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSAkKCcjdG9kb2lucHV0JykudmFsKCk7XHJcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gc2FmZVN0cihjb250ZW50KTtcclxuICAgICAgICAgICAgICAgIGlmIChjb250ZW50Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb2xkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJteXBsYW5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9iaiA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmouY29udGVudCA9IGNvbnRlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iai5kb25lID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iai5saXN0YXR1cyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmouaWQgPSBndWlkKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RyID0gSlNPTi5zdHJpbmdpZnkob2JqKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJteXBsYW5cIiwgJ1snICsgc3RyICsgJ10nKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2JqID0gSlNPTi5wYXJzZShvbGQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmoucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImNvbnRlbnRcIjogY29udGVudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZG9uZVwiOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibGlzdGF0dXNcIjogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImlkXCI6IGd1aWQoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdHIgPSBKU09OLnN0cmluZ2lmeShvYmopO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcIm15cGxhblwiLCBzdHIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBzaG93LnNob3dwbGFuKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY291bnQuY291bnQoKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWxlcnQoXCLor7fovpPlhaXmlbDmja5cIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAkKCcjdG9kb2lucHV0JykudmFsKFwiXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgICQoJ2JvZHknKS5vbignY2xpY2snLCBcIi5saXN0IHVsIGxpXCIsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIga2V5ID0gJCh0aGlzKS5wcm9wKCdpZCcpO1xyXG4gICAgICAgICAgICB2YXIgZGF0YSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwibXlwbGFuXCIpO1xyXG4gICAgICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGF0YVtpXS5pZCA9PSBrZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVtpXS5saXN0YXR1cyA9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhW2ldLmxpc3RhdHVzID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8kKHRoaXMpLnByb3AoJ2NsYXNzJywgJ2xpYm9yZGVyJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICQodGhpcykuYWRkQ2xhc3MoJ2xpYm9yZGVyJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtpXS5saXN0YXR1cyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyQodGhpcykucHJvcCgnY2xhc3MnLCAnbGlib3JkZXIyJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICQodGhpcykucmVtb3ZlQ2xhc3MoJ2xpYm9yZGVyJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBzdHIgPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcclxuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJteXBsYW5cIiwgc3RyKTtcclxuICAgICAgICAgICAgdmFyIGRhdGEgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcIm15cGxhblwiKTtcclxuICAgICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgJCgnYm9keScpLm9uKCdjbGljaycsIFwiLmxpc3QgdWwgbGkgaW5wdXRcIiwgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLy8g54K55Ye75pyq5a6M5oiQ6K6h5YiS5YiX6KGoaW5wdXRcclxuICAgICAgICAkKFwiYm9keSAudG9kb2xpc3QgLmxpc3QgI3VsbGlzdFwiKS5vbihcImNsaWNrXCIsIFwibGkgaW5wdXRcIiwgZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCQodGhpcykucHJvcChcImNoZWNrZWRcIikgPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSAkKHRoaXMpLnBhcmVudCgpLnBhcmVudCgpLnByb3AoXCJpZFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAkKFwiI1wiICsga2V5KS5mYWRlT3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAkKFwiI1wiICsga2V5KS5yZW1vdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJteXBsYW5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhW2ldLmlkID09IGtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtpXS5kb25lID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdHIgPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwibXlwbGFuXCIsIHN0cik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwibXlwbGFuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhkYXRhW2ldLmxpc3RhdHVzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJCgnPGxpIGlkPScgKyBkYXRhW2ldLmlkICsgJz48c3Bhbj48c3Bhbj48L3NwYW4+PGlucHV0IHR5cGU9XCJjaGVja2JveFwiICBzdHlsZT1cInpvb206MjAwJVwiIGNoZWNrZWQ9XCJjaGVja2VkXCIvPjxzcGFuPicgKyBkYXRhW2ldLmNvbnRlbnQgKyAnPC9zcGFuPjwvc3Bhbj48c3BhbiBjbGFzcz1cImRlbFwiPlg8L3NwYW4+PC9saT4nKS5hcHBlbmRUbygkKFwiLnRvZG9saXN0IC5saXN0Mj51bFwiKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YXRlbSA9IGRhdGFbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEucHVzaChkYXRhdGVtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdHIgPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwibXlwbGFuXCIsIHN0cik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudC5jb3VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLy8g54K55Ye75bey5a6M5oiQ5YiX6KGoaW5wdXRcclxuICAgICAgICAkKFwiYm9keSAudG9kb2xpc3QgLmxpc3QgI2RvbmVsaXN0XCIpLm9uKFwiY2xpY2tcIiwgXCJsaSBpbnB1dFwiLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIGlmICgkKHRoaXMpLnByb3AoXCJjaGVja2VkXCIpID09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9ICQodGhpcykucGFyZW50KCkucGFyZW50KCkucHJvcChcImlkXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICQoXCIjXCIgKyBrZXkpLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJteXBsYW5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhW2ldLmlkID09IGtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtpXS5kb25lID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RyID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcIm15cGxhblwiLCBzdHIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcIm15cGxhblwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJCgnPGxpIGlkPScgKyBkYXRhW2ldLmlkICsgJyAgb25kcm9wPVwiZHJvcChldmVudCx0aGlzKVwiIG9uZHJhZ292ZXI9XCJhbGxvd0Ryb3AoZXZlbnQpXCIgZHJhZ2dhYmxlPVwidHJ1ZVwiIG9uZHJhZ3N0YXJ0PVwiZHJhZyhldmVudCwgdGhpcylcIiA+PHNwYW4+PHNwYW4+PC9zcGFuPjxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBzdHlsZT1cInpvb206MjAwJVwiIC8+PHNwYW4+JyArIGRhdGFbaV0uY29udGVudCArICc8L3NwYW4+PC9zcGFuPjxzcGFuIGNsYXNzPVwiZGVsXCI+WDwvc3Bhbj48L2xpPicpLmFwcGVuZFRvKCQoXCIudG9kb2xpc3QgLmxpc3QxPnVsXCIpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vJChcIiNcIiArIGRhdGFbaV0uaWQpLmZpbmQoXCIqXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGF0ZW0gPSBkYXRhW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coZGF0YXRlbSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5wdXNoKGRhdGF0ZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0ciA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJteXBsYW5cIiwgc3RyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50LmNvdW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC8vIOeCueWHu+WIoOmZpOaMiemSrlxyXG4gICAgICAgICQoXCJib2R5XCIpLm9uKFwiY2xpY2tcIiwgXCIuZGVsXCIsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIga2V5ID0gJCh0aGlzKS5wYXJlbnQoKS5wcm9wKFwiaWRcIik7XHJcbiAgICAgICAgICAgICQoXCIjXCIgKyBrZXkpLmZhZGVPdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAkKFwiI1wiICsga2V5KS5yZW1vdmUoKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgdmFyIGRhdGEgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcIm15cGxhblwiKTtcclxuICAgICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IDA7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PSBkYXRhW2ldLmlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgc3RyID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XHJcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwibXlwbGFuXCIsIHN0cik7XHJcbiAgICAgICAgICAgIGNvdW50LmNvdW50KCk7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9KVxyXG4gICAgICAgIGNvdW50LmNvdW50KCk7XHJcbiAgICAgICAgc2hvdy5zaG93YWxscGxhbigpO1xyXG4gICAgfSlcclxuXHJcblxyXG5cclxufSkiXSwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///1\\n')},function(module,exports,__webpack_require__){\"use strict\";eval('/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\\n\\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\\n\\n/*!\\r\\n * jQuery JavaScript Library v2.1.1\\r\\n * http://jquery.com/\\r\\n *\\r\\n * Includes Sizzle.js\\r\\n * http://sizzlejs.com/\\r\\n *\\r\\n * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors\\r\\n * Released under the MIT license\\r\\n * http://jquery.org/license\\r\\n *\\r\\n * Date: 2014-05-01T17:11Z\\r\\n */\\n\\n(function (global, factory) {\\n\\n    if (( false ? undefined : _typeof(module)) === \"object\" && _typeof(module.exports) === \"object\") {\\n        // For CommonJS and CommonJS-like environments where a proper window is present,\\n        // execute the factory and get jQuery\\n        // For environments that do not inherently posses a window with a document\\n        // (such as Node.js), expose a jQuery-making factory as module.exports\\n        // This accentuates the need for the creation of a real window\\n        // e.g. var jQuery = require(\"jquery\")(window);\\n        // See ticket #14549 for more info\\n        module.exports = global.document ? factory(global, true) : function (w) {\\n            if (!w.document) {\\n                throw new Error(\"jQuery requires a window with a document\");\\n            }\\n            return factory(w);\\n        };\\n    } else {\\n        factory(global);\\n    }\\n\\n    // Pass this if window is not defined yet\\n})(typeof window !== \"undefined\" ? window : undefined, function (window, noGlobal) {\\n\\n    // Can\\'t do this because several apps including ASP.NET trace\\n    // the stack via arguments.caller.callee and Firefox dies if\\n    // you try to trace through \"use strict\" call chains. (#13335)\\n    // Support: Firefox 18+\\n    //\\n\\n    var arr = [];\\n\\n    var _slice = arr.slice;\\n\\n    var concat = arr.concat;\\n\\n    var push = arr.push;\\n\\n    var indexOf = arr.indexOf;\\n\\n    var class2type = {};\\n\\n    var toString = class2type.toString;\\n\\n    var hasOwn = class2type.hasOwnProperty;\\n\\n    var support = {};\\n\\n    var\\n    // Use the correct document accordingly with window argument (sandbox)\\n    document = window.document,\\n        version = \"2.1.1\",\\n\\n\\n    // Define a local copy of jQuery\\n    jQuery = function jQuery(selector, context) {\\n        // The jQuery object is actually just the init constructor \\'enhanced\\'\\n        // Need init if jQuery is called (just allow error to be thrown if not included)\\n        return new jQuery.fn.init(selector, context);\\n    },\\n\\n\\n    // Support: Android<4.1\\n    // Make sure we trim BOM and NBSP\\n    rtrim = /^[\\\\s\\\\uFEFF\\\\xA0]+|[\\\\s\\\\uFEFF\\\\xA0]+$/g,\\n\\n\\n    // Matches dashed string for camelizing\\n    rmsPrefix = /^-ms-/,\\n        rdashAlpha = /-([\\\\da-z])/gi,\\n\\n\\n    // Used by jQuery.camelCase as callback to replace()\\n    fcamelCase = function fcamelCase(all, letter) {\\n        return letter.toUpperCase();\\n    };\\n\\n    jQuery.fn = jQuery.prototype = {\\n        // The current version of jQuery being used\\n        jquery: version,\\n\\n        constructor: jQuery,\\n\\n        // Start with an empty selector\\n        selector: \"\",\\n\\n        // The default length of a jQuery object is 0\\n        length: 0,\\n\\n        toArray: function toArray() {\\n            return _slice.call(this);\\n        },\\n\\n        // Get the Nth element in the matched element set OR\\n        // Get the whole matched element set as a clean array\\n        get: function get(num) {\\n            return num != null ?\\n\\n            // Return just the one element from the set\\n            num < 0 ? this[num + this.length] : this[num] :\\n\\n            // Return all the elements in a clean array\\n            _slice.call(this);\\n        },\\n\\n        // Take an array of elements and push it onto the stack\\n        // (returning the new matched element set)\\n        pushStack: function pushStack(elems) {\\n\\n            // Build a new jQuery matched element set\\n            var ret = jQuery.merge(this.constructor(), elems);\\n\\n            // Add the old object onto the stack (as a reference)\\n            ret.prevObject = this;\\n            ret.context = this.context;\\n\\n            // Return the newly-formed element set\\n            return ret;\\n        },\\n\\n        // Execute a callback for every element in the matched set.\\n        // (You can seed the arguments with an array of args, but this is\\n        // only used internally.)\\n        each: function each(callback, args) {\\n            return jQuery.each(this, callback, args);\\n        },\\n\\n        map: function map(callback) {\\n            return this.pushStack(jQuery.map(this, function (elem, i) {\\n                return callback.call(elem, i, elem);\\n            }));\\n        },\\n\\n        slice: function slice() {\\n            return this.pushStack(_slice.apply(this, arguments));\\n        },\\n\\n        first: function first() {\\n            return this.eq(0);\\n        },\\n\\n        last: function last() {\\n            return this.eq(-1);\\n        },\\n\\n        eq: function eq(i) {\\n            var len = this.length,\\n                j = +i + (i < 0 ? len : 0);\\n            return this.pushStack(j >= 0 && j < len ? [this[j]] : []);\\n        },\\n\\n        end: function end() {\\n            return this.prevObject || this.constructor(null);\\n        },\\n\\n        // For internal use only.\\n        // Behaves like an Array\\'s method, not like a jQuery method.\\n        push: push,\\n        sort: arr.sort,\\n        splice: arr.splice\\n    };\\n\\n    jQuery.extend = jQuery.fn.extend = function () {\\n        var options,\\n            name,\\n            src,\\n            copy,\\n            copyIsArray,\\n            clone,\\n            target = arguments[0] || {},\\n            i = 1,\\n            length = arguments.length,\\n            deep = false;\\n\\n        // Handle a deep copy situation\\n        if (typeof target === \"boolean\") {\\n            deep = target;\\n\\n            // skip the boolean and the target\\n            target = arguments[i] || {};\\n            i++;\\n        }\\n\\n        // Handle case when target is a string or something (possible in deep copy)\\n        if ((typeof target === \"undefined\" ? \"undefined\" : _typeof(target)) !== \"object\" && !jQuery.isFunction(target)) {\\n            target = {};\\n        }\\n\\n        // extend jQuery itself if only one argument is passed\\n        if (i === length) {\\n            target = this;\\n            i--;\\n        }\\n\\n        for (; i < length; i++) {\\n            // Only deal with non-null/undefined values\\n            if ((options = arguments[i]) != null) {\\n                // Extend the base object\\n                for (name in options) {\\n                    src = target[name];\\n                    copy = options[name];\\n\\n                    // Prevent never-ending loop\\n                    if (target === copy) {\\n                        continue;\\n                    }\\n\\n                    // Recurse if we\\'re merging plain objects or arrays\\n                    if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {\\n                        if (copyIsArray) {\\n                            copyIsArray = false;\\n                            clone = src && jQuery.isArray(src) ? src : [];\\n                        } else {\\n                            clone = src && jQuery.isPlainObject(src) ? src : {};\\n                        }\\n\\n                        // Never move original objects, clone them\\n                        target[name] = jQuery.extend(deep, clone, copy);\\n\\n                        // Don\\'t bring in undefined values\\n                    } else if (copy !== undefined) {\\n                        target[name] = copy;\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Return the modified object\\n        return target;\\n    };\\n\\n    jQuery.extend({\\n        // Unique for each copy of jQuery on the page\\n        expando: \"jQuery\" + (version + Math.random()).replace(/\\\\D/g, \"\"),\\n\\n        // Assume jQuery is ready without the ready module\\n        isReady: true,\\n\\n        error: function error(msg) {\\n            throw new Error(msg);\\n        },\\n\\n        noop: function noop() {},\\n\\n        // See test/unit/core.js for details concerning isFunction.\\n        // Since version 1.3, DOM methods and functions like alert\\n        // aren\\'t supported. They return false on IE (#2968).\\n        isFunction: function isFunction(obj) {\\n            return jQuery.type(obj) === \"function\";\\n        },\\n\\n        isArray: Array.isArray,\\n\\n        isWindow: function isWindow(obj) {\\n            return obj != null && obj === obj.window;\\n        },\\n\\n        isNumeric: function isNumeric(obj) {\\n            // parseFloat NaNs numeric-cast false positives (null|true|false|\"\")\\n            // ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\\n            // subtraction forces infinities to NaN\\n            return !jQuery.isArray(obj) && obj - parseFloat(obj) >= 0;\\n        },\\n\\n        isPlainObject: function isPlainObject(obj) {\\n            // Not plain objects:\\n            // - Any object or value whose internal [[Class]] property is not \"[object Object]\"\\n            // - DOM nodes\\n            // - window\\n            if (jQuery.type(obj) !== \"object\" || obj.nodeType || jQuery.isWindow(obj)) {\\n                return false;\\n            }\\n\\n            if (obj.constructor && !hasOwn.call(obj.constructor.prototype, \"isPrototypeOf\")) {\\n                return false;\\n            }\\n\\n            // If the function hasn\\'t returned already, we\\'re confident that\\n            // |obj| is a plain object, created by {} or constructed with new Object\\n            return true;\\n        },\\n\\n        isEmptyObject: function isEmptyObject(obj) {\\n            var name;\\n            for (name in obj) {\\n                return false;\\n            }\\n            return true;\\n        },\\n\\n        type: function type(obj) {\\n            if (obj == null) {\\n                return obj + \"\";\\n            }\\n            // Support: Android < 4.0, iOS < 6 (functionish RegExp)\\n            return (typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj)) === \"object\" || typeof obj === \"function\" ? class2type[toString.call(obj)] || \"object\" : typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj);\\n        },\\n\\n        // Evaluates a script in a global context\\n        globalEval: function globalEval(code) {\\n            var script,\\n                indirect = eval;\\n\\n            code = jQuery.trim(code);\\n\\n            if (code) {\\n                // If the code includes a valid, prologue position\\n                // strict mode pragma, execute code by injecting a\\n                // script tag into the document.\\n                if (code.indexOf(\"use strict\") === 1) {\\n                    script = document.createElement(\"script\");\\n                    script.text = code;\\n                    document.head.appendChild(script).parentNode.removeChild(script);\\n                } else {\\n                    // Otherwise, avoid the DOM node creation, insertion\\n                    // and removal by using an indirect global eval\\n                    indirect(code);\\n                }\\n            }\\n        },\\n\\n        // Convert dashed to camelCase; used by the css and data modules\\n        // Microsoft forgot to hump their vendor prefix (#9572)\\n        camelCase: function camelCase(string) {\\n            return string.replace(rmsPrefix, \"ms-\").replace(rdashAlpha, fcamelCase);\\n        },\\n\\n        nodeName: function nodeName(elem, name) {\\n            return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\\n        },\\n\\n        // args is for internal usage only\\n        each: function each(obj, callback, args) {\\n            var value,\\n                i = 0,\\n                length = obj.length,\\n                isArray = isArraylike(obj);\\n\\n            if (args) {\\n                if (isArray) {\\n                    for (; i < length; i++) {\\n                        value = callback.apply(obj[i], args);\\n\\n                        if (value === false) {\\n                            break;\\n                        }\\n                    }\\n                } else {\\n                    for (i in obj) {\\n                        value = callback.apply(obj[i], args);\\n\\n                        if (value === false) {\\n                            break;\\n                        }\\n                    }\\n                }\\n\\n                // A special, fast, case for the most common use of each\\n            } else {\\n                if (isArray) {\\n                    for (; i < length; i++) {\\n                        value = callback.call(obj[i], i, obj[i]);\\n\\n                        if (value === false) {\\n                            break;\\n                        }\\n                    }\\n                } else {\\n                    for (i in obj) {\\n                        value = callback.call(obj[i], i, obj[i]);\\n\\n                        if (value === false) {\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n\\n            return obj;\\n        },\\n\\n        // Support: Android<4.1\\n        trim: function trim(text) {\\n            return text == null ? \"\" : (text + \"\").replace(rtrim, \"\");\\n        },\\n\\n        // results is for internal usage only\\n        makeArray: function makeArray(arr, results) {\\n            var ret = results || [];\\n\\n            if (arr != null) {\\n                if (isArraylike(Object(arr))) {\\n                    jQuery.merge(ret, typeof arr === \"string\" ? [arr] : arr);\\n                } else {\\n                    push.call(ret, arr);\\n                }\\n            }\\n\\n            return ret;\\n        },\\n\\n        inArray: function inArray(elem, arr, i) {\\n            return arr == null ? -1 : indexOf.call(arr, elem, i);\\n        },\\n\\n        merge: function merge(first, second) {\\n            var len = +second.length,\\n                j = 0,\\n                i = first.length;\\n\\n            for (; j < len; j++) {\\n                first[i++] = second[j];\\n            }\\n\\n            first.length = i;\\n\\n            return first;\\n        },\\n\\n        grep: function grep(elems, callback, invert) {\\n            var callbackInverse,\\n                matches = [],\\n                i = 0,\\n                length = elems.length,\\n                callbackExpect = !invert;\\n\\n            // Go through the array, only saving the items\\n            // that pass the validator function\\n            for (; i < length; i++) {\\n                callbackInverse = !callback(elems[i], i);\\n                if (callbackInverse !== callbackExpect) {\\n                    matches.push(elems[i]);\\n                }\\n            }\\n\\n            return matches;\\n        },\\n\\n        // arg is for internal usage only\\n        map: function map(elems, callback, arg) {\\n            var value,\\n                i = 0,\\n                length = elems.length,\\n                isArray = isArraylike(elems),\\n                ret = [];\\n\\n            // Go through the array, translating each of the items to their new values\\n            if (isArray) {\\n                for (; i < length; i++) {\\n                    value = callback(elems[i], i, arg);\\n\\n                    if (value != null) {\\n                        ret.push(value);\\n                    }\\n                }\\n\\n                // Go through every key on the object,\\n            } else {\\n                for (i in elems) {\\n                    value = callback(elems[i], i, arg);\\n\\n                    if (value != null) {\\n                        ret.push(value);\\n                    }\\n                }\\n            }\\n\\n            // Flatten any nested arrays\\n            return concat.apply([], ret);\\n        },\\n\\n        // A global GUID counter for objects\\n        guid: 1,\\n\\n        // Bind a function to a context, optionally partially applying any\\n        // arguments.\\n        proxy: function proxy(fn, context) {\\n            var tmp, args, proxy;\\n\\n            if (typeof context === \"string\") {\\n                tmp = fn[context];\\n                context = fn;\\n                fn = tmp;\\n            }\\n\\n            // Quick check to determine if target is callable, in the spec\\n            // this throws a TypeError, but we will just return undefined.\\n            if (!jQuery.isFunction(fn)) {\\n                return undefined;\\n            }\\n\\n            // Simulated bind\\n            args = _slice.call(arguments, 2);\\n            proxy = function proxy() {\\n                return fn.apply(context || this, args.concat(_slice.call(arguments)));\\n            };\\n\\n            // Set the guid of unique handler to the same of original handler, so it can be removed\\n            proxy.guid = fn.guid = fn.guid || jQuery.guid++;\\n\\n            return proxy;\\n        },\\n\\n        now: Date.now,\\n\\n        // jQuery.support is not used in Core but other projects attach their\\n        // properties to it so it needs to exist.\\n        support: support\\n    });\\n\\n    // Populate the class2type map\\n    jQuery.each(\"Boolean Number String Function Array Date RegExp Object Error\".split(\" \"), function (i, name) {\\n        class2type[\"[object \" + name + \"]\"] = name.toLowerCase();\\n    });\\n\\n    function isArraylike(obj) {\\n        var length = obj.length,\\n            type = jQuery.type(obj);\\n\\n        if (type === \"function\" || jQuery.isWindow(obj)) {\\n            return false;\\n        }\\n\\n        if (obj.nodeType === 1 && length) {\\n            return true;\\n        }\\n\\n        return type === \"array\" || length === 0 || typeof length === \"number\" && length > 0 && length - 1 in obj;\\n    }\\n    var Sizzle =\\n    /*!\\r\\n     * Sizzle CSS Selector Engine v1.10.19\\r\\n     * http://sizzlejs.com/\\r\\n     *\\r\\n     * Copyright 2013 jQuery Foundation, Inc. and other contributors\\r\\n     * Released under the MIT license\\r\\n     * http://jquery.org/license\\r\\n     *\\r\\n     * Date: 2014-04-18\\r\\n     */\\n    function (window) {\\n\\n        var i,\\n            support,\\n            Expr,\\n            getText,\\n            isXML,\\n            tokenize,\\n            compile,\\n            select,\\n            outermostContext,\\n            sortInput,\\n            hasDuplicate,\\n\\n\\n        // Local document vars\\n        setDocument,\\n            document,\\n            docElem,\\n            documentIsHTML,\\n            rbuggyQSA,\\n            rbuggyMatches,\\n            matches,\\n            contains,\\n\\n\\n        // Instance-specific data\\n        expando = \"sizzle\" + -new Date(),\\n            preferredDoc = window.document,\\n            dirruns = 0,\\n            done = 0,\\n            classCache = createCache(),\\n            tokenCache = createCache(),\\n            compilerCache = createCache(),\\n            sortOrder = function sortOrder(a, b) {\\n            if (a === b) {\\n                hasDuplicate = true;\\n            }\\n            return 0;\\n        },\\n\\n\\n        // General-purpose constants\\n        strundefined =  true ? \"undefined\" : undefined,\\n            MAX_NEGATIVE = 1 << 31,\\n\\n\\n        // Instance methods\\n        hasOwn = {}.hasOwnProperty,\\n            arr = [],\\n            pop = arr.pop,\\n            push_native = arr.push,\\n            push = arr.push,\\n            slice = arr.slice,\\n\\n        // Use a stripped-down indexOf if we can\\'t use a native one\\n        indexOf = arr.indexOf || function (elem) {\\n            var i = 0,\\n                len = this.length;\\n            for (; i < len; i++) {\\n                if (this[i] === elem) {\\n                    return i;\\n                }\\n            }\\n            return -1;\\n        },\\n            booleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\\n\\n\\n        // Regular expressions\\n\\n        // Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace\\n        whitespace = \"[\\\\\\\\x20\\\\\\\\t\\\\\\\\r\\\\\\\\n\\\\\\\\f]\",\\n\\n        // http://www.w3.org/TR/css3-syntax/#characters\\n        characterEncoding = \"(?:\\\\\\\\\\\\\\\\.|[\\\\\\\\w-]|[^\\\\\\\\x00-\\\\\\\\xa0])+\",\\n\\n\\n        // Loosely modeled on CSS identifier characters\\n        // An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors\\n        // Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\\n        identifier = characterEncoding.replace(\"w\", \"w#\"),\\n\\n\\n        // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\\n        attributes = \"\\\\\\\\[\" + whitespace + \"*(\" + characterEncoding + \")(?:\" + whitespace +\\n        // Operator (capture 2)\\n        \"*([*^$|!~]?=)\" + whitespace +\\n        // \"Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]\"\\n        \"*(?:\\'((?:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\\\'])*)\\'|\\\\\"((?:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\\\\\\"])*)\\\\\"|(\" + identifier + \"))|)\" + whitespace + \"*\\\\\\\\]\",\\n            pseudos = \":(\" + characterEncoding + \")(?:\\\\\\\\((\" +\\n        // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\\n        // 1. quoted (capture 3; capture 4 or capture 5)\\n        \"(\\'((?:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\\\'])*)\\'|\\\\\"((?:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\\\\\\"])*)\\\\\")|\" +\\n        // 2. simple (capture 6)\\n        \"((?:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\()[\\\\\\\\]]|\" + attributes + \")*)|\" +\\n        // 3. anything else (capture 2)\\n        \".*\" + \")\\\\\\\\)|)\",\\n\\n\\n        // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\\n        rtrim = new RegExp(\"^\" + whitespace + \"+|((?:^|[^\\\\\\\\\\\\\\\\])(?:\\\\\\\\\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\"),\\n            rcomma = new RegExp(\"^\" + whitespace + \"*,\" + whitespace + \"*\"),\\n            rcombinators = new RegExp(\"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\"),\\n            rattributeQuotes = new RegExp(\"=\" + whitespace + \"*([^\\\\\\\\]\\'\\\\\"]*?)\" + whitespace + \"*\\\\\\\\]\", \"g\"),\\n            rpseudo = new RegExp(pseudos),\\n            ridentifier = new RegExp(\"^\" + identifier + \"$\"),\\n            matchExpr = {\\n            \"ID\": new RegExp(\"^#(\" + characterEncoding + \")\"),\\n            \"CLASS\": new RegExp(\"^\\\\\\\\.(\" + characterEncoding + \")\"),\\n            \"TAG\": new RegExp(\"^(\" + characterEncoding.replace(\"w\", \"w*\") + \")\"),\\n            \"ATTR\": new RegExp(\"^\" + attributes),\\n            \"PSEUDO\": new RegExp(\"^\" + pseudos),\\n            \"CHILD\": new RegExp(\"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\\\\\(\" + whitespace + \"*(even|odd|(([+-]|)(\\\\\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace + \"*(\\\\\\\\d+)|))\" + whitespace + \"*\\\\\\\\)|)\", \"i\"),\\n            \"bool\": new RegExp(\"^(?:\" + booleans + \")$\", \"i\"),\\n            // For use in libraries implementing .is()\\n            // We use this for POS matching in `select`\\n            \"needsContext\": new RegExp(\"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\\\\\(\" + whitespace + \"*((?:-\\\\\\\\d)?\\\\\\\\d*)\" + whitespace + \"*\\\\\\\\)|)(?=[^-]|$)\", \"i\")\\n        },\\n            rinputs = /^(?:input|select|textarea|button)$/i,\\n            rheader = /^h\\\\d$/i,\\n            rnative = /^[^{]+\\\\{\\\\s*\\\\[native \\\\w/,\\n\\n\\n        // Easily-parseable/retrievable ID or TAG or CLASS selectors\\n        rquickExpr = /^(?:#([\\\\w-]+)|(\\\\w+)|\\\\.([\\\\w-]+))$/,\\n            rsibling = /[+~]/,\\n            rescape = /\\'|\\\\\\\\/g,\\n\\n\\n        // CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\\n        runescape = new RegExp(\"\\\\\\\\\\\\\\\\([\\\\\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\", \"ig\"),\\n            funescape = function funescape(_, escaped, escapedWhitespace) {\\n            var high = \"0x\" + escaped - 0x10000;\\n            // NaN means non-codepoint\\n            // Support: Firefox<24\\n            // Workaround erroneous numeric interpretation of +\"0x\"\\n            return high !== high || escapedWhitespace ? escaped : high < 0 ?\\n            // BMP codepoint\\n            String.fromCharCode(high + 0x10000) :\\n            // Supplemental Plane codepoint (surrogate pair)\\n            String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);\\n        };\\n\\n        // Optimize for push.apply( _, NodeList )\\n        try {\\n            push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);\\n            // Support: Android<4.0\\n            // Detect silently failing push.apply\\n            arr[preferredDoc.childNodes.length].nodeType;\\n        } catch (e) {\\n            push = {\\n                apply: arr.length ?\\n\\n                // Leverage slice if possible\\n                function (target, els) {\\n                    push_native.apply(target, slice.call(els));\\n                } :\\n\\n                // Support: IE<9\\n                // Otherwise append directly\\n                function (target, els) {\\n                    var j = target.length,\\n                        i = 0;\\n                    // Can\\'t trust NodeList.length\\n                    while (target[j++] = els[i++]) {}\\n                    target.length = j - 1;\\n                }\\n            };\\n        }\\n\\n        function Sizzle(selector, context, results, seed) {\\n            var match, elem, m, nodeType,\\n            // QSA vars\\n            i, groups, old, nid, newContext, newSelector;\\n\\n            if ((context ? context.ownerDocument || context : preferredDoc) !== document) {\\n                setDocument(context);\\n            }\\n\\n            context = context || document;\\n            results = results || [];\\n\\n            if (!selector || typeof selector !== \"string\") {\\n                return results;\\n            }\\n\\n            if ((nodeType = context.nodeType) !== 1 && nodeType !== 9) {\\n                return [];\\n            }\\n\\n            if (documentIsHTML && !seed) {\\n\\n                // Shortcuts\\n                if (match = rquickExpr.exec(selector)) {\\n                    // Speed-up: Sizzle(\"#ID\")\\n                    if (m = match[1]) {\\n                        if (nodeType === 9) {\\n                            elem = context.getElementById(m);\\n                            // Check parentNode to catch when Blackberry 4.6 returns\\n                            // nodes that are no longer in the document (jQuery #6963)\\n                            if (elem && elem.parentNode) {\\n                                // Handle the case where IE, Opera, and Webkit return items\\n                                // by name instead of ID\\n                                if (elem.id === m) {\\n                                    results.push(elem);\\n                                    return results;\\n                                }\\n                            } else {\\n                                return results;\\n                            }\\n                        } else {\\n                            // Context is not a document\\n                            if (context.ownerDocument && (elem = context.ownerDocument.getElementById(m)) && contains(context, elem) && elem.id === m) {\\n                                results.push(elem);\\n                                return results;\\n                            }\\n                        }\\n\\n                        // Speed-up: Sizzle(\"TAG\")\\n                    } else if (match[2]) {\\n                        push.apply(results, context.getElementsByTagName(selector));\\n                        return results;\\n\\n                        // Speed-up: Sizzle(\".CLASS\")\\n                    } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {\\n                        push.apply(results, context.getElementsByClassName(m));\\n                        return results;\\n                    }\\n                }\\n\\n                // QSA path\\n                if (support.qsa && (!rbuggyQSA || !rbuggyQSA.test(selector))) {\\n                    nid = old = expando;\\n                    newContext = context;\\n                    newSelector = nodeType === 9 && selector;\\n\\n                    // qSA works strangely on Element-rooted queries\\n                    // We can work around this by specifying an extra ID on the root\\n                    // and working up from there (Thanks to Andrew Dupont for the technique)\\n                    // IE 8 doesn\\'t work on object elements\\n                    if (nodeType === 1 && context.nodeName.toLowerCase() !== \"object\") {\\n                        groups = tokenize(selector);\\n\\n                        if (old = context.getAttribute(\"id\")) {\\n                            nid = old.replace(rescape, \"\\\\\\\\$&\");\\n                        } else {\\n                            context.setAttribute(\"id\", nid);\\n                        }\\n                        nid = \"[id=\\'\" + nid + \"\\'] \";\\n\\n                        i = groups.length;\\n                        while (i--) {\\n                            groups[i] = nid + toSelector(groups[i]);\\n                        }\\n                        newContext = rsibling.test(selector) && testContext(context.parentNode) || context;\\n                        newSelector = groups.join(\",\");\\n                    }\\n\\n                    if (newSelector) {\\n                        try {\\n                            push.apply(results, newContext.querySelectorAll(newSelector));\\n                            return results;\\n                        } catch (qsaError) {} finally {\\n                            if (!old) {\\n                                context.removeAttribute(\"id\");\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n\\n            // All others\\n            return select(selector.replace(rtrim, \"$1\"), context, results, seed);\\n        }\\n\\n        /**\\r\\n         * Create key-value caches of limited size\\r\\n         * @returns {Function(string, Object)} Returns the Object data after storing it on itself with\\r\\n         *\\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\\r\\n         *\\tdeleting the oldest entry\\r\\n         */\\n        function createCache() {\\n            var keys = [];\\n\\n            function cache(key, value) {\\n                // Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\\n                if (keys.push(key + \" \") > Expr.cacheLength) {\\n                    // Only keep the most recent entries\\n                    delete cache[keys.shift()];\\n                }\\n                return cache[key + \" \"] = value;\\n            }\\n            return cache;\\n        }\\n\\n        /**\\r\\n         * Mark a function for special use by Sizzle\\r\\n         * @param {Function} fn The function to mark\\r\\n         */\\n        function markFunction(fn) {\\n            fn[expando] = true;\\n            return fn;\\n        }\\n\\n        /**\\r\\n         * Support testing using an element\\r\\n         * @param {Function} fn Passed the created div and expects a boolean result\\r\\n         */\\n        function assert(fn) {\\n            var div = document.createElement(\"div\");\\n\\n            try {\\n                return !!fn(div);\\n            } catch (e) {\\n                return false;\\n            } finally {\\n                // Remove from its parent by default\\n                if (div.parentNode) {\\n                    div.parentNode.removeChild(div);\\n                }\\n                // release memory in IE\\n                div = null;\\n            }\\n        }\\n\\n        /**\\r\\n         * Adds the same handler for all of the specified attrs\\r\\n         * @param {String} attrs Pipe-separated list of attributes\\r\\n         * @param {Function} handler The method that will be applied\\r\\n         */\\n        function addHandle(attrs, handler) {\\n            var arr = attrs.split(\"|\"),\\n                i = attrs.length;\\n\\n            while (i--) {\\n                Expr.attrHandle[arr[i]] = handler;\\n            }\\n        }\\n\\n        /**\\r\\n         * Checks document order of two siblings\\r\\n         * @param {Element} a\\r\\n         * @param {Element} b\\r\\n         * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\\r\\n         */\\n        function siblingCheck(a, b) {\\n            var cur = b && a,\\n                diff = cur && a.nodeType === 1 && b.nodeType === 1 && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);\\n\\n            // Use IE sourceIndex if available on both nodes\\n            if (diff) {\\n                return diff;\\n            }\\n\\n            // Check if b follows a\\n            if (cur) {\\n                while (cur = cur.nextSibling) {\\n                    if (cur === b) {\\n                        return -1;\\n                    }\\n                }\\n            }\\n\\n            return a ? 1 : -1;\\n        }\\n\\n        /**\\r\\n         * Returns a function to use in pseudos for input types\\r\\n         * @param {String} type\\r\\n         */\\n        function createInputPseudo(type) {\\n            return function (elem) {\\n                var name = elem.nodeName.toLowerCase();\\n                return name === \"input\" && elem.type === type;\\n            };\\n        }\\n\\n        /**\\r\\n         * Returns a function to use in pseudos for buttons\\r\\n         * @param {String} type\\r\\n         */\\n        function createButtonPseudo(type) {\\n            return function (elem) {\\n                var name = elem.nodeName.toLowerCase();\\n                return (name === \"input\" || name === \"button\") && elem.type === type;\\n            };\\n        }\\n\\n        /**\\r\\n         * Returns a function to use in pseudos for positionals\\r\\n         * @param {Function} fn\\r\\n         */\\n        function createPositionalPseudo(fn) {\\n            return markFunction(function (argument) {\\n                argument = +argument;\\n                return markFunction(function (seed, matches) {\\n                    var j,\\n                        matchIndexes = fn([], seed.length, argument),\\n                        i = matchIndexes.length;\\n\\n                    // Match elements found at the specified indexes\\n                    while (i--) {\\n                        if (seed[j = matchIndexes[i]]) {\\n                            seed[j] = !(matches[j] = seed[j]);\\n                        }\\n                    }\\n                });\\n            });\\n        }\\n\\n        /**\\r\\n         * Checks a node for validity as a Sizzle context\\r\\n         * @param {Element|Object=} context\\r\\n         * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\\r\\n         */\\n        function testContext(context) {\\n            return context && _typeof(context.getElementsByTagName) !== strundefined && context;\\n        }\\n\\n        // Expose support vars for convenience\\n        support = Sizzle.support = {};\\n\\n        /**\\r\\n         * Detects XML nodes\\r\\n         * @param {Element|Object} elem An element or a document\\r\\n         * @returns {Boolean} True iff elem is a non-HTML XML node\\r\\n         */\\n        isXML = Sizzle.isXML = function (elem) {\\n            // documentElement is verified for cases where it doesn\\'t yet exist\\n            // (such as loading iframes in IE - #4833)\\n            var documentElement = elem && (elem.ownerDocument || elem).documentElement;\\n            return documentElement ? documentElement.nodeName !== \"HTML\" : false;\\n        };\\n\\n        /**\\r\\n         * Sets document-related variables once based on the current document\\r\\n         * @param {Element|Object} [doc] An element or document object to use to set the document\\r\\n         * @returns {Object} Returns the current document\\r\\n         */\\n        setDocument = Sizzle.setDocument = function (node) {\\n            var hasCompare,\\n                doc = node ? node.ownerDocument || node : preferredDoc,\\n                parent = doc.defaultView;\\n\\n            // If no document and documentElement is available, return\\n            if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {\\n                return document;\\n            }\\n\\n            // Set our document\\n            document = doc;\\n            docElem = doc.documentElement;\\n\\n            // Support tests\\n            documentIsHTML = !isXML(doc);\\n\\n            // Support: IE>8\\n            // If iframe document is assigned to \"document\" variable and if iframe has been reloaded,\\n            // IE will throw \"permission denied\" error when accessing \"document\" variable, see jQuery #13936\\n            // IE6-8 do not support the defaultView property so parent will be undefined\\n            if (parent && parent !== parent.top) {\\n                // IE11 does not have attachEvent, so all must suffer\\n                if (parent.addEventListener) {\\n                    parent.addEventListener(\"unload\", function () {\\n                        setDocument();\\n                    }, false);\\n                } else if (parent.attachEvent) {\\n                    parent.attachEvent(\"onunload\", function () {\\n                        setDocument();\\n                    });\\n                }\\n            }\\n\\n            /* Attributes\\r\\n            ---------------------------------------------------------------------- */\\n\\n            // Support: IE<8\\n            // Verify that getAttribute really returns attributes and not properties (excepting IE8 booleans)\\n            support.attributes = assert(function (div) {\\n                div.className = \"i\";\\n                return !div.getAttribute(\"className\");\\n            });\\n\\n            /* getElement(s)By*\\r\\n            ---------------------------------------------------------------------- */\\n\\n            // Check if getElementsByTagName(\"*\") returns only elements\\n            support.getElementsByTagName = assert(function (div) {\\n                div.appendChild(doc.createComment(\"\"));\\n                return !div.getElementsByTagName(\"*\").length;\\n            });\\n\\n            // Check if getElementsByClassName can be trusted\\n            support.getElementsByClassName = rnative.test(doc.getElementsByClassName) && assert(function (div) {\\n                div.innerHTML = \"<div class=\\'a\\'></div><div class=\\'a i\\'></div>\";\\n\\n                // Support: Safari<4\\n                // Catch class over-caching\\n                div.firstChild.className = \"i\";\\n                // Support: Opera<10\\n                // Catch gEBCN failure to find non-leading classes\\n                return div.getElementsByClassName(\"i\").length === 2;\\n            });\\n\\n            // Support: IE<10\\n            // Check if getElementById returns elements by name\\n            // The broken getElementById methods don\\'t pick up programatically-set names,\\n            // so use a roundabout getElementsByName test\\n            support.getById = assert(function (div) {\\n                docElem.appendChild(div).id = expando;\\n                return !doc.getElementsByName || !doc.getElementsByName(expando).length;\\n            });\\n\\n            // ID find and filter\\n            if (support.getById) {\\n                Expr.find[\"ID\"] = function (id, context) {\\n                    if (_typeof(context.getElementById) !== strundefined && documentIsHTML) {\\n                        var m = context.getElementById(id);\\n                        // Check parentNode to catch when Blackberry 4.6 returns\\n                        // nodes that are no longer in the document #6963\\n                        return m && m.parentNode ? [m] : [];\\n                    }\\n                };\\n                Expr.filter[\"ID\"] = function (id) {\\n                    var attrId = id.replace(runescape, funescape);\\n                    return function (elem) {\\n                        return elem.getAttribute(\"id\") === attrId;\\n                    };\\n                };\\n            } else {\\n                // Support: IE6/7\\n                // getElementById is not reliable as a find shortcut\\n                delete Expr.find[\"ID\"];\\n\\n                Expr.filter[\"ID\"] = function (id) {\\n                    var attrId = id.replace(runescape, funescape);\\n                    return function (elem) {\\n                        var node = _typeof(elem.getAttributeNode) !== strundefined && elem.getAttributeNode(\"id\");\\n                        return node && node.value === attrId;\\n                    };\\n                };\\n            }\\n\\n            // Tag\\n            Expr.find[\"TAG\"] = support.getElementsByTagName ? function (tag, context) {\\n                if (_typeof(context.getElementsByTagName) !== strundefined) {\\n                    return context.getElementsByTagName(tag);\\n                }\\n            } : function (tag, context) {\\n                var elem,\\n                    tmp = [],\\n                    i = 0,\\n                    results = context.getElementsByTagName(tag);\\n\\n                // Filter out possible comments\\n                if (tag === \"*\") {\\n                    while (elem = results[i++]) {\\n                        if (elem.nodeType === 1) {\\n                            tmp.push(elem);\\n                        }\\n                    }\\n\\n                    return tmp;\\n                }\\n                return results;\\n            };\\n\\n            // Class\\n            Expr.find[\"CLASS\"] = support.getElementsByClassName && function (className, context) {\\n                if (_typeof(context.getElementsByClassName) !== strundefined && documentIsHTML) {\\n                    return context.getElementsByClassName(className);\\n                }\\n            };\\n\\n            /* QSA/matchesSelector\\r\\n            ---------------------------------------------------------------------- */\\n\\n            // QSA and matchesSelector support\\n\\n            // matchesSelector(:active) reports false when true (IE9/Opera 11.5)\\n            rbuggyMatches = [];\\n\\n            // qSa(:focus) reports false when true (Chrome 21)\\n            // We allow this because of a bug in IE8/9 that throws an error\\n            // whenever `document.activeElement` is accessed on an iframe\\n            // So, we allow :focus to pass through QSA all the time to avoid the IE error\\n            // See http://bugs.jquery.com/ticket/13378\\n            rbuggyQSA = [];\\n\\n            if (support.qsa = rnative.test(doc.querySelectorAll)) {\\n                // Build QSA regex\\n                // Regex strategy adopted from Diego Perini\\n                assert(function (div) {\\n                    // Select is set to empty string on purpose\\n                    // This is to test IE\\'s treatment of not explicitly\\n                    // setting a boolean content attribute,\\n                    // since its presence should be enough\\n                    // http://bugs.jquery.com/ticket/12359\\n                    div.innerHTML = \"<select msallowclip=\\'\\'><option selected=\\'\\'></option></select>\";\\n\\n                    // Support: IE8, Opera 11-12.16\\n                    // Nothing should be selected when empty strings follow ^= or $= or *=\\n                    // The test attribute must be unknown in Opera but \"safe\" for WinRT\\n                    // http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\\n                    if (div.querySelectorAll(\"[msallowclip^=\\'\\']\").length) {\\n                        rbuggyQSA.push(\"[*^$]=\" + whitespace + \"*(?:\\'\\'|\\\\\"\\\\\")\");\\n                    }\\n\\n                    // Support: IE8\\n                    // Boolean attributes and \"value\" are not treated correctly\\n                    if (!div.querySelectorAll(\"[selected]\").length) {\\n                        rbuggyQSA.push(\"\\\\\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\");\\n                    }\\n\\n                    // Webkit/Opera - :checked should return selected option elements\\n                    // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\\n                    // IE8 throws error here and will not see later tests\\n                    if (!div.querySelectorAll(\":checked\").length) {\\n                        rbuggyQSA.push(\":checked\");\\n                    }\\n                });\\n\\n                assert(function (div) {\\n                    // Support: Windows 8 Native Apps\\n                    // The type and name attributes are restricted during .innerHTML assignment\\n                    var input = doc.createElement(\"input\");\\n                    input.setAttribute(\"type\", \"hidden\");\\n                    div.appendChild(input).setAttribute(\"name\", \"D\");\\n\\n                    // Support: IE8\\n                    // Enforce case-sensitivity of name attribute\\n                    if (div.querySelectorAll(\"[name=d]\").length) {\\n                        rbuggyQSA.push(\"name\" + whitespace + \"*[*^$|!~]?=\");\\n                    }\\n\\n                    // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\\n                    // IE8 throws error here and will not see later tests\\n                    if (!div.querySelectorAll(\":enabled\").length) {\\n                        rbuggyQSA.push(\":enabled\", \":disabled\");\\n                    }\\n\\n                    // Opera 10-11 does not throw on post-comma invalid pseudos\\n                    div.querySelectorAll(\"*,:x\");\\n                    rbuggyQSA.push(\",.*:\");\\n                });\\n            }\\n\\n            if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {\\n\\n                assert(function (div) {\\n                    // Check to see if it\\'s possible to do matchesSelector\\n                    // on a disconnected node (IE 9)\\n                    support.disconnectedMatch = matches.call(div, \"div\");\\n\\n                    // This should fail with an exception\\n                    // Gecko does not error, returns false instead\\n                    matches.call(div, \"[s!=\\'\\']:x\");\\n                    rbuggyMatches.push(\"!=\", pseudos);\\n                });\\n            }\\n\\n            rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join(\"|\"));\\n            rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join(\"|\"));\\n\\n            /* Contains\\r\\n            ---------------------------------------------------------------------- */\\n            hasCompare = rnative.test(docElem.compareDocumentPosition);\\n\\n            // Element contains another\\n            // Purposefully does not implement inclusive descendent\\n            // As in, an element does not contain itself\\n            contains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {\\n                var adown = a.nodeType === 9 ? a.documentElement : a,\\n                    bup = b && b.parentNode;\\n                return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));\\n            } : function (a, b) {\\n                if (b) {\\n                    while (b = b.parentNode) {\\n                        if (b === a) {\\n                            return true;\\n                        }\\n                    }\\n                }\\n                return false;\\n            };\\n\\n            /* Sorting\\r\\n            ---------------------------------------------------------------------- */\\n\\n            // Document order sorting\\n            sortOrder = hasCompare ? function (a, b) {\\n\\n                // Flag for duplicate removal\\n                if (a === b) {\\n                    hasDuplicate = true;\\n                    return 0;\\n                }\\n\\n                // Sort on method existence if only one input has compareDocumentPosition\\n                var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\\n                if (compare) {\\n                    return compare;\\n                }\\n\\n                // Calculate position if both inputs belong to the same document\\n                compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) :\\n\\n                // Otherwise we know they are disconnected\\n                1;\\n\\n                // Disconnected nodes\\n                if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {\\n\\n                    // Choose the first element that is related to our preferred document\\n                    if (a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {\\n                        return -1;\\n                    }\\n                    if (b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {\\n                        return 1;\\n                    }\\n\\n                    // Maintain original order\\n                    return sortInput ? indexOf.call(sortInput, a) - indexOf.call(sortInput, b) : 0;\\n                }\\n\\n                return compare & 4 ? -1 : 1;\\n            } : function (a, b) {\\n                // Exit early if the nodes are identical\\n                if (a === b) {\\n                    hasDuplicate = true;\\n                    return 0;\\n                }\\n\\n                var cur,\\n                    i = 0,\\n                    aup = a.parentNode,\\n                    bup = b.parentNode,\\n                    ap = [a],\\n                    bp = [b];\\n\\n                // Parentless nodes are either documents or disconnected\\n                if (!aup || !bup) {\\n                    return a === doc ? -1 : b === doc ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf.call(sortInput, a) - indexOf.call(sortInput, b) : 0;\\n\\n                    // If the nodes are siblings, we can do a quick check\\n                } else if (aup === bup) {\\n                    return siblingCheck(a, b);\\n                }\\n\\n                // Otherwise we need full lists of their ancestors for comparison\\n                cur = a;\\n                while (cur = cur.parentNode) {\\n                    ap.unshift(cur);\\n                }\\n                cur = b;\\n                while (cur = cur.parentNode) {\\n                    bp.unshift(cur);\\n                }\\n\\n                // Walk down the tree looking for a discrepancy\\n                while (ap[i] === bp[i]) {\\n                    i++;\\n                }\\n\\n                return i ?\\n                // Do a sibling check if the nodes have a common ancestor\\n                siblingCheck(ap[i], bp[i]) :\\n\\n                // Otherwise nodes in our document sort first\\n                ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;\\n            };\\n\\n            return doc;\\n        };\\n\\n        Sizzle.matches = function (expr, elements) {\\n            return Sizzle(expr, null, null, elements);\\n        };\\n\\n        Sizzle.matchesSelector = function (elem, expr) {\\n            // Set document vars if needed\\n            if ((elem.ownerDocument || elem) !== document) {\\n                setDocument(elem);\\n            }\\n\\n            // Make sure that attribute selectors are quoted\\n            expr = expr.replace(rattributeQuotes, \"=\\'$1\\']\");\\n\\n            if (support.matchesSelector && documentIsHTML && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {\\n\\n                try {\\n                    var ret = matches.call(elem, expr);\\n\\n                    // IE 9\\'s matchesSelector returns false on disconnected nodes\\n                    if (ret || support.disconnectedMatch ||\\n                    // As well, disconnected nodes are said to be in a document\\n                    // fragment in IE 9\\n                    elem.document && elem.document.nodeType !== 11) {\\n                        return ret;\\n                    }\\n                } catch (e) {}\\n            }\\n\\n            return Sizzle(expr, document, null, [elem]).length > 0;\\n        };\\n\\n        Sizzle.contains = function (context, elem) {\\n            // Set document vars if needed\\n            if ((context.ownerDocument || context) !== document) {\\n                setDocument(context);\\n            }\\n            return contains(context, elem);\\n        };\\n\\n        Sizzle.attr = function (elem, name) {\\n            // Set document vars if needed\\n            if ((elem.ownerDocument || elem) !== document) {\\n                setDocument(elem);\\n            }\\n\\n            var fn = Expr.attrHandle[name.toLowerCase()],\\n\\n            // Don\\'t get fooled by Object.prototype properties (jQuery #13807)\\n            val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;\\n\\n            return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;\\n        };\\n\\n        Sizzle.error = function (msg) {\\n            throw new Error(\"Syntax error, unrecognized expression: \" + msg);\\n        };\\n\\n        /**\\r\\n         * Document sorting and removing duplicates\\r\\n         * @param {ArrayLike} results\\r\\n         */\\n        Sizzle.uniqueSort = function (results) {\\n            var elem,\\n                duplicates = [],\\n                j = 0,\\n                i = 0;\\n\\n            // Unless we *know* we can detect duplicates, assume their presence\\n            hasDuplicate = !support.detectDuplicates;\\n            sortInput = !support.sortStable && results.slice(0);\\n            results.sort(sortOrder);\\n\\n            if (hasDuplicate) {\\n                while (elem = results[i++]) {\\n                    if (elem === results[i]) {\\n                        j = duplicates.push(i);\\n                    }\\n                }\\n                while (j--) {\\n                    results.splice(duplicates[j], 1);\\n                }\\n            }\\n\\n            // Clear input after sorting to release objects\\n            // See https://github.com/jquery/sizzle/pull/225\\n            sortInput = null;\\n\\n            return results;\\n        };\\n\\n        /**\\r\\n         * Utility function for retrieving the text value of an array of DOM nodes\\r\\n         * @param {Array|Element} elem\\r\\n         */\\n        getText = Sizzle.getText = function (elem) {\\n            var node,\\n                ret = \"\",\\n                i = 0,\\n                nodeType = elem.nodeType;\\n\\n            if (!nodeType) {\\n                // If no nodeType, this is expected to be an array\\n                while (node = elem[i++]) {\\n                    // Do not traverse comment nodes\\n                    ret += getText(node);\\n                }\\n            } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {\\n                // Use textContent for elements\\n                // innerText usage removed for consistency of new lines (jQuery #11153)\\n                if (typeof elem.textContent === \"string\") {\\n                    return elem.textContent;\\n                } else {\\n                    // Traverse its children\\n                    for (elem = elem.firstChild; elem; elem = elem.nextSibling) {\\n                        ret += getText(elem);\\n                    }\\n                }\\n            } else if (nodeType === 3 || nodeType === 4) {\\n                return elem.nodeValue;\\n            }\\n            // Do not include comment or processing instruction nodes\\n\\n            return ret;\\n        };\\n\\n        Expr = Sizzle.selectors = {\\n\\n            // Can be adjusted by the user\\n            cacheLength: 50,\\n\\n            createPseudo: markFunction,\\n\\n            match: matchExpr,\\n\\n            attrHandle: {},\\n\\n            find: {},\\n\\n            relative: {\\n                \">\": { dir: \"parentNode\", first: true },\\n                \" \": { dir: \"parentNode\" },\\n                \"+\": { dir: \"previousSibling\", first: true },\\n                \"~\": { dir: \"previousSibling\" }\\n            },\\n\\n            preFilter: {\\n                \"ATTR\": function ATTR(match) {\\n                    match[1] = match[1].replace(runescape, funescape);\\n\\n                    // Move the given value to match[3] whether quoted or unquoted\\n                    match[3] = (match[3] || match[4] || match[5] || \"\").replace(runescape, funescape);\\n\\n                    if (match[2] === \"~=\") {\\n                        match[3] = \" \" + match[3] + \" \";\\n                    }\\n\\n                    return match.slice(0, 4);\\n                },\\n\\n                \"CHILD\": function CHILD(match) {\\n                    /* matches from matchExpr[\"CHILD\"]\\r\\n                    \\t1 type (only|nth|...)\\r\\n                    \\t2 what (child|of-type)\\r\\n                    \\t3 argument (even|odd|\\\\d*|\\\\d*n([+-]\\\\d+)?|...)\\r\\n                    \\t4 xn-component of xn+y argument ([+-]?\\\\d*n|)\\r\\n                    \\t5 sign of xn-component\\r\\n                    \\t6 x of xn-component\\r\\n                    \\t7 sign of y-component\\r\\n                    \\t8 y of y-component\\r\\n                    */\\n                    match[1] = match[1].toLowerCase();\\n\\n                    if (match[1].slice(0, 3) === \"nth\") {\\n                        // nth-* requires argument\\n                        if (!match[3]) {\\n                            Sizzle.error(match[0]);\\n                        }\\n\\n                        // numeric x and y parameters for Expr.filter.CHILD\\n                        // remember that false/true cast respectively to 0/1\\n                        match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === \"even\" || match[3] === \"odd\"));\\n                        match[5] = +(match[7] + match[8] || match[3] === \"odd\");\\n\\n                        // other types prohibit arguments\\n                    } else if (match[3]) {\\n                        Sizzle.error(match[0]);\\n                    }\\n\\n                    return match;\\n                },\\n\\n                \"PSEUDO\": function PSEUDO(match) {\\n                    var excess,\\n                        unquoted = !match[6] && match[2];\\n\\n                    if (matchExpr[\"CHILD\"].test(match[0])) {\\n                        return null;\\n                    }\\n\\n                    // Accept quoted arguments as-is\\n                    if (match[3]) {\\n                        match[2] = match[4] || match[5] || \"\";\\n\\n                        // Strip excess characters from unquoted arguments\\n                    } else if (unquoted && rpseudo.test(unquoted) && (\\n                    // Get excess from tokenize (recursively)\\n                    excess = tokenize(unquoted, true)) && (\\n                    // advance to the next closing parenthesis\\n                    excess = unquoted.indexOf(\")\", unquoted.length - excess) - unquoted.length)) {\\n\\n                        // excess is a negative index\\n                        match[0] = match[0].slice(0, excess);\\n                        match[2] = unquoted.slice(0, excess);\\n                    }\\n\\n                    // Return only captures needed by the pseudo filter method (type and argument)\\n                    return match.slice(0, 3);\\n                }\\n            },\\n\\n            filter: {\\n\\n                \"TAG\": function TAG(nodeNameSelector) {\\n                    var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();\\n                    return nodeNameSelector === \"*\" ? function () {\\n                        return true;\\n                    } : function (elem) {\\n                        return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\\n                    };\\n                },\\n\\n                \"CLASS\": function CLASS(className) {\\n                    var pattern = classCache[className + \" \"];\\n\\n                    return pattern || (pattern = new RegExp(\"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\")) && classCache(className, function (elem) {\\n                        return pattern.test(typeof elem.className === \"string\" && elem.className || _typeof(elem.getAttribute) !== strundefined && elem.getAttribute(\"class\") || \"\");\\n                    });\\n                },\\n\\n                \"ATTR\": function ATTR(name, operator, check) {\\n                    return function (elem) {\\n                        var result = Sizzle.attr(elem, name);\\n\\n                        if (result == null) {\\n                            return operator === \"!=\";\\n                        }\\n                        if (!operator) {\\n                            return true;\\n                        }\\n\\n                        result += \"\";\\n\\n                        return operator === \"=\" ? result === check : operator === \"!=\" ? result !== check : operator === \"^=\" ? check && result.indexOf(check) === 0 : operator === \"*=\" ? check && result.indexOf(check) > -1 : operator === \"$=\" ? check && result.slice(-check.length) === check : operator === \"~=\" ? (\" \" + result + \" \").indexOf(check) > -1 : operator === \"|=\" ? result === check || result.slice(0, check.length + 1) === check + \"-\" : false;\\n                    };\\n                },\\n\\n                \"CHILD\": function CHILD(type, what, argument, first, last) {\\n                    var simple = type.slice(0, 3) !== \"nth\",\\n                        forward = type.slice(-4) !== \"last\",\\n                        ofType = what === \"of-type\";\\n\\n                    return first === 1 && last === 0 ?\\n\\n                    // Shortcut for :nth-*(n)\\n                    function (elem) {\\n                        return !!elem.parentNode;\\n                    } : function (elem, context, xml) {\\n                        var cache,\\n                            outerCache,\\n                            node,\\n                            diff,\\n                            nodeIndex,\\n                            start,\\n                            dir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\\n                            parent = elem.parentNode,\\n                            name = ofType && elem.nodeName.toLowerCase(),\\n                            useCache = !xml && !ofType;\\n\\n                        if (parent) {\\n\\n                            // :(first|last|only)-(child|of-type)\\n                            if (simple) {\\n                                while (dir) {\\n                                    node = elem;\\n                                    while (node = node[dir]) {\\n                                        if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {\\n                                            return false;\\n                                        }\\n                                    }\\n                                    // Reverse direction for :only-* (if we haven\\'t yet done so)\\n                                    start = dir = type === \"only\" && !start && \"nextSibling\";\\n                                }\\n                                return true;\\n                            }\\n\\n                            start = [forward ? parent.firstChild : parent.lastChild];\\n\\n                            // non-xml :nth-child(...) stores cache data on `parent`\\n                            if (forward && useCache) {\\n                                // Seek `elem` from a previously-cached index\\n                                outerCache = parent[expando] || (parent[expando] = {});\\n                                cache = outerCache[type] || [];\\n                                nodeIndex = cache[0] === dirruns && cache[1];\\n                                diff = cache[0] === dirruns && cache[2];\\n                                node = nodeIndex && parent.childNodes[nodeIndex];\\n\\n                                while (node = ++nodeIndex && node && node[dir] || (\\n\\n                                // Fallback to seeking `elem` from the start\\n                                diff = nodeIndex = 0) || start.pop()) {\\n\\n                                    // When found, cache indexes on `parent` and break\\n                                    if (node.nodeType === 1 && ++diff && node === elem) {\\n                                        outerCache[type] = [dirruns, nodeIndex, diff];\\n                                        break;\\n                                    }\\n                                }\\n\\n                                // Use previously-cached element index if available\\n                            } else if (useCache && (cache = (elem[expando] || (elem[expando] = {}))[type]) && cache[0] === dirruns) {\\n                                diff = cache[1];\\n\\n                                // xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)\\n                            } else {\\n                                // Use the same loop as above to seek `elem` from the start\\n                                while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {\\n\\n                                    if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {\\n                                        // Cache the index of each encountered element\\n                                        if (useCache) {\\n                                            (node[expando] || (node[expando] = {}))[type] = [dirruns, diff];\\n                                        }\\n\\n                                        if (node === elem) {\\n                                            break;\\n                                        }\\n                                    }\\n                                }\\n                            }\\n\\n                            // Incorporate the offset, then check against cycle size\\n                            diff -= last;\\n                            return diff === first || diff % first === 0 && diff / first >= 0;\\n                        }\\n                    };\\n                },\\n\\n                \"PSEUDO\": function PSEUDO(pseudo, argument) {\\n                    // pseudo-class names are case-insensitive\\n                    // http://www.w3.org/TR/selectors/#pseudo-classes\\n                    // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\\n                    // Remember that setFilters inherits from pseudos\\n                    var args,\\n                        fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error(\"unsupported pseudo: \" + pseudo);\\n\\n                    // The user may use createPseudo to indicate that\\n                    // arguments are needed to create the filter function\\n                    // just as Sizzle does\\n                    if (fn[expando]) {\\n                        return fn(argument);\\n                    }\\n\\n                    // But maintain support for old signatures\\n                    if (fn.length > 1) {\\n                        args = [pseudo, pseudo, \"\", argument];\\n                        return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {\\n                            var idx,\\n                                matched = fn(seed, argument),\\n                                i = matched.length;\\n                            while (i--) {\\n                                idx = indexOf.call(seed, matched[i]);\\n                                seed[idx] = !(matches[idx] = matched[i]);\\n                            }\\n                        }) : function (elem) {\\n                            return fn(elem, 0, args);\\n                        };\\n                    }\\n\\n                    return fn;\\n                }\\n            },\\n\\n            pseudos: {\\n                // Potentially complex pseudos\\n                \"not\": markFunction(function (selector) {\\n                    // Trim the selector passed to compile\\n                    // to avoid treating leading and trailing\\n                    // spaces as combinators\\n                    var input = [],\\n                        results = [],\\n                        matcher = compile(selector.replace(rtrim, \"$1\"));\\n\\n                    return matcher[expando] ? markFunction(function (seed, matches, context, xml) {\\n                        var elem,\\n                            unmatched = matcher(seed, null, xml, []),\\n                            i = seed.length;\\n\\n                        // Match elements unmatched by `matcher`\\n                        while (i--) {\\n                            if (elem = unmatched[i]) {\\n                                seed[i] = !(matches[i] = elem);\\n                            }\\n                        }\\n                    }) : function (elem, context, xml) {\\n                        input[0] = elem;\\n                        matcher(input, null, xml, results);\\n                        return !results.pop();\\n                    };\\n                }),\\n\\n                \"has\": markFunction(function (selector) {\\n                    return function (elem) {\\n                        return Sizzle(selector, elem).length > 0;\\n                    };\\n                }),\\n\\n                \"contains\": markFunction(function (text) {\\n                    return function (elem) {\\n                        return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;\\n                    };\\n                }),\\n\\n                // \"Whether an element is represented by a :lang() selector\\n                // is based solely on the element\\'s language value\\n                // being equal to the identifier C,\\n                // or beginning with the identifier C immediately followed by \"-\".\\n                // The matching of C against the element\\'s language value is performed case-insensitively.\\n                // The identifier C does not have to be a valid language name.\"\\n                // http://www.w3.org/TR/selectors/#lang-pseudo\\n                \"lang\": markFunction(function (lang) {\\n                    // lang value must be a valid identifier\\n                    if (!ridentifier.test(lang || \"\")) {\\n                        Sizzle.error(\"unsupported lang: \" + lang);\\n                    }\\n                    lang = lang.replace(runescape, funescape).toLowerCase();\\n                    return function (elem) {\\n                        var elemLang;\\n                        do {\\n                            if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\")) {\\n\\n                                elemLang = elemLang.toLowerCase();\\n                                return elemLang === lang || elemLang.indexOf(lang + \"-\") === 0;\\n                            }\\n                        } while ((elem = elem.parentNode) && elem.nodeType === 1);\\n                        return false;\\n                    };\\n                }),\\n\\n                // Miscellaneous\\n                \"target\": function target(elem) {\\n                    var hash = window.location && window.location.hash;\\n                    return hash && hash.slice(1) === elem.id;\\n                },\\n\\n                \"root\": function root(elem) {\\n                    return elem === docElem;\\n                },\\n\\n                \"focus\": function focus(elem) {\\n                    return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\\n                },\\n\\n                // Boolean properties\\n                \"enabled\": function enabled(elem) {\\n                    return elem.disabled === false;\\n                },\\n\\n                \"disabled\": function disabled(elem) {\\n                    return elem.disabled === true;\\n                },\\n\\n                \"checked\": function checked(elem) {\\n                    // In CSS3, :checked should return both checked and selected elements\\n                    // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\\n                    var nodeName = elem.nodeName.toLowerCase();\\n                    return nodeName === \"input\" && !!elem.checked || nodeName === \"option\" && !!elem.selected;\\n                },\\n\\n                \"selected\": function selected(elem) {\\n                    // Accessing this property makes selected-by-default\\n                    // options in Safari work properly\\n                    if (elem.parentNode) {\\n                        elem.parentNode.selectedIndex;\\n                    }\\n\\n                    return elem.selected === true;\\n                },\\n\\n                // Contents\\n                \"empty\": function empty(elem) {\\n                    // http://www.w3.org/TR/selectors/#empty-pseudo\\n                    // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\\n                    //   but not by others (comment: 8; processing instruction: 7; etc.)\\n                    // nodeType < 6 works because attributes (2) do not appear as children\\n                    for (elem = elem.firstChild; elem; elem = elem.nextSibling) {\\n                        if (elem.nodeType < 6) {\\n                            return false;\\n                        }\\n                    }\\n                    return true;\\n                },\\n\\n                \"parent\": function parent(elem) {\\n                    return !Expr.pseudos[\"empty\"](elem);\\n                },\\n\\n                // Element/input types\\n                \"header\": function header(elem) {\\n                    return rheader.test(elem.nodeName);\\n                },\\n\\n                \"input\": function input(elem) {\\n                    return rinputs.test(elem.nodeName);\\n                },\\n\\n                \"button\": function button(elem) {\\n                    var name = elem.nodeName.toLowerCase();\\n                    return name === \"input\" && elem.type === \"button\" || name === \"button\";\\n                },\\n\\n                \"text\": function text(elem) {\\n                    var attr;\\n                    return elem.nodeName.toLowerCase() === \"input\" && elem.type === \"text\" && (\\n\\n                    // Support: IE<8\\n                    // New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\\n                    (attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === \"text\");\\n                },\\n\\n                // Position-in-collection\\n                \"first\": createPositionalPseudo(function () {\\n                    return [0];\\n                }),\\n\\n                \"last\": createPositionalPseudo(function (matchIndexes, length) {\\n                    return [length - 1];\\n                }),\\n\\n                \"eq\": createPositionalPseudo(function (matchIndexes, length, argument) {\\n                    return [argument < 0 ? argument + length : argument];\\n                }),\\n\\n                \"even\": createPositionalPseudo(function (matchIndexes, length) {\\n                    var i = 0;\\n                    for (; i < length; i += 2) {\\n                        matchIndexes.push(i);\\n                    }\\n                    return matchIndexes;\\n                }),\\n\\n                \"odd\": createPositionalPseudo(function (matchIndexes, length) {\\n                    var i = 1;\\n                    for (; i < length; i += 2) {\\n                        matchIndexes.push(i);\\n                    }\\n                    return matchIndexes;\\n                }),\\n\\n                \"lt\": createPositionalPseudo(function (matchIndexes, length, argument) {\\n                    var i = argument < 0 ? argument + length : argument;\\n                    for (; --i >= 0;) {\\n                        matchIndexes.push(i);\\n                    }\\n                    return matchIndexes;\\n                }),\\n\\n                \"gt\": createPositionalPseudo(function (matchIndexes, length, argument) {\\n                    var i = argument < 0 ? argument + length : argument;\\n                    for (; ++i < length;) {\\n                        matchIndexes.push(i);\\n                    }\\n                    return matchIndexes;\\n                })\\n            }\\n        };\\n\\n        Expr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"];\\n\\n        // Add button/input type pseudos\\n        for (i in { radio: true, checkbox: true, file: true, password: true, image: true }) {\\n            Expr.pseudos[i] = createInputPseudo(i);\\n        }\\n        for (i in { submit: true, reset: true }) {\\n            Expr.pseudos[i] = createButtonPseudo(i);\\n        }\\n\\n        // Easy API for creating new setFilters\\n        function setFilters() {}\\n        setFilters.prototype = Expr.filters = Expr.pseudos;\\n        Expr.setFilters = new setFilters();\\n\\n        tokenize = Sizzle.tokenize = function (selector, parseOnly) {\\n            var matched,\\n                match,\\n                tokens,\\n                type,\\n                soFar,\\n                groups,\\n                preFilters,\\n                cached = tokenCache[selector + \" \"];\\n\\n            if (cached) {\\n                return parseOnly ? 0 : cached.slice(0);\\n            }\\n\\n            soFar = selector;\\n            groups = [];\\n            preFilters = Expr.preFilter;\\n\\n            while (soFar) {\\n\\n                // Comma and first run\\n                if (!matched || (match = rcomma.exec(soFar))) {\\n                    if (match) {\\n                        // Don\\'t consume trailing commas as valid\\n                        soFar = soFar.slice(match[0].length) || soFar;\\n                    }\\n                    groups.push(tokens = []);\\n                }\\n\\n                matched = false;\\n\\n                // Combinators\\n                if (match = rcombinators.exec(soFar)) {\\n                    matched = match.shift();\\n                    tokens.push({\\n                        value: matched,\\n                        // Cast descendant combinators to space\\n                        type: match[0].replace(rtrim, \" \")\\n                    });\\n                    soFar = soFar.slice(matched.length);\\n                }\\n\\n                // Filters\\n                for (type in Expr.filter) {\\n                    if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {\\n                        matched = match.shift();\\n                        tokens.push({\\n                            value: matched,\\n                            type: type,\\n                            matches: match\\n                        });\\n                        soFar = soFar.slice(matched.length);\\n                    }\\n                }\\n\\n                if (!matched) {\\n                    break;\\n                }\\n            }\\n\\n            // Return the length of the invalid excess\\n            // if we\\'re just parsing\\n            // Otherwise, throw an error or return tokens\\n            return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) :\\n            // Cache the tokens\\n            tokenCache(selector, groups).slice(0);\\n        };\\n\\n        function toSelector(tokens) {\\n            var i = 0,\\n                len = tokens.length,\\n                selector = \"\";\\n            for (; i < len; i++) {\\n                selector += tokens[i].value;\\n            }\\n            return selector;\\n        }\\n\\n        function addCombinator(matcher, combinator, base) {\\n            var dir = combinator.dir,\\n                checkNonElements = base && dir === \"parentNode\",\\n                doneName = done++;\\n\\n            return combinator.first ?\\n            // Check against closest ancestor/preceding element\\n            function (elem, context, xml) {\\n                while (elem = elem[dir]) {\\n                    if (elem.nodeType === 1 || checkNonElements) {\\n                        return matcher(elem, context, xml);\\n                    }\\n                }\\n            } :\\n\\n            // Check against all ancestor/preceding elements\\n            function (elem, context, xml) {\\n                var oldCache,\\n                    outerCache,\\n                    newCache = [dirruns, doneName];\\n\\n                // We can\\'t set arbitrary data on XML nodes, so they don\\'t benefit from dir caching\\n                if (xml) {\\n                    while (elem = elem[dir]) {\\n                        if (elem.nodeType === 1 || checkNonElements) {\\n                            if (matcher(elem, context, xml)) {\\n                                return true;\\n                            }\\n                        }\\n                    }\\n                } else {\\n                    while (elem = elem[dir]) {\\n                        if (elem.nodeType === 1 || checkNonElements) {\\n                            outerCache = elem[expando] || (elem[expando] = {});\\n                            if ((oldCache = outerCache[dir]) && oldCache[0] === dirruns && oldCache[1] === doneName) {\\n\\n                                // Assign to newCache so results back-propagate to previous elements\\n                                return newCache[2] = oldCache[2];\\n                            } else {\\n                                // Reuse newcache so results back-propagate to previous elements\\n                                outerCache[dir] = newCache;\\n\\n                                // A match means we\\'re done; a fail means we have to keep checking\\n                                if (newCache[2] = matcher(elem, context, xml)) {\\n                                    return true;\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n            };\\n        }\\n\\n        function elementMatcher(matchers) {\\n            return matchers.length > 1 ? function (elem, context, xml) {\\n                var i = matchers.length;\\n                while (i--) {\\n                    if (!matchers[i](elem, context, xml)) {\\n                        return false;\\n                    }\\n                }\\n                return true;\\n            } : matchers[0];\\n        }\\n\\n        function multipleContexts(selector, contexts, results) {\\n            var i = 0,\\n                len = contexts.length;\\n            for (; i < len; i++) {\\n                Sizzle(selector, contexts[i], results);\\n            }\\n            return results;\\n        }\\n\\n        function condense(unmatched, map, filter, context, xml) {\\n            var elem,\\n                newUnmatched = [],\\n                i = 0,\\n                len = unmatched.length,\\n                mapped = map != null;\\n\\n            for (; i < len; i++) {\\n                if (elem = unmatched[i]) {\\n                    if (!filter || filter(elem, context, xml)) {\\n                        newUnmatched.push(elem);\\n                        if (mapped) {\\n                            map.push(i);\\n                        }\\n                    }\\n                }\\n            }\\n\\n            return newUnmatched;\\n        }\\n\\n        function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {\\n            if (postFilter && !postFilter[expando]) {\\n                postFilter = setMatcher(postFilter);\\n            }\\n            if (postFinder && !postFinder[expando]) {\\n                postFinder = setMatcher(postFinder, postSelector);\\n            }\\n            return markFunction(function (seed, results, context, xml) {\\n                var temp,\\n                    i,\\n                    elem,\\n                    preMap = [],\\n                    postMap = [],\\n                    preexisting = results.length,\\n\\n\\n                // Get initial elements from seed or context\\n                elems = seed || multipleContexts(selector || \"*\", context.nodeType ? [context] : context, []),\\n\\n\\n                // Prefilter to get matcher input, preserving a map for seed-results synchronization\\n                matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,\\n                    matcherOut = matcher ?\\n                // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\\n                postFinder || (seed ? preFilter : preexisting || postFilter) ?\\n\\n                // ...intermediate processing is necessary\\n                [] :\\n\\n                // ...otherwise use results directly\\n                results : matcherIn;\\n\\n                // Find primary matches\\n                if (matcher) {\\n                    matcher(matcherIn, matcherOut, context, xml);\\n                }\\n\\n                // Apply postFilter\\n                if (postFilter) {\\n                    temp = condense(matcherOut, postMap);\\n                    postFilter(temp, [], context, xml);\\n\\n                    // Un-match failing elements by moving them back to matcherIn\\n                    i = temp.length;\\n                    while (i--) {\\n                        if (elem = temp[i]) {\\n                            matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);\\n                        }\\n                    }\\n                }\\n\\n                if (seed) {\\n                    if (postFinder || preFilter) {\\n                        if (postFinder) {\\n                            // Get the final matcherOut by condensing this intermediate into postFinder contexts\\n                            temp = [];\\n                            i = matcherOut.length;\\n                            while (i--) {\\n                                if (elem = matcherOut[i]) {\\n                                    // Restore matcherIn since elem is not yet a final match\\n                                    temp.push(matcherIn[i] = elem);\\n                                }\\n                            }\\n                            postFinder(null, matcherOut = [], temp, xml);\\n                        }\\n\\n                        // Move matched elements from seed to results to keep them synchronized\\n                        i = matcherOut.length;\\n                        while (i--) {\\n                            if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf.call(seed, elem) : preMap[i]) > -1) {\\n\\n                                seed[temp] = !(results[temp] = elem);\\n                            }\\n                        }\\n                    }\\n\\n                    // Add elements to results, through postFinder if defined\\n                } else {\\n                    matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);\\n                    if (postFinder) {\\n                        postFinder(null, results, matcherOut, xml);\\n                    } else {\\n                        push.apply(results, matcherOut);\\n                    }\\n                }\\n            });\\n        }\\n\\n        function matcherFromTokens(tokens) {\\n            var checkContext,\\n                matcher,\\n                j,\\n                len = tokens.length,\\n                leadingRelative = Expr.relative[tokens[0].type],\\n                implicitRelative = leadingRelative || Expr.relative[\" \"],\\n                i = leadingRelative ? 1 : 0,\\n\\n\\n            // The foundational matcher ensures that elements are reachable from top-level context(s)\\n            matchContext = addCombinator(function (elem) {\\n                return elem === checkContext;\\n            }, implicitRelative, true),\\n                matchAnyContext = addCombinator(function (elem) {\\n                return indexOf.call(checkContext, elem) > -1;\\n            }, implicitRelative, true),\\n                matchers = [function (elem, context, xml) {\\n                return !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));\\n            }];\\n\\n            for (; i < len; i++) {\\n                if (matcher = Expr.relative[tokens[i].type]) {\\n                    matchers = [addCombinator(elementMatcher(matchers), matcher)];\\n                } else {\\n                    matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);\\n\\n                    // Return special upon seeing a positional matcher\\n                    if (matcher[expando]) {\\n                        // Find the next relative operator (if any) for proper handling\\n                        j = ++i;\\n                        for (; j < len; j++) {\\n                            if (Expr.relative[tokens[j].type]) {\\n                                break;\\n                            }\\n                        }\\n                        return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(\\n                        // If the preceding token was a descendant combinator, insert an implicit any-element `*`\\n                        tokens.slice(0, i - 1).concat({ value: tokens[i - 2].type === \" \" ? \"*\" : \"\" })).replace(rtrim, \"$1\"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));\\n                    }\\n                    matchers.push(matcher);\\n                }\\n            }\\n\\n            return elementMatcher(matchers);\\n        }\\n\\n        function matcherFromGroupMatchers(elementMatchers, setMatchers) {\\n            var bySet = setMatchers.length > 0,\\n                byElement = elementMatchers.length > 0,\\n                superMatcher = function superMatcher(seed, context, xml, results, outermost) {\\n                var elem,\\n                    j,\\n                    matcher,\\n                    matchedCount = 0,\\n                    i = \"0\",\\n                    unmatched = seed && [],\\n                    setMatched = [],\\n                    contextBackup = outermostContext,\\n\\n                // We must always have either seed elements or outermost context\\n                elems = seed || byElement && Expr.find[\"TAG\"](\"*\", outermost),\\n\\n                // Use integer dirruns iff this is the outermost matcher\\n                dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1,\\n                    len = elems.length;\\n\\n                if (outermost) {\\n                    outermostContext = context !== document && context;\\n                }\\n\\n                // Add elements passing elementMatchers directly to results\\n                // Keep `i` a string if there are no elements so `matchedCount` will be \"00\" below\\n                // Support: IE<9, Safari\\n                // Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\\n                for (; i !== len && (elem = elems[i]) != null; i++) {\\n                    if (byElement && elem) {\\n                        j = 0;\\n                        while (matcher = elementMatchers[j++]) {\\n                            if (matcher(elem, context, xml)) {\\n                                results.push(elem);\\n                                break;\\n                            }\\n                        }\\n                        if (outermost) {\\n                            dirruns = dirrunsUnique;\\n                        }\\n                    }\\n\\n                    // Track unmatched elements for set filters\\n                    if (bySet) {\\n                        // They will have gone through all possible matchers\\n                        if (elem = !matcher && elem) {\\n                            matchedCount--;\\n                        }\\n\\n                        // Lengthen the array for every element, matched or not\\n                        if (seed) {\\n                            unmatched.push(elem);\\n                        }\\n                    }\\n                }\\n\\n                // Apply set filters to unmatched elements\\n                matchedCount += i;\\n                if (bySet && i !== matchedCount) {\\n                    j = 0;\\n                    while (matcher = setMatchers[j++]) {\\n                        matcher(unmatched, setMatched, context, xml);\\n                    }\\n\\n                    if (seed) {\\n                        // Reintegrate element matches to eliminate the need for sorting\\n                        if (matchedCount > 0) {\\n                            while (i--) {\\n                                if (!(unmatched[i] || setMatched[i])) {\\n                                    setMatched[i] = pop.call(results);\\n                                }\\n                            }\\n                        }\\n\\n                        // Discard index placeholder values to get only actual matches\\n                        setMatched = condense(setMatched);\\n                    }\\n\\n                    // Add matches to results\\n                    push.apply(results, setMatched);\\n\\n                    // Seedless set matches succeeding multiple successful matchers stipulate sorting\\n                    if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {\\n\\n                        Sizzle.uniqueSort(results);\\n                    }\\n                }\\n\\n                // Override manipulation of globals by nested matchers\\n                if (outermost) {\\n                    dirruns = dirrunsUnique;\\n                    outermostContext = contextBackup;\\n                }\\n\\n                return unmatched;\\n            };\\n\\n            return bySet ? markFunction(superMatcher) : superMatcher;\\n        }\\n\\n        compile = Sizzle.compile = function (selector, match /* Internal Use Only */) {\\n            var i,\\n                setMatchers = [],\\n                elementMatchers = [],\\n                cached = compilerCache[selector + \" \"];\\n\\n            if (!cached) {\\n                // Generate a function of recursive functions that can be used to check each element\\n                if (!match) {\\n                    match = tokenize(selector);\\n                }\\n                i = match.length;\\n                while (i--) {\\n                    cached = matcherFromTokens(match[i]);\\n                    if (cached[expando]) {\\n                        setMatchers.push(cached);\\n                    } else {\\n                        elementMatchers.push(cached);\\n                    }\\n                }\\n\\n                // Cache the compiled function\\n                cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));\\n\\n                // Save selector and tokenization\\n                cached.selector = selector;\\n            }\\n            return cached;\\n        };\\n\\n        /**\\r\\n         * A low-level selection function that works with Sizzle\\'s compiled\\r\\n         *  selector functions\\r\\n         * @param {String|Function} selector A selector or a pre-compiled\\r\\n         *  selector function built with Sizzle.compile\\r\\n         * @param {Element} context\\r\\n         * @param {Array} [results]\\r\\n         * @param {Array} [seed] A set of elements to match against\\r\\n         */\\n        select = Sizzle.select = function (selector, context, results, seed) {\\n            var i,\\n                tokens,\\n                token,\\n                type,\\n                find,\\n                compiled = typeof selector === \"function\" && selector,\\n                match = !seed && tokenize(selector = compiled.selector || selector);\\n\\n            results = results || [];\\n\\n            // Try to minimize operations if there is no seed and only one group\\n            if (match.length === 1) {\\n\\n                // Take a shortcut and set the context if the root selector is an ID\\n                tokens = match[0] = match[0].slice(0);\\n                if (tokens.length > 2 && (token = tokens[0]).type === \"ID\" && support.getById && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {\\n\\n                    context = (Expr.find[\"ID\"](token.matches[0].replace(runescape, funescape), context) || [])[0];\\n                    if (!context) {\\n                        return results;\\n\\n                        // Precompiled matchers will still verify ancestry, so step up a level\\n                    } else if (compiled) {\\n                        context = context.parentNode;\\n                    }\\n\\n                    selector = selector.slice(tokens.shift().value.length);\\n                }\\n\\n                // Fetch a seed set for right-to-left matching\\n                i = matchExpr[\"needsContext\"].test(selector) ? 0 : tokens.length;\\n                while (i--) {\\n                    token = tokens[i];\\n\\n                    // Abort if we hit a combinator\\n                    if (Expr.relative[type = token.type]) {\\n                        break;\\n                    }\\n                    if (find = Expr.find[type]) {\\n                        // Search, expanding context for leading sibling combinators\\n                        if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {\\n\\n                            // If seed is empty or no tokens remain, we can return early\\n                            tokens.splice(i, 1);\\n                            selector = seed.length && toSelector(tokens);\\n                            if (!selector) {\\n                                push.apply(results, seed);\\n                                return results;\\n                            }\\n\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n\\n            // Compile and execute a filtering function if one is not provided\\n            // Provide `match` to avoid retokenization if we modified the selector above\\n            (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, rsibling.test(selector) && testContext(context.parentNode) || context);\\n            return results;\\n        };\\n\\n        // One-time assignments\\n\\n        // Sort stability\\n        support.sortStable = expando.split(\"\").sort(sortOrder).join(\"\") === expando;\\n\\n        // Support: Chrome<14\\n        // Always assume duplicates if they aren\\'t passed to the comparison function\\n        support.detectDuplicates = !!hasDuplicate;\\n\\n        // Initialize against the default document\\n        setDocument();\\n\\n        // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\\n        // Detached nodes confoundingly follow *each other*\\n        support.sortDetached = assert(function (div1) {\\n            // Should return 1, but returns 4 (following)\\n            return div1.compareDocumentPosition(document.createElement(\"div\")) & 1;\\n        });\\n\\n        // Support: IE<8\\n        // Prevent attribute/property \"interpolation\"\\n        // http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\\n        if (!assert(function (div) {\\n            div.innerHTML = \"<a href=\\'#\\'></a>\";\\n            return div.firstChild.getAttribute(\"href\") === \"#\";\\n        })) {\\n            addHandle(\"type|href|height|width\", function (elem, name, isXML) {\\n                if (!isXML) {\\n                    return elem.getAttribute(name, name.toLowerCase() === \"type\" ? 1 : 2);\\n                }\\n            });\\n        }\\n\\n        // Support: IE<9\\n        // Use defaultValue in place of getAttribute(\"value\")\\n        if (!support.attributes || !assert(function (div) {\\n            div.innerHTML = \"<input/>\";\\n            div.firstChild.setAttribute(\"value\", \"\");\\n            return div.firstChild.getAttribute(\"value\") === \"\";\\n        })) {\\n            addHandle(\"value\", function (elem, name, isXML) {\\n                if (!isXML && elem.nodeName.toLowerCase() === \"input\") {\\n                    return elem.defaultValue;\\n                }\\n            });\\n        }\\n\\n        // Support: IE<9\\n        // Use getAttributeNode to fetch booleans when getAttribute lies\\n        if (!assert(function (div) {\\n            return div.getAttribute(\"disabled\") == null;\\n        })) {\\n            addHandle(booleans, function (elem, name, isXML) {\\n                var val;\\n                if (!isXML) {\\n                    return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;\\n                }\\n            });\\n        }\\n\\n        return Sizzle;\\n    }(window);\\n\\n    jQuery.find = Sizzle;\\n    jQuery.expr = Sizzle.selectors;\\n    jQuery.expr[\":\"] = jQuery.expr.pseudos;\\n    jQuery.unique = Sizzle.uniqueSort;\\n    jQuery.text = Sizzle.getText;\\n    jQuery.isXMLDoc = Sizzle.isXML;\\n    jQuery.contains = Sizzle.contains;\\n\\n    var rneedsContext = jQuery.expr.match.needsContext;\\n\\n    var rsingleTag = /^<(\\\\w+)\\\\s*\\\\/?>(?:<\\\\/\\\\1>|)$/;\\n\\n    var risSimple = /^.[^:#\\\\[\\\\.,]*$/;\\n\\n    // Implement the identical functionality for filter and not\\n    function winnow(elements, qualifier, not) {\\n        if (jQuery.isFunction(qualifier)) {\\n            return jQuery.grep(elements, function (elem, i) {\\n                /* jshint -W018 */\\n                return !!qualifier.call(elem, i, elem) !== not;\\n            });\\n        }\\n\\n        if (qualifier.nodeType) {\\n            return jQuery.grep(elements, function (elem) {\\n                return elem === qualifier !== not;\\n            });\\n        }\\n\\n        if (typeof qualifier === \"string\") {\\n            if (risSimple.test(qualifier)) {\\n                return jQuery.filter(qualifier, elements, not);\\n            }\\n\\n            qualifier = jQuery.filter(qualifier, elements);\\n        }\\n\\n        return jQuery.grep(elements, function (elem) {\\n            return indexOf.call(qualifier, elem) >= 0 !== not;\\n        });\\n    }\\n\\n    jQuery.filter = function (expr, elems, not) {\\n        var elem = elems[0];\\n\\n        if (not) {\\n            expr = \":not(\" + expr + \")\";\\n        }\\n\\n        return elems.length === 1 && elem.nodeType === 1 ? jQuery.find.matchesSelector(elem, expr) ? [elem] : [] : jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {\\n            return elem.nodeType === 1;\\n        }));\\n    };\\n\\n    jQuery.fn.extend({\\n        find: function find(selector) {\\n            var i,\\n                len = this.length,\\n                ret = [],\\n                self = this;\\n\\n            if (typeof selector !== \"string\") {\\n                return this.pushStack(jQuery(selector).filter(function () {\\n                    for (i = 0; i < len; i++) {\\n                        if (jQuery.contains(self[i], this)) {\\n                            return true;\\n                        }\\n                    }\\n                }));\\n            }\\n\\n            for (i = 0; i < len; i++) {\\n                jQuery.find(selector, self[i], ret);\\n            }\\n\\n            // Needed because $( selector, context ) becomes $( context ).find( selector )\\n            ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);\\n            ret.selector = this.selector ? this.selector + \" \" + selector : selector;\\n            return ret;\\n        },\\n        filter: function filter(selector) {\\n            return this.pushStack(winnow(this, selector || [], false));\\n        },\\n        not: function not(selector) {\\n            return this.pushStack(winnow(this, selector || [], true));\\n        },\\n        is: function is(selector) {\\n            return !!winnow(this,\\n\\n            // If this is a positional/relative selector, check membership in the returned set\\n            // so $(\"p:first\").is(\"p:last\") won\\'t return true for a doc with two \"p\".\\n            typeof selector === \"string\" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;\\n        }\\n    });\\n\\n    // Initialize a jQuery object\\n\\n\\n    // A central reference to the root jQuery(document)\\n    var rootjQuery,\\n\\n\\n    // A simple way to check for HTML strings\\n    // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\\n    // Strict HTML recognition (#11290: must start with <)\\n    rquickExpr = /^(?:\\\\s*(<[\\\\w\\\\W]+>)[^>]*|#([\\\\w-]*))$/,\\n        init = jQuery.fn.init = function (selector, context) {\\n        var match, elem;\\n\\n        // HANDLE: $(\"\"), $(null), $(undefined), $(false)\\n        if (!selector) {\\n            return this;\\n        }\\n\\n        // Handle HTML strings\\n        if (typeof selector === \"string\") {\\n            if (selector[0] === \"<\" && selector[selector.length - 1] === \">\" && selector.length >= 3) {\\n                // Assume that strings that start and end with <> are HTML and skip the regex check\\n                match = [null, selector, null];\\n            } else {\\n                match = rquickExpr.exec(selector);\\n            }\\n\\n            // Match html or make sure no context is specified for #id\\n            if (match && (match[1] || !context)) {\\n\\n                // HANDLE: $(html) -> $(array)\\n                if (match[1]) {\\n                    context = context instanceof jQuery ? context[0] : context;\\n\\n                    // scripts is true for back-compat\\n                    // Intentionally let the error be thrown if parseHTML is not present\\n                    jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));\\n\\n                    // HANDLE: $(html, props)\\n                    if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {\\n                        for (match in context) {\\n                            // Properties of context are called as methods if possible\\n                            if (jQuery.isFunction(this[match])) {\\n                                this[match](context[match]);\\n\\n                                // ...and otherwise set as attributes\\n                            } else {\\n                                this.attr(match, context[match]);\\n                            }\\n                        }\\n                    }\\n\\n                    return this;\\n\\n                    // HANDLE: $(#id)\\n                } else {\\n                    elem = document.getElementById(match[2]);\\n\\n                    // Check parentNode to catch when Blackberry 4.6 returns\\n                    // nodes that are no longer in the document #6963\\n                    if (elem && elem.parentNode) {\\n                        // Inject the element directly into the jQuery object\\n                        this.length = 1;\\n                        this[0] = elem;\\n                    }\\n\\n                    this.context = document;\\n                    this.selector = selector;\\n                    return this;\\n                }\\n\\n                // HANDLE: $(expr, $(...))\\n            } else if (!context || context.jquery) {\\n                return (context || rootjQuery).find(selector);\\n\\n                // HANDLE: $(expr, context)\\n                // (which is just equivalent to: $(context).find(expr)\\n            } else {\\n                return this.constructor(context).find(selector);\\n            }\\n\\n            // HANDLE: $(DOMElement)\\n        } else if (selector.nodeType) {\\n            this.context = this[0] = selector;\\n            this.length = 1;\\n            return this;\\n\\n            // HANDLE: $(function)\\n            // Shortcut for document ready\\n        } else if (jQuery.isFunction(selector)) {\\n            return typeof rootjQuery.ready !== \"undefined\" ? rootjQuery.ready(selector) :\\n            // Execute immediately if ready is not present\\n            selector(jQuery);\\n        }\\n\\n        if (selector.selector !== undefined) {\\n            this.selector = selector.selector;\\n            this.context = selector.context;\\n        }\\n\\n        return jQuery.makeArray(selector, this);\\n    };\\n\\n    // Give the init function the jQuery prototype for later instantiation\\n    init.prototype = jQuery.fn;\\n\\n    // Initialize central reference\\n    rootjQuery = jQuery(document);\\n\\n    var rparentsprev = /^(?:parents|prev(?:Until|All))/,\\n\\n    // methods guaranteed to produce a unique set when starting from a unique set\\n    guaranteedUnique = {\\n        children: true,\\n        contents: true,\\n        next: true,\\n        prev: true\\n    };\\n\\n    jQuery.extend({\\n        dir: function dir(elem, _dir, until) {\\n            var matched = [],\\n                truncate = until !== undefined;\\n\\n            while ((elem = elem[_dir]) && elem.nodeType !== 9) {\\n                if (elem.nodeType === 1) {\\n                    if (truncate && jQuery(elem).is(until)) {\\n                        break;\\n                    }\\n                    matched.push(elem);\\n                }\\n            }\\n            return matched;\\n        },\\n\\n        sibling: function sibling(n, elem) {\\n            var matched = [];\\n\\n            for (; n; n = n.nextSibling) {\\n                if (n.nodeType === 1 && n !== elem) {\\n                    matched.push(n);\\n                }\\n            }\\n\\n            return matched;\\n        }\\n    });\\n\\n    jQuery.fn.extend({\\n        has: function has(target) {\\n            var targets = jQuery(target, this),\\n                l = targets.length;\\n\\n            return this.filter(function () {\\n                var i = 0;\\n                for (; i < l; i++) {\\n                    if (jQuery.contains(this, targets[i])) {\\n                        return true;\\n                    }\\n                }\\n            });\\n        },\\n\\n        closest: function closest(selectors, context) {\\n            var cur,\\n                i = 0,\\n                l = this.length,\\n                matched = [],\\n                pos = rneedsContext.test(selectors) || typeof selectors !== \"string\" ? jQuery(selectors, context || this.context) : 0;\\n\\n            for (; i < l; i++) {\\n                for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {\\n                    // Always skip document fragments\\n                    if (cur.nodeType < 11 && (pos ? pos.index(cur) > -1 :\\n\\n                    // Don\\'t pass non-elements to Sizzle\\n                    cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {\\n\\n                        matched.push(cur);\\n                        break;\\n                    }\\n                }\\n            }\\n\\n            return this.pushStack(matched.length > 1 ? jQuery.unique(matched) : matched);\\n        },\\n\\n        // Determine the position of an element within\\n        // the matched set of elements\\n        index: function index(elem) {\\n\\n            // No argument, return index in parent\\n            if (!elem) {\\n                return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;\\n            }\\n\\n            // index in selector\\n            if (typeof elem === \"string\") {\\n                return indexOf.call(jQuery(elem), this[0]);\\n            }\\n\\n            // Locate the position of the desired element\\n            return indexOf.call(this,\\n\\n            // If it receives a jQuery object, the first element is used\\n            elem.jquery ? elem[0] : elem);\\n        },\\n\\n        add: function add(selector, context) {\\n            return this.pushStack(jQuery.unique(jQuery.merge(this.get(), jQuery(selector, context))));\\n        },\\n\\n        addBack: function addBack(selector) {\\n            return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));\\n        }\\n    });\\n\\n    function sibling(cur, dir) {\\n        while ((cur = cur[dir]) && cur.nodeType !== 1) {}\\n        return cur;\\n    }\\n\\n    jQuery.each({\\n        parent: function parent(elem) {\\n            var parent = elem.parentNode;\\n            return parent && parent.nodeType !== 11 ? parent : null;\\n        },\\n        parents: function parents(elem) {\\n            return jQuery.dir(elem, \"parentNode\");\\n        },\\n        parentsUntil: function parentsUntil(elem, i, until) {\\n            return jQuery.dir(elem, \"parentNode\", until);\\n        },\\n        next: function next(elem) {\\n            return sibling(elem, \"nextSibling\");\\n        },\\n        prev: function prev(elem) {\\n            return sibling(elem, \"previousSibling\");\\n        },\\n        nextAll: function nextAll(elem) {\\n            return jQuery.dir(elem, \"nextSibling\");\\n        },\\n        prevAll: function prevAll(elem) {\\n            return jQuery.dir(elem, \"previousSibling\");\\n        },\\n        nextUntil: function nextUntil(elem, i, until) {\\n            return jQuery.dir(elem, \"nextSibling\", until);\\n        },\\n        prevUntil: function prevUntil(elem, i, until) {\\n            return jQuery.dir(elem, \"previousSibling\", until);\\n        },\\n        siblings: function siblings(elem) {\\n            return jQuery.sibling((elem.parentNode || {}).firstChild, elem);\\n        },\\n        children: function children(elem) {\\n            return jQuery.sibling(elem.firstChild);\\n        },\\n        contents: function contents(elem) {\\n            return elem.contentDocument || jQuery.merge([], elem.childNodes);\\n        }\\n    }, function (name, fn) {\\n        jQuery.fn[name] = function (until, selector) {\\n            var matched = jQuery.map(this, fn, until);\\n\\n            if (name.slice(-5) !== \"Until\") {\\n                selector = until;\\n            }\\n\\n            if (selector && typeof selector === \"string\") {\\n                matched = jQuery.filter(selector, matched);\\n            }\\n\\n            if (this.length > 1) {\\n                // Remove duplicates\\n                if (!guaranteedUnique[name]) {\\n                    jQuery.unique(matched);\\n                }\\n\\n                // Reverse order for parents* and prev-derivatives\\n                if (rparentsprev.test(name)) {\\n                    matched.reverse();\\n                }\\n            }\\n\\n            return this.pushStack(matched);\\n        };\\n    });\\n    var rnotwhite = /\\\\S+/g;\\n\\n    // String to Object options format cache\\n    var optionsCache = {};\\n\\n    // Convert String-formatted options into Object-formatted ones and store in cache\\n    function createOptions(options) {\\n        var object = optionsCache[options] = {};\\n        jQuery.each(options.match(rnotwhite) || [], function (_, flag) {\\n            object[flag] = true;\\n        });\\n        return object;\\n    }\\n\\n    /*\\r\\n     * Create a callback list using the following parameters:\\r\\n     *\\r\\n     *\\toptions: an optional list of space-separated options that will change how\\r\\n     *\\t\\t\\tthe callback list behaves or a more traditional option object\\r\\n     *\\r\\n     * By default a callback list will act like an event callback list and can be\\r\\n     * \"fired\" multiple times.\\r\\n     *\\r\\n     * Possible options:\\r\\n     *\\r\\n     *\\tonce:\\t\\t\\twill ensure the callback list can only be fired once (like a Deferred)\\r\\n     *\\r\\n     *\\tmemory:\\t\\t\\twill keep track of previous values and will call any callback added\\r\\n     *\\t\\t\\t\\t\\tafter the list has been fired right away with the latest \"memorized\"\\r\\n     *\\t\\t\\t\\t\\tvalues (like a Deferred)\\r\\n     *\\r\\n     *\\tunique:\\t\\t\\twill ensure a callback can only be added once (no duplicate in the list)\\r\\n     *\\r\\n     *\\tstopOnFalse:\\tinterrupt callings when a callback returns false\\r\\n     *\\r\\n     */\\n    jQuery.Callbacks = function (options) {\\n\\n        // Convert options from String-formatted to Object-formatted if needed\\n        // (we check in cache first)\\n        options = typeof options === \"string\" ? optionsCache[options] || createOptions(options) : jQuery.extend({}, options);\\n\\n        var // Last fire value (for non-forgettable lists)\\n        memory,\\n\\n        // Flag to know if list was already fired\\n        _fired,\\n\\n        // Flag to know if list is currently firing\\n        firing,\\n\\n        // First callback to fire (used internally by add and fireWith)\\n        firingStart,\\n\\n        // End of the loop when firing\\n        firingLength,\\n\\n        // Index of currently firing callback (modified by remove if needed)\\n        firingIndex,\\n\\n        // Actual callback list\\n        list = [],\\n\\n        // Stack of fire calls for repeatable lists\\n        stack = !options.once && [],\\n\\n        // Fire callbacks\\n        fire = function fire(data) {\\n            memory = options.memory && data;\\n            _fired = true;\\n            firingIndex = firingStart || 0;\\n            firingStart = 0;\\n            firingLength = list.length;\\n            firing = true;\\n            for (; list && firingIndex < firingLength; firingIndex++) {\\n                if (list[firingIndex].apply(data[0], data[1]) === false && options.stopOnFalse) {\\n                    memory = false; // To prevent further calls using add\\n                    break;\\n                }\\n            }\\n            firing = false;\\n            if (list) {\\n                if (stack) {\\n                    if (stack.length) {\\n                        fire(stack.shift());\\n                    }\\n                } else if (memory) {\\n                    list = [];\\n                } else {\\n                    self.disable();\\n                }\\n            }\\n        },\\n\\n        // Actual Callbacks object\\n        self = {\\n            // Add a callback or a collection of callbacks to the list\\n            add: function add() {\\n                if (list) {\\n                    // First, we save the current length\\n                    var start = list.length;\\n                    (function add(args) {\\n                        jQuery.each(args, function (_, arg) {\\n                            var type = jQuery.type(arg);\\n                            if (type === \"function\") {\\n                                if (!options.unique || !self.has(arg)) {\\n                                    list.push(arg);\\n                                }\\n                            } else if (arg && arg.length && type !== \"string\") {\\n                                // Inspect recursively\\n                                add(arg);\\n                            }\\n                        });\\n                    })(arguments);\\n                    // Do we need to add the callbacks to the\\n                    // current firing batch?\\n                    if (firing) {\\n                        firingLength = list.length;\\n                        // With memory, if we\\'re not firing then\\n                        // we should call right away\\n                    } else if (memory) {\\n                        firingStart = start;\\n                        fire(memory);\\n                    }\\n                }\\n                return this;\\n            },\\n            // Remove a callback from the list\\n            remove: function remove() {\\n                if (list) {\\n                    jQuery.each(arguments, function (_, arg) {\\n                        var index;\\n                        while ((index = jQuery.inArray(arg, list, index)) > -1) {\\n                            list.splice(index, 1);\\n                            // Handle firing indexes\\n                            if (firing) {\\n                                if (index <= firingLength) {\\n                                    firingLength--;\\n                                }\\n                                if (index <= firingIndex) {\\n                                    firingIndex--;\\n                                }\\n                            }\\n                        }\\n                    });\\n                }\\n                return this;\\n            },\\n            // Check if a given callback is in the list.\\n            // If no argument is given, return whether or not list has callbacks attached.\\n            has: function has(fn) {\\n                return fn ? jQuery.inArray(fn, list) > -1 : !!(list && list.length);\\n            },\\n            // Remove all callbacks from the list\\n            empty: function empty() {\\n                list = [];\\n                firingLength = 0;\\n                return this;\\n            },\\n            // Have the list do nothing anymore\\n            disable: function disable() {\\n                list = stack = memory = undefined;\\n                return this;\\n            },\\n            // Is it disabled?\\n            disabled: function disabled() {\\n                return !list;\\n            },\\n            // Lock the list in its current state\\n            lock: function lock() {\\n                stack = undefined;\\n                if (!memory) {\\n                    self.disable();\\n                }\\n                return this;\\n            },\\n            // Is it locked?\\n            locked: function locked() {\\n                return !stack;\\n            },\\n            // Call all callbacks with the given context and arguments\\n            fireWith: function fireWith(context, args) {\\n                if (list && (!_fired || stack)) {\\n                    args = args || [];\\n                    args = [context, args.slice ? args.slice() : args];\\n                    if (firing) {\\n                        stack.push(args);\\n                    } else {\\n                        fire(args);\\n                    }\\n                }\\n                return this;\\n            },\\n            // Call all the callbacks with the given arguments\\n            fire: function fire() {\\n                self.fireWith(this, arguments);\\n                return this;\\n            },\\n            // To know if the callbacks have already been called at least once\\n            fired: function fired() {\\n                return !!_fired;\\n            }\\n        };\\n\\n        return self;\\n    };\\n\\n    jQuery.extend({\\n\\n        Deferred: function Deferred(func) {\\n            var tuples = [\\n            // action, add listener, listener list, final state\\n            [\"resolve\", \"done\", jQuery.Callbacks(\"once memory\"), \"resolved\"], [\"reject\", \"fail\", jQuery.Callbacks(\"once memory\"), \"rejected\"], [\"notify\", \"progress\", jQuery.Callbacks(\"memory\")]],\\n                _state = \"pending\",\\n                _promise = {\\n                state: function state() {\\n                    return _state;\\n                },\\n                always: function always() {\\n                    deferred.done(arguments).fail(arguments);\\n                    return this;\\n                },\\n                then: function then() /* fnDone, fnFail, fnProgress */{\\n                    var fns = arguments;\\n                    return jQuery.Deferred(function (newDefer) {\\n                        jQuery.each(tuples, function (i, tuple) {\\n                            var fn = jQuery.isFunction(fns[i]) && fns[i];\\n                            // deferred[ done | fail | progress ] for forwarding actions to newDefer\\n                            deferred[tuple[1]](function () {\\n                                var returned = fn && fn.apply(this, arguments);\\n                                if (returned && jQuery.isFunction(returned.promise)) {\\n                                    returned.promise().done(newDefer.resolve).fail(newDefer.reject).progress(newDefer.notify);\\n                                } else {\\n                                    newDefer[tuple[0] + \"With\"](this === _promise ? newDefer.promise() : this, fn ? [returned] : arguments);\\n                                }\\n                            });\\n                        });\\n                        fns = null;\\n                    }).promise();\\n                },\\n                // Get a promise for this deferred\\n                // If obj is provided, the promise aspect is added to the object\\n                promise: function promise(obj) {\\n                    return obj != null ? jQuery.extend(obj, _promise) : _promise;\\n                }\\n            },\\n                deferred = {};\\n\\n            // Keep pipe for back-compat\\n            _promise.pipe = _promise.then;\\n\\n            // Add list-specific methods\\n            jQuery.each(tuples, function (i, tuple) {\\n                var list = tuple[2],\\n                    stateString = tuple[3];\\n\\n                // promise[ done | fail | progress ] = list.add\\n                _promise[tuple[1]] = list.add;\\n\\n                // Handle state\\n                if (stateString) {\\n                    list.add(function () {\\n                        // state = [ resolved | rejected ]\\n                        _state = stateString;\\n\\n                        // [ reject_list | resolve_list ].disable; progress_list.lock\\n                    }, tuples[i ^ 1][2].disable, tuples[2][2].lock);\\n                }\\n\\n                // deferred[ resolve | reject | notify ]\\n                deferred[tuple[0]] = function () {\\n                    deferred[tuple[0] + \"With\"](this === deferred ? _promise : this, arguments);\\n                    return this;\\n                };\\n                deferred[tuple[0] + \"With\"] = list.fireWith;\\n            });\\n\\n            // Make the deferred a promise\\n            _promise.promise(deferred);\\n\\n            // Call given func if any\\n            if (func) {\\n                func.call(deferred, deferred);\\n            }\\n\\n            // All done!\\n            return deferred;\\n        },\\n\\n        // Deferred helper\\n        when: function when(subordinate /* , ..., subordinateN */) {\\n            var i = 0,\\n                resolveValues = _slice.call(arguments),\\n                length = resolveValues.length,\\n\\n\\n            // the count of uncompleted subordinates\\n            remaining = length !== 1 || subordinate && jQuery.isFunction(subordinate.promise) ? length : 0,\\n\\n\\n            // the master Deferred. If resolveValues consist of only a single Deferred, just use that.\\n            deferred = remaining === 1 ? subordinate : jQuery.Deferred(),\\n\\n\\n            // Update function for both resolve and progress values\\n            updateFunc = function updateFunc(i, contexts, values) {\\n                return function (value) {\\n                    contexts[i] = this;\\n                    values[i] = arguments.length > 1 ? _slice.call(arguments) : value;\\n                    if (values === progressValues) {\\n                        deferred.notifyWith(contexts, values);\\n                    } else if (! --remaining) {\\n                        deferred.resolveWith(contexts, values);\\n                    }\\n                };\\n            },\\n                progressValues,\\n                progressContexts,\\n                resolveContexts;\\n\\n            // add listeners to Deferred subordinates; treat others as resolved\\n            if (length > 1) {\\n                progressValues = new Array(length);\\n                progressContexts = new Array(length);\\n                resolveContexts = new Array(length);\\n                for (; i < length; i++) {\\n                    if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {\\n                        resolveValues[i].promise().done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject).progress(updateFunc(i, progressContexts, progressValues));\\n                    } else {\\n                        --remaining;\\n                    }\\n                }\\n            }\\n\\n            // if we\\'re not waiting on anything, resolve the master\\n            if (!remaining) {\\n                deferred.resolveWith(resolveContexts, resolveValues);\\n            }\\n\\n            return deferred.promise();\\n        }\\n    });\\n\\n    // The deferred used on DOM ready\\n    var readyList;\\n\\n    jQuery.fn.ready = function (fn) {\\n        // Add the callback\\n        jQuery.ready.promise().done(fn);\\n\\n        return this;\\n    };\\n\\n    jQuery.extend({\\n        // Is the DOM ready to be used? Set to true once it occurs.\\n        isReady: false,\\n\\n        // A counter to track how many items to wait for before\\n        // the ready event fires. See #6781\\n        readyWait: 1,\\n\\n        // Hold (or release) the ready event\\n        holdReady: function holdReady(hold) {\\n            if (hold) {\\n                jQuery.readyWait++;\\n            } else {\\n                jQuery.ready(true);\\n            }\\n        },\\n\\n        // Handle when the DOM is ready\\n        ready: function ready(wait) {\\n\\n            // Abort if there are pending holds or we\\'re already ready\\n            if (wait === true ? --jQuery.readyWait : jQuery.isReady) {\\n                return;\\n            }\\n\\n            // Remember that the DOM is ready\\n            jQuery.isReady = true;\\n\\n            // If a normal DOM Ready event fired, decrement, and wait if need be\\n            if (wait !== true && --jQuery.readyWait > 0) {\\n                return;\\n            }\\n\\n            // If there are functions bound, to execute\\n            readyList.resolveWith(document, [jQuery]);\\n\\n            // Trigger any bound ready events\\n            if (jQuery.fn.triggerHandler) {\\n                jQuery(document).triggerHandler(\"ready\");\\n                jQuery(document).off(\"ready\");\\n            }\\n        }\\n    });\\n\\n    /**\\r\\n     * The ready event handler and self cleanup method\\r\\n     */\\n    function completed() {\\n        document.removeEventListener(\"DOMContentLoaded\", completed, false);\\n        window.removeEventListener(\"load\", completed, false);\\n        jQuery.ready();\\n    }\\n\\n    jQuery.ready.promise = function (obj) {\\n        if (!readyList) {\\n\\n            readyList = jQuery.Deferred();\\n\\n            // Catch cases where $(document).ready() is called after the browser event has already occurred.\\n            // we once tried to use readyState \"interactive\" here, but it caused issues like the one\\n            // discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15\\n            if (document.readyState === \"complete\") {\\n                // Handle it asynchronously to allow scripts the opportunity to delay ready\\n                setTimeout(jQuery.ready);\\n            } else {\\n\\n                // Use the handy event callback\\n                document.addEventListener(\"DOMContentLoaded\", completed, false);\\n\\n                // A fallback to window.onload, that will always work\\n                window.addEventListener(\"load\", completed, false);\\n            }\\n        }\\n        return readyList.promise(obj);\\n    };\\n\\n    // Kick off the DOM ready check even if the user does not\\n    jQuery.ready.promise();\\n\\n    // Multifunctional method to get and set values of a collection\\n    // The value/s can optionally be executed if it\\'s a function\\n    var access = jQuery.access = function (elems, fn, key, value, chainable, emptyGet, raw) {\\n        var i = 0,\\n            len = elems.length,\\n            bulk = key == null;\\n\\n        // Sets many values\\n        if (jQuery.type(key) === \"object\") {\\n            chainable = true;\\n            for (i in key) {\\n                jQuery.access(elems, fn, i, key[i], true, emptyGet, raw);\\n            }\\n\\n            // Sets one value\\n        } else if (value !== undefined) {\\n            chainable = true;\\n\\n            if (!jQuery.isFunction(value)) {\\n                raw = true;\\n            }\\n\\n            if (bulk) {\\n                // Bulk operations run against the entire set\\n                if (raw) {\\n                    fn.call(elems, value);\\n                    fn = null;\\n\\n                    // ...except when executing function values\\n                } else {\\n                    bulk = fn;\\n                    fn = function fn(elem, key, value) {\\n                        return bulk.call(jQuery(elem), value);\\n                    };\\n                }\\n            }\\n\\n            if (fn) {\\n                for (; i < len; i++) {\\n                    fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));\\n                }\\n            }\\n        }\\n\\n        return chainable ? elems :\\n\\n        // Gets\\n        bulk ? fn.call(elems) : len ? fn(elems[0], key) : emptyGet;\\n    };\\n\\n    /**\\r\\n     * Determines whether an object can have data\\r\\n     */\\n    jQuery.acceptData = function (owner) {\\n        // Accepts only:\\n        //  - Node\\n        //    - Node.ELEMENT_NODE\\n        //    - Node.DOCUMENT_NODE\\n        //  - Object\\n        //    - Any\\n        /* jshint -W018 */\\n        return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;\\n    };\\n\\n    function Data() {\\n        // Support: Android < 4,\\n        // Old WebKit does not have Object.preventExtensions/freeze method,\\n        // return new empty object instead with no [[set]] accessor\\n        Object.defineProperty(this.cache = {}, 0, {\\n            get: function get() {\\n                return {};\\n            }\\n        });\\n\\n        this.expando = jQuery.expando + Math.random();\\n    }\\n\\n    Data.uid = 1;\\n    Data.accepts = jQuery.acceptData;\\n\\n    Data.prototype = {\\n        key: function key(owner) {\\n            // We can accept data for non-element nodes in modern browsers,\\n            // but we should not, see #8335.\\n            // Always return the key for a frozen object.\\n            if (!Data.accepts(owner)) {\\n                return 0;\\n            }\\n\\n            var descriptor = {},\\n\\n            // Check if the owner object already has a cache key\\n            unlock = owner[this.expando];\\n\\n            // If not, create one\\n            if (!unlock) {\\n                unlock = Data.uid++;\\n\\n                // Secure it in a non-enumerable, non-writable property\\n                try {\\n                    descriptor[this.expando] = { value: unlock };\\n                    Object.defineProperties(owner, descriptor);\\n\\n                    // Support: Android < 4\\n                    // Fallback to a less secure definition\\n                } catch (e) {\\n                    descriptor[this.expando] = unlock;\\n                    jQuery.extend(owner, descriptor);\\n                }\\n            }\\n\\n            // Ensure the cache object\\n            if (!this.cache[unlock]) {\\n                this.cache[unlock] = {};\\n            }\\n\\n            return unlock;\\n        },\\n        set: function set(owner, data, value) {\\n            var prop,\\n\\n            // There may be an unlock assigned to this node,\\n            // if there is no entry for this \"owner\", create one inline\\n            // and set the unlock as though an owner entry had always existed\\n            unlock = this.key(owner),\\n                cache = this.cache[unlock];\\n\\n            // Handle: [ owner, key, value ] args\\n            if (typeof data === \"string\") {\\n                cache[data] = value;\\n\\n                // Handle: [ owner, { properties } ] args\\n            } else {\\n                // Fresh assignments by object are shallow copied\\n                if (jQuery.isEmptyObject(cache)) {\\n                    jQuery.extend(this.cache[unlock], data);\\n                    // Otherwise, copy the properties one-by-one to the cache object\\n                } else {\\n                    for (prop in data) {\\n                        cache[prop] = data[prop];\\n                    }\\n                }\\n            }\\n            return cache;\\n        },\\n        get: function get(owner, key) {\\n            // Either a valid cache is found, or will be created.\\n            // New caches will be created and the unlock returned,\\n            // allowing direct access to the newly created\\n            // empty data object. A valid owner object must be provided.\\n            var cache = this.cache[this.key(owner)];\\n\\n            return key === undefined ? cache : cache[key];\\n        },\\n        access: function access(owner, key, value) {\\n            var stored;\\n            // In cases where either:\\n            //\\n            //   1. No key was specified\\n            //   2. A string key was specified, but no value provided\\n            //\\n            // Take the \"read\" path and allow the get method to determine\\n            // which value to return, respectively either:\\n            //\\n            //   1. The entire cache object\\n            //   2. The data stored at the key\\n            //\\n            if (key === undefined || key && typeof key === \"string\" && value === undefined) {\\n\\n                stored = this.get(owner, key);\\n\\n                return stored !== undefined ? stored : this.get(owner, jQuery.camelCase(key));\\n            }\\n\\n            // [*]When the key is not a string, or both a key and value\\n            // are specified, set or extend (existing objects) with either:\\n            //\\n            //   1. An object of properties\\n            //   2. A key and value\\n            //\\n            this.set(owner, key, value);\\n\\n            // Since the \"set\" path can have two possible entry points\\n            // return the expected data based on which path was taken[*]\\n            return value !== undefined ? value : key;\\n        },\\n        remove: function remove(owner, key) {\\n            var i,\\n                name,\\n                camel,\\n                unlock = this.key(owner),\\n                cache = this.cache[unlock];\\n\\n            if (key === undefined) {\\n                this.cache[unlock] = {};\\n            } else {\\n                // Support array or space separated string of keys\\n                if (jQuery.isArray(key)) {\\n                    // If \"name\" is an array of keys...\\n                    // When data is initially created, via (\"key\", \"val\") signature,\\n                    // keys will be converted to camelCase.\\n                    // Since there is no way to tell _how_ a key was added, remove\\n                    // both plain key and camelCase key. #12786\\n                    // This will only penalize the array argument path.\\n                    name = key.concat(key.map(jQuery.camelCase));\\n                } else {\\n                    camel = jQuery.camelCase(key);\\n                    // Try the string as a key before any manipulation\\n                    if (key in cache) {\\n                        name = [key, camel];\\n                    } else {\\n                        // If a key with the spaces exists, use it.\\n                        // Otherwise, create an array by matching non-whitespace\\n                        name = camel;\\n                        name = name in cache ? [name] : name.match(rnotwhite) || [];\\n                    }\\n                }\\n\\n                i = name.length;\\n                while (i--) {\\n                    delete cache[name[i]];\\n                }\\n            }\\n        },\\n        hasData: function hasData(owner) {\\n            return !jQuery.isEmptyObject(this.cache[owner[this.expando]] || {});\\n        },\\n        discard: function discard(owner) {\\n            if (owner[this.expando]) {\\n                delete this.cache[owner[this.expando]];\\n            }\\n        }\\n    };\\n    var data_priv = new Data();\\n\\n    var data_user = new Data();\\n\\n    /*\\r\\n    \\tImplementation Summary\\r\\n      \\t1. Enforce API surface and semantic compatibility with 1.9.x branch\\r\\n    \\t2. Improve the module\\'s maintainability by reducing the storage\\r\\n    \\t\\tpaths to a single mechanism.\\r\\n    \\t3. Use the same single mechanism to support \"private\" and \"user\" data.\\r\\n    \\t4. _Never_ expose \"private\" data to user code (TODO: Drop _data, _removeData)\\r\\n    \\t5. Avoid exposing implementation details on user objects (eg. expando properties)\\r\\n    \\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\\r\\n    */\\n    var rbrace = /^(?:\\\\{[\\\\w\\\\W]*\\\\}|\\\\[[\\\\w\\\\W]*\\\\])$/,\\n        rmultiDash = /([A-Z])/g;\\n\\n    function dataAttr(elem, key, data) {\\n        var name;\\n\\n        // If nothing was found internally, try to fetch any\\n        // data from the HTML5 data-* attribute\\n        if (data === undefined && elem.nodeType === 1) {\\n            name = \"data-\" + key.replace(rmultiDash, \"-$1\").toLowerCase();\\n            data = elem.getAttribute(name);\\n\\n            if (typeof data === \"string\") {\\n                try {\\n                    data = data === \"true\" ? true : data === \"false\" ? false : data === \"null\" ? null :\\n                    // Only convert to a number if it doesn\\'t change the string\\n                    +data + \"\" === data ? +data : rbrace.test(data) ? jQuery.parseJSON(data) : data;\\n                } catch (e) {}\\n\\n                // Make sure we set the data so it isn\\'t changed later\\n                data_user.set(elem, key, data);\\n            } else {\\n                data = undefined;\\n            }\\n        }\\n        return data;\\n    }\\n\\n    jQuery.extend({\\n        hasData: function hasData(elem) {\\n            return data_user.hasData(elem) || data_priv.hasData(elem);\\n        },\\n\\n        data: function data(elem, name, _data) {\\n            return data_user.access(elem, name, _data);\\n        },\\n\\n        removeData: function removeData(elem, name) {\\n            data_user.remove(elem, name);\\n        },\\n\\n        // TODO: Now that all calls to _data and _removeData have been replaced\\n        // with direct calls to data_priv methods, these can be deprecated.\\n        _data: function _data(elem, name, data) {\\n            return data_priv.access(elem, name, data);\\n        },\\n\\n        _removeData: function _removeData(elem, name) {\\n            data_priv.remove(elem, name);\\n        }\\n    });\\n\\n    jQuery.fn.extend({\\n        data: function data(key, value) {\\n            var i,\\n                name,\\n                data,\\n                elem = this[0],\\n                attrs = elem && elem.attributes;\\n\\n            // Gets all values\\n            if (key === undefined) {\\n                if (this.length) {\\n                    data = data_user.get(elem);\\n\\n                    if (elem.nodeType === 1 && !data_priv.get(elem, \"hasDataAttrs\")) {\\n                        i = attrs.length;\\n                        while (i--) {\\n\\n                            // Support: IE11+\\n                            // The attrs elements can be null (#14894)\\n                            if (attrs[i]) {\\n                                name = attrs[i].name;\\n                                if (name.indexOf(\"data-\") === 0) {\\n                                    name = jQuery.camelCase(name.slice(5));\\n                                    dataAttr(elem, name, data[name]);\\n                                }\\n                            }\\n                        }\\n                        data_priv.set(elem, \"hasDataAttrs\", true);\\n                    }\\n                }\\n\\n                return data;\\n            }\\n\\n            // Sets multiple values\\n            if ((typeof key === \"undefined\" ? \"undefined\" : _typeof(key)) === \"object\") {\\n                return this.each(function () {\\n                    data_user.set(this, key);\\n                });\\n            }\\n\\n            return access(this, function (value) {\\n                var data,\\n                    camelKey = jQuery.camelCase(key);\\n\\n                // The calling jQuery object (element matches) is not empty\\n                // (and therefore has an element appears at this[ 0 ]) and the\\n                // `value` parameter was not undefined. An empty jQuery object\\n                // will result in `undefined` for elem = this[ 0 ] which will\\n                // throw an exception if an attempt to read a data cache is made.\\n                if (elem && value === undefined) {\\n                    // Attempt to get data from the cache\\n                    // with the key as-is\\n                    data = data_user.get(elem, key);\\n                    if (data !== undefined) {\\n                        return data;\\n                    }\\n\\n                    // Attempt to get data from the cache\\n                    // with the key camelized\\n                    data = data_user.get(elem, camelKey);\\n                    if (data !== undefined) {\\n                        return data;\\n                    }\\n\\n                    // Attempt to \"discover\" the data in\\n                    // HTML5 custom data-* attrs\\n                    data = dataAttr(elem, camelKey, undefined);\\n                    if (data !== undefined) {\\n                        return data;\\n                    }\\n\\n                    // We tried really hard, but the data doesn\\'t exist.\\n                    return;\\n                }\\n\\n                // Set the data...\\n                this.each(function () {\\n                    // First, attempt to store a copy or reference of any\\n                    // data that might\\'ve been store with a camelCased key.\\n                    var data = data_user.get(this, camelKey);\\n\\n                    // For HTML5 data-* attribute interop, we have to\\n                    // store property names with dashes in a camelCase form.\\n                    // This might not apply to all properties...*\\n                    data_user.set(this, camelKey, value);\\n\\n                    // *... In the case of properties that might _actually_\\n                    // have dashes, we need to also store a copy of that\\n                    // unchanged property.\\n                    if (key.indexOf(\"-\") !== -1 && data !== undefined) {\\n                        data_user.set(this, key, value);\\n                    }\\n                });\\n            }, null, value, arguments.length > 1, null, true);\\n        },\\n\\n        removeData: function removeData(key) {\\n            return this.each(function () {\\n                data_user.remove(this, key);\\n            });\\n        }\\n    });\\n\\n    jQuery.extend({\\n        queue: function queue(elem, type, data) {\\n            var queue;\\n\\n            if (elem) {\\n                type = (type || \"fx\") + \"queue\";\\n                queue = data_priv.get(elem, type);\\n\\n                // Speed up dequeue by getting out quickly if this is just a lookup\\n                if (data) {\\n                    if (!queue || jQuery.isArray(data)) {\\n                        queue = data_priv.access(elem, type, jQuery.makeArray(data));\\n                    } else {\\n                        queue.push(data);\\n                    }\\n                }\\n                return queue || [];\\n            }\\n        },\\n\\n        dequeue: function dequeue(elem, type) {\\n            type = type || \"fx\";\\n\\n            var queue = jQuery.queue(elem, type),\\n                startLength = queue.length,\\n                fn = queue.shift(),\\n                hooks = jQuery._queueHooks(elem, type),\\n                next = function next() {\\n                jQuery.dequeue(elem, type);\\n            };\\n\\n            // If the fx queue is dequeued, always remove the progress sentinel\\n            if (fn === \"inprogress\") {\\n                fn = queue.shift();\\n                startLength--;\\n            }\\n\\n            if (fn) {\\n\\n                // Add a progress sentinel to prevent the fx queue from being\\n                // automatically dequeued\\n                if (type === \"fx\") {\\n                    queue.unshift(\"inprogress\");\\n                }\\n\\n                // clear up the last queue stop function\\n                delete hooks.stop;\\n                fn.call(elem, next, hooks);\\n            }\\n\\n            if (!startLength && hooks) {\\n                hooks.empty.fire();\\n            }\\n        },\\n\\n        // not intended for public consumption - generates a queueHooks object, or returns the current one\\n        _queueHooks: function _queueHooks(elem, type) {\\n            var key = type + \"queueHooks\";\\n            return data_priv.get(elem, key) || data_priv.access(elem, key, {\\n                empty: jQuery.Callbacks(\"once memory\").add(function () {\\n                    data_priv.remove(elem, [type + \"queue\", key]);\\n                })\\n            });\\n        }\\n    });\\n\\n    jQuery.fn.extend({\\n        queue: function queue(type, data) {\\n            var setter = 2;\\n\\n            if (typeof type !== \"string\") {\\n                data = type;\\n                type = \"fx\";\\n                setter--;\\n            }\\n\\n            if (arguments.length < setter) {\\n                return jQuery.queue(this[0], type);\\n            }\\n\\n            return data === undefined ? this : this.each(function () {\\n                var queue = jQuery.queue(this, type, data);\\n\\n                // ensure a hooks for this queue\\n                jQuery._queueHooks(this, type);\\n\\n                if (type === \"fx\" && queue[0] !== \"inprogress\") {\\n                    jQuery.dequeue(this, type);\\n                }\\n            });\\n        },\\n        dequeue: function dequeue(type) {\\n            return this.each(function () {\\n                jQuery.dequeue(this, type);\\n            });\\n        },\\n        clearQueue: function clearQueue(type) {\\n            return this.queue(type || \"fx\", []);\\n        },\\n        // Get a promise resolved when queues of a certain type\\n        // are emptied (fx is the type by default)\\n        promise: function promise(type, obj) {\\n            var tmp,\\n                count = 1,\\n                defer = jQuery.Deferred(),\\n                elements = this,\\n                i = this.length,\\n                resolve = function resolve() {\\n                if (! --count) {\\n                    defer.resolveWith(elements, [elements]);\\n                }\\n            };\\n\\n            if (typeof type !== \"string\") {\\n                obj = type;\\n                type = undefined;\\n            }\\n            type = type || \"fx\";\\n\\n            while (i--) {\\n                tmp = data_priv.get(elements[i], type + \"queueHooks\");\\n                if (tmp && tmp.empty) {\\n                    count++;\\n                    tmp.empty.add(resolve);\\n                }\\n            }\\n            resolve();\\n            return defer.promise(obj);\\n        }\\n    });\\n    var pnum = /[+-]?(?:\\\\d*\\\\.|)\\\\d+(?:[eE][+-]?\\\\d+|)/.source;\\n\\n    var cssExpand = [\"Top\", \"Right\", \"Bottom\", \"Left\"];\\n\\n    var isHidden = function isHidden(elem, el) {\\n        // isHidden might be called from jQuery#filter function;\\n        // in that case, element will be second argument\\n        elem = el || elem;\\n        return jQuery.css(elem, \"display\") === \"none\" || !jQuery.contains(elem.ownerDocument, elem);\\n    };\\n\\n    var rcheckableType = /^(?:checkbox|radio)$/i;\\n\\n    (function () {\\n        var fragment = document.createDocumentFragment(),\\n            div = fragment.appendChild(document.createElement(\"div\")),\\n            input = document.createElement(\"input\");\\n\\n        // #11217 - WebKit loses check when the name is after the checked attribute\\n        // Support: Windows Web Apps (WWA)\\n        // `name` and `type` need .setAttribute for WWA\\n        input.setAttribute(\"type\", \"radio\");\\n        input.setAttribute(\"checked\", \"checked\");\\n        input.setAttribute(\"name\", \"t\");\\n\\n        div.appendChild(input);\\n\\n        // Support: Safari 5.1, iOS 5.1, Android 4.x, Android 2.3\\n        // old WebKit doesn\\'t clone checked state correctly in fragments\\n        support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;\\n\\n        // Make sure textarea (and checkbox) defaultValue is properly cloned\\n        // Support: IE9-IE11+\\n        div.innerHTML = \"<textarea>x</textarea>\";\\n        support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;\\n    })();\\n    var strundefined =  true ? \"undefined\" : undefined;\\n\\n    support.focusinBubbles = \"onfocusin\" in window;\\n\\n    var rkeyEvent = /^key/,\\n        rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,\\n        rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,\\n        rtypenamespace = /^([^.]*)(?:\\\\.(.+)|)$/;\\n\\n    function returnTrue() {\\n        return true;\\n    }\\n\\n    function returnFalse() {\\n        return false;\\n    }\\n\\n    function safeActiveElement() {\\n        try {\\n            return document.activeElement;\\n        } catch (err) {}\\n    }\\n\\n    /*\\r\\n     * Helper functions for managing events -- not part of the public interface.\\r\\n     * Props to Dean Edwards\\' addEvent library for many of the ideas.\\r\\n     */\\n    jQuery.event = {\\n\\n        global: {},\\n\\n        add: function add(elem, types, handler, data, selector) {\\n\\n            var handleObjIn,\\n                eventHandle,\\n                tmp,\\n                events,\\n                t,\\n                handleObj,\\n                special,\\n                handlers,\\n                type,\\n                namespaces,\\n                origType,\\n                elemData = data_priv.get(elem);\\n\\n            // Don\\'t attach events to noData or text/comment nodes (but allow plain objects)\\n            if (!elemData) {\\n                return;\\n            }\\n\\n            // Caller can pass in an object of custom data in lieu of the handler\\n            if (handler.handler) {\\n                handleObjIn = handler;\\n                handler = handleObjIn.handler;\\n                selector = handleObjIn.selector;\\n            }\\n\\n            // Make sure that the handler has a unique ID, used to find/remove it later\\n            if (!handler.guid) {\\n                handler.guid = jQuery.guid++;\\n            }\\n\\n            // Init the element\\'s event structure and main handler, if this is the first\\n            if (!(events = elemData.events)) {\\n                events = elemData.events = {};\\n            }\\n            if (!(eventHandle = elemData.handle)) {\\n                eventHandle = elemData.handle = function (e) {\\n                    // Discard the second event of a jQuery.event.trigger() and\\n                    // when an event is called after a page has unloaded\\n                    return (typeof jQuery === \"undefined\" ? \"undefined\" : _typeof(jQuery)) !== strundefined && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;\\n                };\\n            }\\n\\n            // Handle multiple events separated by a space\\n            types = (types || \"\").match(rnotwhite) || [\"\"];\\n            t = types.length;\\n            while (t--) {\\n                tmp = rtypenamespace.exec(types[t]) || [];\\n                type = origType = tmp[1];\\n                namespaces = (tmp[2] || \"\").split(\".\").sort();\\n\\n                // There *must* be a type, no attaching namespace-only handlers\\n                if (!type) {\\n                    continue;\\n                }\\n\\n                // If event changes its type, use the special event handlers for the changed type\\n                special = jQuery.event.special[type] || {};\\n\\n                // If selector defined, determine special event api type, otherwise given type\\n                type = (selector ? special.delegateType : special.bindType) || type;\\n\\n                // Update special based on newly reset type\\n                special = jQuery.event.special[type] || {};\\n\\n                // handleObj is passed to all event handlers\\n                handleObj = jQuery.extend({\\n                    type: type,\\n                    origType: origType,\\n                    data: data,\\n                    handler: handler,\\n                    guid: handler.guid,\\n                    selector: selector,\\n                    needsContext: selector && jQuery.expr.match.needsContext.test(selector),\\n                    namespace: namespaces.join(\".\")\\n                }, handleObjIn);\\n\\n                // Init the event handler queue if we\\'re the first\\n                if (!(handlers = events[type])) {\\n                    handlers = events[type] = [];\\n                    handlers.delegateCount = 0;\\n\\n                    // Only use addEventListener if the special events handler returns false\\n                    if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {\\n                        if (elem.addEventListener) {\\n                            elem.addEventListener(type, eventHandle, false);\\n                        }\\n                    }\\n                }\\n\\n                if (special.add) {\\n                    special.add.call(elem, handleObj);\\n\\n                    if (!handleObj.handler.guid) {\\n                        handleObj.handler.guid = handler.guid;\\n                    }\\n                }\\n\\n                // Add to the element\\'s handler list, delegates in front\\n                if (selector) {\\n                    handlers.splice(handlers.delegateCount++, 0, handleObj);\\n                } else {\\n                    handlers.push(handleObj);\\n                }\\n\\n                // Keep track of which events have ever been used, for event optimization\\n                jQuery.event.global[type] = true;\\n            }\\n        },\\n\\n        // Detach an event or set of events from an element\\n        remove: function remove(elem, types, handler, selector, mappedTypes) {\\n\\n            var j,\\n                origCount,\\n                tmp,\\n                events,\\n                t,\\n                handleObj,\\n                special,\\n                handlers,\\n                type,\\n                namespaces,\\n                origType,\\n                elemData = data_priv.hasData(elem) && data_priv.get(elem);\\n\\n            if (!elemData || !(events = elemData.events)) {\\n                return;\\n            }\\n\\n            // Once for each type.namespace in types; type may be omitted\\n            types = (types || \"\").match(rnotwhite) || [\"\"];\\n            t = types.length;\\n            while (t--) {\\n                tmp = rtypenamespace.exec(types[t]) || [];\\n                type = origType = tmp[1];\\n                namespaces = (tmp[2] || \"\").split(\".\").sort();\\n\\n                // Unbind all events (on this namespace, if provided) for the element\\n                if (!type) {\\n                    for (type in events) {\\n                        jQuery.event.remove(elem, type + types[t], handler, selector, true);\\n                    }\\n                    continue;\\n                }\\n\\n                special = jQuery.event.special[type] || {};\\n                type = (selector ? special.delegateType : special.bindType) || type;\\n                handlers = events[type] || [];\\n                tmp = tmp[2] && new RegExp(\"(^|\\\\\\\\.)\" + namespaces.join(\"\\\\\\\\.(?:.*\\\\\\\\.|)\") + \"(\\\\\\\\.|$)\");\\n\\n                // Remove matching events\\n                origCount = j = handlers.length;\\n                while (j--) {\\n                    handleObj = handlers[j];\\n\\n                    if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === \"**\" && handleObj.selector)) {\\n                        handlers.splice(j, 1);\\n\\n                        if (handleObj.selector) {\\n                            handlers.delegateCount--;\\n                        }\\n                        if (special.remove) {\\n                            special.remove.call(elem, handleObj);\\n                        }\\n                    }\\n                }\\n\\n                // Remove generic event handler if we removed something and no more handlers exist\\n                // (avoids potential for endless recursion during removal of special event handlers)\\n                if (origCount && !handlers.length) {\\n                    if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {\\n                        jQuery.removeEvent(elem, type, elemData.handle);\\n                    }\\n\\n                    delete events[type];\\n                }\\n            }\\n\\n            // Remove the expando if it\\'s no longer used\\n            if (jQuery.isEmptyObject(events)) {\\n                delete elemData.handle;\\n                data_priv.remove(elem, \"events\");\\n            }\\n        },\\n\\n        trigger: function trigger(event, data, elem, onlyHandlers) {\\n\\n            var i,\\n                cur,\\n                tmp,\\n                bubbleType,\\n                ontype,\\n                handle,\\n                special,\\n                eventPath = [elem || document],\\n                type = hasOwn.call(event, \"type\") ? event.type : event,\\n                namespaces = hasOwn.call(event, \"namespace\") ? event.namespace.split(\".\") : [];\\n\\n            cur = tmp = elem = elem || document;\\n\\n            // Don\\'t do events on text and comment nodes\\n            if (elem.nodeType === 3 || elem.nodeType === 8) {\\n                return;\\n            }\\n\\n            // focus/blur morphs to focusin/out; ensure we\\'re not firing them right now\\n            if (rfocusMorph.test(type + jQuery.event.triggered)) {\\n                return;\\n            }\\n\\n            if (type.indexOf(\".\") >= 0) {\\n                // Namespaced trigger; create a regexp to match event type in handle()\\n                namespaces = type.split(\".\");\\n                type = namespaces.shift();\\n                namespaces.sort();\\n            }\\n            ontype = type.indexOf(\":\") < 0 && \"on\" + type;\\n\\n            // Caller can pass in a jQuery.Event object, Object, or just an event type string\\n            event = event[jQuery.expando] ? event : new jQuery.Event(type, (typeof event === \"undefined\" ? \"undefined\" : _typeof(event)) === \"object\" && event);\\n\\n            // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\\n            event.isTrigger = onlyHandlers ? 2 : 3;\\n            event.namespace = namespaces.join(\".\");\\n            event.namespace_re = event.namespace ? new RegExp(\"(^|\\\\\\\\.)\" + namespaces.join(\"\\\\\\\\.(?:.*\\\\\\\\.|)\") + \"(\\\\\\\\.|$)\") : null;\\n\\n            // Clean up the event in case it is being reused\\n            event.result = undefined;\\n            if (!event.target) {\\n                event.target = elem;\\n            }\\n\\n            // Clone any incoming data and prepend the event, creating the handler arg list\\n            data = data == null ? [event] : jQuery.makeArray(data, [event]);\\n\\n            // Allow special events to draw outside the lines\\n            special = jQuery.event.special[type] || {};\\n            if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {\\n                return;\\n            }\\n\\n            // Determine event propagation path in advance, per W3C events spec (#9951)\\n            // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\\n            if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {\\n\\n                bubbleType = special.delegateType || type;\\n                if (!rfocusMorph.test(bubbleType + type)) {\\n                    cur = cur.parentNode;\\n                }\\n                for (; cur; cur = cur.parentNode) {\\n                    eventPath.push(cur);\\n                    tmp = cur;\\n                }\\n\\n                // Only add window if we got to document (e.g., not plain obj or detached DOM)\\n                if (tmp === (elem.ownerDocument || document)) {\\n                    eventPath.push(tmp.defaultView || tmp.parentWindow || window);\\n                }\\n            }\\n\\n            // Fire handlers on the event path\\n            i = 0;\\n            while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {\\n\\n                event.type = i > 1 ? bubbleType : special.bindType || type;\\n\\n                // jQuery handler\\n                handle = (data_priv.get(cur, \"events\") || {})[event.type] && data_priv.get(cur, \"handle\");\\n                if (handle) {\\n                    handle.apply(cur, data);\\n                }\\n\\n                // Native handler\\n                handle = ontype && cur[ontype];\\n                if (handle && handle.apply && jQuery.acceptData(cur)) {\\n                    event.result = handle.apply(cur, data);\\n                    if (event.result === false) {\\n                        event.preventDefault();\\n                    }\\n                }\\n            }\\n            event.type = type;\\n\\n            // If nobody prevented the default action, do it now\\n            if (!onlyHandlers && !event.isDefaultPrevented()) {\\n\\n                if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && jQuery.acceptData(elem)) {\\n\\n                    // Call a native DOM method on the target with the same name name as the event.\\n                    // Don\\'t do default actions on window, that\\'s where global variables be (#6170)\\n                    if (ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem)) {\\n\\n                        // Don\\'t re-trigger an onFOO event when we call its FOO() method\\n                        tmp = elem[ontype];\\n\\n                        if (tmp) {\\n                            elem[ontype] = null;\\n                        }\\n\\n                        // Prevent re-triggering of the same event, since we already bubbled it above\\n                        jQuery.event.triggered = type;\\n                        elem[type]();\\n                        jQuery.event.triggered = undefined;\\n\\n                        if (tmp) {\\n                            elem[ontype] = tmp;\\n                        }\\n                    }\\n                }\\n            }\\n\\n            return event.result;\\n        },\\n\\n        dispatch: function dispatch(event) {\\n\\n            // Make a writable jQuery.Event from the native event object\\n            event = jQuery.event.fix(event);\\n\\n            var i,\\n                j,\\n                ret,\\n                matched,\\n                handleObj,\\n                handlerQueue = [],\\n                args = _slice.call(arguments),\\n                handlers = (data_priv.get(this, \"events\") || {})[event.type] || [],\\n                special = jQuery.event.special[event.type] || {};\\n\\n            // Use the fix-ed jQuery.Event rather than the (read-only) native event\\n            args[0] = event;\\n            event.delegateTarget = this;\\n\\n            // Call the preDispatch hook for the mapped type, and let it bail if desired\\n            if (special.preDispatch && special.preDispatch.call(this, event) === false) {\\n                return;\\n            }\\n\\n            // Determine handlers\\n            handlerQueue = jQuery.event.handlers.call(this, event, handlers);\\n\\n            // Run delegates first; they may want to stop propagation beneath us\\n            i = 0;\\n            while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {\\n                event.currentTarget = matched.elem;\\n\\n                j = 0;\\n                while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {\\n\\n                    // Triggered event must either 1) have no namespace, or\\n                    // 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).\\n                    if (!event.namespace_re || event.namespace_re.test(handleObj.namespace)) {\\n\\n                        event.handleObj = handleObj;\\n                        event.data = handleObj.data;\\n\\n                        ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);\\n\\n                        if (ret !== undefined) {\\n                            if ((event.result = ret) === false) {\\n                                event.preventDefault();\\n                                event.stopPropagation();\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n\\n            // Call the postDispatch hook for the mapped type\\n            if (special.postDispatch) {\\n                special.postDispatch.call(this, event);\\n            }\\n\\n            return event.result;\\n        },\\n\\n        handlers: function handlers(event, _handlers) {\\n            var i,\\n                matches,\\n                sel,\\n                handleObj,\\n                handlerQueue = [],\\n                delegateCount = _handlers.delegateCount,\\n                cur = event.target;\\n\\n            // Find delegate handlers\\n            // Black-hole SVG <use> instance trees (#13180)\\n            // Avoid non-left-click bubbling in Firefox (#3861)\\n            if (delegateCount && cur.nodeType && (!event.button || event.type !== \"click\")) {\\n\\n                for (; cur !== this; cur = cur.parentNode || this) {\\n\\n                    // Don\\'t process clicks on disabled elements (#6911, #8165, #11382, #11764)\\n                    if (cur.disabled !== true || event.type !== \"click\") {\\n                        matches = [];\\n                        for (i = 0; i < delegateCount; i++) {\\n                            handleObj = _handlers[i];\\n\\n                            // Don\\'t conflict with Object.prototype properties (#13203)\\n                            sel = handleObj.selector + \" \";\\n\\n                            if (matches[sel] === undefined) {\\n                                matches[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) >= 0 : jQuery.find(sel, this, null, [cur]).length;\\n                            }\\n                            if (matches[sel]) {\\n                                matches.push(handleObj);\\n                            }\\n                        }\\n                        if (matches.length) {\\n                            handlerQueue.push({ elem: cur, handlers: matches });\\n                        }\\n                    }\\n                }\\n            }\\n\\n            // Add the remaining (directly-bound) handlers\\n            if (delegateCount < _handlers.length) {\\n                handlerQueue.push({ elem: this, handlers: _handlers.slice(delegateCount) });\\n            }\\n\\n            return handlerQueue;\\n        },\\n\\n        // Includes some event props shared by KeyEvent and MouseEvent\\n        props: \"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which\".split(\" \"),\\n\\n        fixHooks: {},\\n\\n        keyHooks: {\\n            props: \"char charCode key keyCode\".split(\" \"),\\n            filter: function filter(event, original) {\\n\\n                // Add which for key events\\n                if (event.which == null) {\\n                    event.which = original.charCode != null ? original.charCode : original.keyCode;\\n                }\\n\\n                return event;\\n            }\\n        },\\n\\n        mouseHooks: {\\n            props: \"button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement\".split(\" \"),\\n            filter: function filter(event, original) {\\n                var eventDoc,\\n                    doc,\\n                    body,\\n                    button = original.button;\\n\\n                // Calculate pageX/Y if missing and clientX/Y available\\n                if (event.pageX == null && original.clientX != null) {\\n                    eventDoc = event.target.ownerDocument || document;\\n                    doc = eventDoc.documentElement;\\n                    body = eventDoc.body;\\n\\n                    event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);\\n                    event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);\\n                }\\n\\n                // Add which for click: 1 === left; 2 === middle; 3 === right\\n                // Note: button is not normalized, so don\\'t use it\\n                if (!event.which && button !== undefined) {\\n                    event.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;\\n                }\\n\\n                return event;\\n            }\\n        },\\n\\n        fix: function fix(event) {\\n            if (event[jQuery.expando]) {\\n                return event;\\n            }\\n\\n            // Create a writable copy of the event object and normalize some properties\\n            var i,\\n                prop,\\n                copy,\\n                type = event.type,\\n                originalEvent = event,\\n                fixHook = this.fixHooks[type];\\n\\n            if (!fixHook) {\\n                this.fixHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks : rkeyEvent.test(type) ? this.keyHooks : {};\\n            }\\n            copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;\\n\\n            event = new jQuery.Event(originalEvent);\\n\\n            i = copy.length;\\n            while (i--) {\\n                prop = copy[i];\\n                event[prop] = originalEvent[prop];\\n            }\\n\\n            // Support: Cordova 2.5 (WebKit) (#13255)\\n            // All events should have a target; Cordova deviceready doesn\\'t\\n            if (!event.target) {\\n                event.target = document;\\n            }\\n\\n            // Support: Safari 6.0+, Chrome < 28\\n            // Target should not be a text node (#504, #13143)\\n            if (event.target.nodeType === 3) {\\n                event.target = event.target.parentNode;\\n            }\\n\\n            return fixHook.filter ? fixHook.filter(event, originalEvent) : event;\\n        },\\n\\n        special: {\\n            load: {\\n                // Prevent triggered image.load events from bubbling to window.load\\n                noBubble: true\\n            },\\n            focus: {\\n                // Fire native event if possible so blur/focus sequence is correct\\n                trigger: function trigger() {\\n                    if (this !== safeActiveElement() && this.focus) {\\n                        this.focus();\\n                        return false;\\n                    }\\n                },\\n                delegateType: \"focusin\"\\n            },\\n            blur: {\\n                trigger: function trigger() {\\n                    if (this === safeActiveElement() && this.blur) {\\n                        this.blur();\\n                        return false;\\n                    }\\n                },\\n                delegateType: \"focusout\"\\n            },\\n            click: {\\n                // For checkbox, fire native event so checked state will be right\\n                trigger: function trigger() {\\n                    if (this.type === \"checkbox\" && this.click && jQuery.nodeName(this, \"input\")) {\\n                        this.click();\\n                        return false;\\n                    }\\n                },\\n\\n                // For cross-browser consistency, don\\'t fire native .click() on links\\n                _default: function _default(event) {\\n                    return jQuery.nodeName(event.target, \"a\");\\n                }\\n            },\\n\\n            beforeunload: {\\n                postDispatch: function postDispatch(event) {\\n\\n                    // Support: Firefox 20+\\n                    // Firefox doesn\\'t alert if the returnValue field is not set.\\n                    if (event.result !== undefined && event.originalEvent) {\\n                        event.originalEvent.returnValue = event.result;\\n                    }\\n                }\\n            }\\n        },\\n\\n        simulate: function simulate(type, elem, event, bubble) {\\n            // Piggyback on a donor event to simulate a different one.\\n            // Fake originalEvent to avoid donor\\'s stopPropagation, but if the\\n            // simulated event prevents default then we do the same on the donor.\\n            var e = jQuery.extend(new jQuery.Event(), event, {\\n                type: type,\\n                isSimulated: true,\\n                originalEvent: {}\\n            });\\n            if (bubble) {\\n                jQuery.event.trigger(e, null, elem);\\n            } else {\\n                jQuery.event.dispatch.call(elem, e);\\n            }\\n            if (e.isDefaultPrevented()) {\\n                event.preventDefault();\\n            }\\n        }\\n    };\\n\\n    jQuery.removeEvent = function (elem, type, handle) {\\n        if (elem.removeEventListener) {\\n            elem.removeEventListener(type, handle, false);\\n        }\\n    };\\n\\n    jQuery.Event = function (src, props) {\\n        // Allow instantiation without the \\'new\\' keyword\\n        if (!(this instanceof jQuery.Event)) {\\n            return new jQuery.Event(src, props);\\n        }\\n\\n        // Event object\\n        if (src && src.type) {\\n            this.originalEvent = src;\\n            this.type = src.type;\\n\\n            // Events bubbling up the document may have been marked as prevented\\n            // by a handler lower down the tree; reflect the correct value.\\n            this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined &&\\n            // Support: Android < 4.0\\n            src.returnValue === false ? returnTrue : returnFalse;\\n\\n            // Event type\\n        } else {\\n            this.type = src;\\n        }\\n\\n        // Put explicitly provided properties onto the event object\\n        if (props) {\\n            jQuery.extend(this, props);\\n        }\\n\\n        // Create a timestamp if incoming event doesn\\'t have one\\n        this.timeStamp = src && src.timeStamp || jQuery.now();\\n\\n        // Mark it as fixed\\n        this[jQuery.expando] = true;\\n    };\\n\\n    // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\\n    // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\\n    jQuery.Event.prototype = {\\n        isDefaultPrevented: returnFalse,\\n        isPropagationStopped: returnFalse,\\n        isImmediatePropagationStopped: returnFalse,\\n\\n        preventDefault: function preventDefault() {\\n            var e = this.originalEvent;\\n\\n            this.isDefaultPrevented = returnTrue;\\n\\n            if (e && e.preventDefault) {\\n                e.preventDefault();\\n            }\\n        },\\n        stopPropagation: function stopPropagation() {\\n            var e = this.originalEvent;\\n\\n            this.isPropagationStopped = returnTrue;\\n\\n            if (e && e.stopPropagation) {\\n                e.stopPropagation();\\n            }\\n        },\\n        stopImmediatePropagation: function stopImmediatePropagation() {\\n            var e = this.originalEvent;\\n\\n            this.isImmediatePropagationStopped = returnTrue;\\n\\n            if (e && e.stopImmediatePropagation) {\\n                e.stopImmediatePropagation();\\n            }\\n\\n            this.stopPropagation();\\n        }\\n    };\\n\\n    // Create mouseenter/leave events using mouseover/out and event-time checks\\n    // Support: Chrome 15+\\n    jQuery.each({\\n        mouseenter: \"mouseover\",\\n        mouseleave: \"mouseout\",\\n        pointerenter: \"pointerover\",\\n        pointerleave: \"pointerout\"\\n    }, function (orig, fix) {\\n        jQuery.event.special[orig] = {\\n            delegateType: fix,\\n            bindType: fix,\\n\\n            handle: function handle(event) {\\n                var ret,\\n                    target = this,\\n                    related = event.relatedTarget,\\n                    handleObj = event.handleObj;\\n\\n                // For mousenter/leave call the handler if related is outside the target.\\n                // NB: No relatedTarget if the mouse left/entered the browser window\\n                if (!related || related !== target && !jQuery.contains(target, related)) {\\n                    event.type = handleObj.origType;\\n                    ret = handleObj.handler.apply(this, arguments);\\n                    event.type = fix;\\n                }\\n                return ret;\\n            }\\n        };\\n    });\\n\\n    // Create \"bubbling\" focus and blur events\\n    // Support: Firefox, Chrome, Safari\\n    if (!support.focusinBubbles) {\\n        jQuery.each({ focus: \"focusin\", blur: \"focusout\" }, function (orig, fix) {\\n\\n            // Attach a single capturing handler on the document while someone wants focusin/focusout\\n            var handler = function handler(event) {\\n                jQuery.event.simulate(fix, event.target, jQuery.event.fix(event), true);\\n            };\\n\\n            jQuery.event.special[fix] = {\\n                setup: function setup() {\\n                    var doc = this.ownerDocument || this,\\n                        attaches = data_priv.access(doc, fix);\\n\\n                    if (!attaches) {\\n                        doc.addEventListener(orig, handler, true);\\n                    }\\n                    data_priv.access(doc, fix, (attaches || 0) + 1);\\n                },\\n                teardown: function teardown() {\\n                    var doc = this.ownerDocument || this,\\n                        attaches = data_priv.access(doc, fix) - 1;\\n\\n                    if (!attaches) {\\n                        doc.removeEventListener(orig, handler, true);\\n                        data_priv.remove(doc, fix);\\n                    } else {\\n                        data_priv.access(doc, fix, attaches);\\n                    }\\n                }\\n            };\\n        });\\n    }\\n\\n    jQuery.fn.extend({\\n\\n        on: function on(types, selector, data, fn, /*INTERNAL*/one) {\\n            var origFn, type;\\n\\n            // Types can be a map of types/handlers\\n            if ((typeof types === \"undefined\" ? \"undefined\" : _typeof(types)) === \"object\") {\\n                // ( types-Object, selector, data )\\n                if (typeof selector !== \"string\") {\\n                    // ( types-Object, data )\\n                    data = data || selector;\\n                    selector = undefined;\\n                }\\n                for (type in types) {\\n                    this.on(type, selector, data, types[type], one);\\n                }\\n                return this;\\n            }\\n\\n            if (data == null && fn == null) {\\n                // ( types, fn )\\n                fn = selector;\\n                data = selector = undefined;\\n            } else if (fn == null) {\\n                if (typeof selector === \"string\") {\\n                    // ( types, selector, fn )\\n                    fn = data;\\n                    data = undefined;\\n                } else {\\n                    // ( types, data, fn )\\n                    fn = data;\\n                    data = selector;\\n                    selector = undefined;\\n                }\\n            }\\n            if (fn === false) {\\n                fn = returnFalse;\\n            } else if (!fn) {\\n                return this;\\n            }\\n\\n            if (one === 1) {\\n                origFn = fn;\\n                fn = function fn(event) {\\n                    // Can use an empty set, since event contains the info\\n                    jQuery().off(event);\\n                    return origFn.apply(this, arguments);\\n                };\\n                // Use same guid so caller can remove using origFn\\n                fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);\\n            }\\n            return this.each(function () {\\n                jQuery.event.add(this, types, fn, data, selector);\\n            });\\n        },\\n        one: function one(types, selector, data, fn) {\\n            return this.on(types, selector, data, fn, 1);\\n        },\\n        off: function off(types, selector, fn) {\\n            var handleObj, type;\\n            if (types && types.preventDefault && types.handleObj) {\\n                // ( event )  dispatched jQuery.Event\\n                handleObj = types.handleObj;\\n                jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + \".\" + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);\\n                return this;\\n            }\\n            if ((typeof types === \"undefined\" ? \"undefined\" : _typeof(types)) === \"object\") {\\n                // ( types-object [, selector] )\\n                for (type in types) {\\n                    this.off(type, selector, types[type]);\\n                }\\n                return this;\\n            }\\n            if (selector === false || typeof selector === \"function\") {\\n                // ( types [, fn] )\\n                fn = selector;\\n                selector = undefined;\\n            }\\n            if (fn === false) {\\n                fn = returnFalse;\\n            }\\n            return this.each(function () {\\n                jQuery.event.remove(this, types, fn, selector);\\n            });\\n        },\\n\\n        trigger: function trigger(type, data) {\\n            return this.each(function () {\\n                jQuery.event.trigger(type, data, this);\\n            });\\n        },\\n        triggerHandler: function triggerHandler(type, data) {\\n            var elem = this[0];\\n            if (elem) {\\n                return jQuery.event.trigger(type, data, elem, true);\\n            }\\n        }\\n    });\\n\\n    var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\\\w:]+)[^>]*)\\\\/>/gi,\\n        rtagName = /<([\\\\w:]+)/,\\n        rhtml = /<|&#?\\\\w+;/,\\n        rnoInnerhtml = /<(?:script|style|link)/i,\\n\\n    // checked=\"checked\" or checked\\n    rchecked = /checked\\\\s*(?:[^=]|=\\\\s*.checked.)/i,\\n        rscriptType = /^$|\\\\/(?:java|ecma)script/i,\\n        rscriptTypeMasked = /^true\\\\/(.*)/,\\n        rcleanScript = /^\\\\s*<!(?:\\\\[CDATA\\\\[|--)|(?:\\\\]\\\\]|--)>\\\\s*$/g,\\n\\n\\n    // We have to close these tags to support XHTML (#13200)\\n    wrapMap = {\\n\\n        // Support: IE 9\\n        option: [1, \"<select multiple=\\'multiple\\'>\", \"</select>\"],\\n\\n        thead: [1, \"<table>\", \"</table>\"],\\n        col: [2, \"<table><colgroup>\", \"</colgroup></table>\"],\\n        tr: [2, \"<table><tbody>\", \"</tbody></table>\"],\\n        td: [3, \"<table><tbody><tr>\", \"</tr></tbody></table>\"],\\n\\n        _default: [0, \"\", \"\"]\\n    };\\n\\n    // Support: IE 9\\n    wrapMap.optgroup = wrapMap.option;\\n\\n    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\\n    wrapMap.th = wrapMap.td;\\n\\n    // Support: 1.x compatibility\\n    // Manipulating tables requires a tbody\\n    function manipulationTarget(elem, content) {\\n        return jQuery.nodeName(elem, \"table\") && jQuery.nodeName(content.nodeType !== 11 ? content : content.firstChild, \"tr\") ? elem.getElementsByTagName(\"tbody\")[0] || elem.appendChild(elem.ownerDocument.createElement(\"tbody\")) : elem;\\n    }\\n\\n    // Replace/restore the type attribute of script elements for safe DOM manipulation\\n    function disableScript(elem) {\\n        elem.type = (elem.getAttribute(\"type\") !== null) + \"/\" + elem.type;\\n        return elem;\\n    }\\n\\n    function restoreScript(elem) {\\n        var match = rscriptTypeMasked.exec(elem.type);\\n\\n        if (match) {\\n            elem.type = match[1];\\n        } else {\\n            elem.removeAttribute(\"type\");\\n        }\\n\\n        return elem;\\n    }\\n\\n    // Mark scripts as having already been evaluated\\n    function setGlobalEval(elems, refElements) {\\n        var i = 0,\\n            l = elems.length;\\n\\n        for (; i < l; i++) {\\n            data_priv.set(elems[i], \"globalEval\", !refElements || data_priv.get(refElements[i], \"globalEval\"));\\n        }\\n    }\\n\\n    function cloneCopyEvent(src, dest) {\\n        var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;\\n\\n        if (dest.nodeType !== 1) {\\n            return;\\n        }\\n\\n        // 1. Copy private data: events, handlers, etc.\\n        if (data_priv.hasData(src)) {\\n            pdataOld = data_priv.access(src);\\n            pdataCur = data_priv.set(dest, pdataOld);\\n            events = pdataOld.events;\\n\\n            if (events) {\\n                delete pdataCur.handle;\\n                pdataCur.events = {};\\n\\n                for (type in events) {\\n                    for (i = 0, l = events[type].length; i < l; i++) {\\n                        jQuery.event.add(dest, type, events[type][i]);\\n                    }\\n                }\\n            }\\n        }\\n\\n        // 2. Copy user data\\n        if (data_user.hasData(src)) {\\n            udataOld = data_user.access(src);\\n            udataCur = jQuery.extend({}, udataOld);\\n\\n            data_user.set(dest, udataCur);\\n        }\\n    }\\n\\n    function getAll(context, tag) {\\n        var ret = context.getElementsByTagName ? context.getElementsByTagName(tag || \"*\") : context.querySelectorAll ? context.querySelectorAll(tag || \"*\") : [];\\n\\n        return tag === undefined || tag && jQuery.nodeName(context, tag) ? jQuery.merge([context], ret) : ret;\\n    }\\n\\n    // Support: IE >= 9\\n    function fixInput(src, dest) {\\n        var nodeName = dest.nodeName.toLowerCase();\\n\\n        // Fails to persist the checked state of a cloned checkbox or radio button.\\n        if (nodeName === \"input\" && rcheckableType.test(src.type)) {\\n            dest.checked = src.checked;\\n\\n            // Fails to return the selected option to the default selected state when cloning options\\n        } else if (nodeName === \"input\" || nodeName === \"textarea\") {\\n            dest.defaultValue = src.defaultValue;\\n        }\\n    }\\n\\n    jQuery.extend({\\n        clone: function clone(elem, dataAndEvents, deepDataAndEvents) {\\n            var i,\\n                l,\\n                srcElements,\\n                destElements,\\n                clone = elem.cloneNode(true),\\n                inPage = jQuery.contains(elem.ownerDocument, elem);\\n\\n            // Support: IE >= 9\\n            // Fix Cloning issues\\n            if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {\\n\\n                // We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2\\n                destElements = getAll(clone);\\n                srcElements = getAll(elem);\\n\\n                for (i = 0, l = srcElements.length; i < l; i++) {\\n                    fixInput(srcElements[i], destElements[i]);\\n                }\\n            }\\n\\n            // Copy the events from the original to the clone\\n            if (dataAndEvents) {\\n                if (deepDataAndEvents) {\\n                    srcElements = srcElements || getAll(elem);\\n                    destElements = destElements || getAll(clone);\\n\\n                    for (i = 0, l = srcElements.length; i < l; i++) {\\n                        cloneCopyEvent(srcElements[i], destElements[i]);\\n                    }\\n                } else {\\n                    cloneCopyEvent(elem, clone);\\n                }\\n            }\\n\\n            // Preserve script evaluation history\\n            destElements = getAll(clone, \"script\");\\n            if (destElements.length > 0) {\\n                setGlobalEval(destElements, !inPage && getAll(elem, \"script\"));\\n            }\\n\\n            // Return the cloned set\\n            return clone;\\n        },\\n\\n        buildFragment: function buildFragment(elems, context, scripts, selection) {\\n            var elem,\\n                tmp,\\n                tag,\\n                wrap,\\n                contains,\\n                j,\\n                fragment = context.createDocumentFragment(),\\n                nodes = [],\\n                i = 0,\\n                l = elems.length;\\n\\n            for (; i < l; i++) {\\n                elem = elems[i];\\n\\n                if (elem || elem === 0) {\\n\\n                    // Add nodes directly\\n                    if (jQuery.type(elem) === \"object\") {\\n                        // Support: QtWebKit\\n                        // jQuery.merge because push.apply(_, arraylike) throws\\n                        jQuery.merge(nodes, elem.nodeType ? [elem] : elem);\\n\\n                        // Convert non-html into a text node\\n                    } else if (!rhtml.test(elem)) {\\n                        nodes.push(context.createTextNode(elem));\\n\\n                        // Convert html into DOM nodes\\n                    } else {\\n                        tmp = tmp || fragment.appendChild(context.createElement(\"div\"));\\n\\n                        // Deserialize a standard representation\\n                        tag = (rtagName.exec(elem) || [\"\", \"\"])[1].toLowerCase();\\n                        wrap = wrapMap[tag] || wrapMap._default;\\n                        tmp.innerHTML = wrap[1] + elem.replace(rxhtmlTag, \"<$1></$2>\") + wrap[2];\\n\\n                        // Descend through wrappers to the right content\\n                        j = wrap[0];\\n                        while (j--) {\\n                            tmp = tmp.lastChild;\\n                        }\\n\\n                        // Support: QtWebKit\\n                        // jQuery.merge because push.apply(_, arraylike) throws\\n                        jQuery.merge(nodes, tmp.childNodes);\\n\\n                        // Remember the top-level container\\n                        tmp = fragment.firstChild;\\n\\n                        // Fixes #12346\\n                        // Support: Webkit, IE\\n                        tmp.textContent = \"\";\\n                    }\\n                }\\n            }\\n\\n            // Remove wrapper from fragment\\n            fragment.textContent = \"\";\\n\\n            i = 0;\\n            while (elem = nodes[i++]) {\\n\\n                // #4087 - If origin and destination elements are the same, and this is\\n                // that element, do not do anything\\n                if (selection && jQuery.inArray(elem, selection) !== -1) {\\n                    continue;\\n                }\\n\\n                contains = jQuery.contains(elem.ownerDocument, elem);\\n\\n                // Append to fragment\\n                tmp = getAll(fragment.appendChild(elem), \"script\");\\n\\n                // Preserve script evaluation history\\n                if (contains) {\\n                    setGlobalEval(tmp);\\n                }\\n\\n                // Capture executables\\n                if (scripts) {\\n                    j = 0;\\n                    while (elem = tmp[j++]) {\\n                        if (rscriptType.test(elem.type || \"\")) {\\n                            scripts.push(elem);\\n                        }\\n                    }\\n                }\\n            }\\n\\n            return fragment;\\n        },\\n\\n        cleanData: function cleanData(elems) {\\n            var data,\\n                elem,\\n                type,\\n                key,\\n                special = jQuery.event.special,\\n                i = 0;\\n\\n            for (; (elem = elems[i]) !== undefined; i++) {\\n                if (jQuery.acceptData(elem)) {\\n                    key = elem[data_priv.expando];\\n\\n                    if (key && (data = data_priv.cache[key])) {\\n                        if (data.events) {\\n                            for (type in data.events) {\\n                                if (special[type]) {\\n                                    jQuery.event.remove(elem, type);\\n\\n                                    // This is a shortcut to avoid jQuery.event.remove\\'s overhead\\n                                } else {\\n                                    jQuery.removeEvent(elem, type, data.handle);\\n                                }\\n                            }\\n                        }\\n                        if (data_priv.cache[key]) {\\n                            // Discard any remaining `private` data\\n                            delete data_priv.cache[key];\\n                        }\\n                    }\\n                }\\n                // Discard any remaining `user` data\\n                delete data_user.cache[elem[data_user.expando]];\\n            }\\n        }\\n    });\\n\\n    jQuery.fn.extend({\\n        text: function text(value) {\\n            return access(this, function (value) {\\n                return value === undefined ? jQuery.text(this) : this.empty().each(function () {\\n                    if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {\\n                        this.textContent = value;\\n                    }\\n                });\\n            }, null, value, arguments.length);\\n        },\\n\\n        append: function append() {\\n            return this.domManip(arguments, function (elem) {\\n                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {\\n                    var target = manipulationTarget(this, elem);\\n                    target.appendChild(elem);\\n                }\\n            });\\n        },\\n\\n        prepend: function prepend() {\\n            return this.domManip(arguments, function (elem) {\\n                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {\\n                    var target = manipulationTarget(this, elem);\\n                    target.insertBefore(elem, target.firstChild);\\n                }\\n            });\\n        },\\n\\n        before: function before() {\\n            return this.domManip(arguments, function (elem) {\\n                if (this.parentNode) {\\n                    this.parentNode.insertBefore(elem, this);\\n                }\\n            });\\n        },\\n\\n        after: function after() {\\n            return this.domManip(arguments, function (elem) {\\n                if (this.parentNode) {\\n                    this.parentNode.insertBefore(elem, this.nextSibling);\\n                }\\n            });\\n        },\\n\\n        remove: function remove(selector, keepData /* Internal Use Only */) {\\n            var elem,\\n                elems = selector ? jQuery.filter(selector, this) : this,\\n                i = 0;\\n\\n            for (; (elem = elems[i]) != null; i++) {\\n                if (!keepData && elem.nodeType === 1) {\\n                    jQuery.cleanData(getAll(elem));\\n                }\\n\\n                if (elem.parentNode) {\\n                    if (keepData && jQuery.contains(elem.ownerDocument, elem)) {\\n                        setGlobalEval(getAll(elem, \"script\"));\\n                    }\\n                    elem.parentNode.removeChild(elem);\\n                }\\n            }\\n\\n            return this;\\n        },\\n\\n        empty: function empty() {\\n            var elem,\\n                i = 0;\\n\\n            for (; (elem = this[i]) != null; i++) {\\n                if (elem.nodeType === 1) {\\n\\n                    // Prevent memory leaks\\n                    jQuery.cleanData(getAll(elem, false));\\n\\n                    // Remove any remaining nodes\\n                    elem.textContent = \"\";\\n                }\\n            }\\n\\n            return this;\\n        },\\n\\n        clone: function clone(dataAndEvents, deepDataAndEvents) {\\n            dataAndEvents = dataAndEvents == null ? false : dataAndEvents;\\n            deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\\n\\n            return this.map(function () {\\n                return jQuery.clone(this, dataAndEvents, deepDataAndEvents);\\n            });\\n        },\\n\\n        html: function html(value) {\\n            return access(this, function (value) {\\n                var elem = this[0] || {},\\n                    i = 0,\\n                    l = this.length;\\n\\n                if (value === undefined && elem.nodeType === 1) {\\n                    return elem.innerHTML;\\n                }\\n\\n                // See if we can take a shortcut and just use innerHTML\\n                if (typeof value === \"string\" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || [\"\", \"\"])[1].toLowerCase()]) {\\n\\n                    value = value.replace(rxhtmlTag, \"<$1></$2>\");\\n\\n                    try {\\n                        for (; i < l; i++) {\\n                            elem = this[i] || {};\\n\\n                            // Remove element nodes and prevent memory leaks\\n                            if (elem.nodeType === 1) {\\n                                jQuery.cleanData(getAll(elem, false));\\n                                elem.innerHTML = value;\\n                            }\\n                        }\\n\\n                        elem = 0;\\n\\n                        // If using innerHTML throws an exception, use the fallback method\\n                    } catch (e) {}\\n                }\\n\\n                if (elem) {\\n                    this.empty().append(value);\\n                }\\n            }, null, value, arguments.length);\\n        },\\n\\n        replaceWith: function replaceWith() {\\n            var arg = arguments[0];\\n\\n            // Make the changes, replacing each context element with the new content\\n            this.domManip(arguments, function (elem) {\\n                arg = this.parentNode;\\n\\n                jQuery.cleanData(getAll(this));\\n\\n                if (arg) {\\n                    arg.replaceChild(elem, this);\\n                }\\n            });\\n\\n            // Force removal if there was no new content (e.g., from empty arguments)\\n            return arg && (arg.length || arg.nodeType) ? this : this.remove();\\n        },\\n\\n        detach: function detach(selector) {\\n            return this.remove(selector, true);\\n        },\\n\\n        domManip: function domManip(args, callback) {\\n\\n            // Flatten any nested arrays\\n            args = concat.apply([], args);\\n\\n            var fragment,\\n                first,\\n                scripts,\\n                hasScripts,\\n                node,\\n                doc,\\n                i = 0,\\n                l = this.length,\\n                set = this,\\n                iNoClone = l - 1,\\n                value = args[0],\\n                isFunction = jQuery.isFunction(value);\\n\\n            // We can\\'t cloneNode fragments that contain checked, in WebKit\\n            if (isFunction || l > 1 && typeof value === \"string\" && !support.checkClone && rchecked.test(value)) {\\n                return this.each(function (index) {\\n                    var self = set.eq(index);\\n                    if (isFunction) {\\n                        args[0] = value.call(this, index, self.html());\\n                    }\\n                    self.domManip(args, callback);\\n                });\\n            }\\n\\n            if (l) {\\n                fragment = jQuery.buildFragment(args, this[0].ownerDocument, false, this);\\n                first = fragment.firstChild;\\n\\n                if (fragment.childNodes.length === 1) {\\n                    fragment = first;\\n                }\\n\\n                if (first) {\\n                    scripts = jQuery.map(getAll(fragment, \"script\"), disableScript);\\n                    hasScripts = scripts.length;\\n\\n                    // Use the original fragment for the last item instead of the first because it can end up\\n                    // being emptied incorrectly in certain situations (#8070).\\n                    for (; i < l; i++) {\\n                        node = fragment;\\n\\n                        if (i !== iNoClone) {\\n                            node = jQuery.clone(node, true, true);\\n\\n                            // Keep references to cloned scripts for later restoration\\n                            if (hasScripts) {\\n                                // Support: QtWebKit\\n                                // jQuery.merge because push.apply(_, arraylike) throws\\n                                jQuery.merge(scripts, getAll(node, \"script\"));\\n                            }\\n                        }\\n\\n                        callback.call(this[i], node, i);\\n                    }\\n\\n                    if (hasScripts) {\\n                        doc = scripts[scripts.length - 1].ownerDocument;\\n\\n                        // Reenable scripts\\n                        jQuery.map(scripts, restoreScript);\\n\\n                        // Evaluate executable scripts on first document insertion\\n                        for (i = 0; i < hasScripts; i++) {\\n                            node = scripts[i];\\n                            if (rscriptType.test(node.type || \"\") && !data_priv.access(node, \"globalEval\") && jQuery.contains(doc, node)) {\\n\\n                                if (node.src) {\\n                                    // Optional AJAX dependency, but won\\'t run scripts if not present\\n                                    if (jQuery._evalUrl) {\\n                                        jQuery._evalUrl(node.src);\\n                                    }\\n                                } else {\\n                                    jQuery.globalEval(node.textContent.replace(rcleanScript, \"\"));\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n\\n            return this;\\n        }\\n    });\\n\\n    jQuery.each({\\n        appendTo: \"append\",\\n        prependTo: \"prepend\",\\n        insertBefore: \"before\",\\n        insertAfter: \"after\",\\n        replaceAll: \"replaceWith\"\\n    }, function (name, original) {\\n        jQuery.fn[name] = function (selector) {\\n            var elems,\\n                ret = [],\\n                insert = jQuery(selector),\\n                last = insert.length - 1,\\n                i = 0;\\n\\n            for (; i <= last; i++) {\\n                elems = i === last ? this : this.clone(true);\\n                jQuery(insert[i])[original](elems);\\n\\n                // Support: QtWebKit\\n                // .get() because push.apply(_, arraylike) throws\\n                push.apply(ret, elems.get());\\n            }\\n\\n            return this.pushStack(ret);\\n        };\\n    });\\n\\n    var iframe,\\n        elemdisplay = {};\\n\\n    /**\\r\\n     * Retrieve the actual display of a element\\r\\n     * @param {String} name nodeName of the element\\r\\n     * @param {Object} doc Document object\\r\\n     */\\n    // Called only from within defaultDisplay\\n    function actualDisplay(name, doc) {\\n        var style,\\n            elem = jQuery(doc.createElement(name)).appendTo(doc.body),\\n\\n\\n        // getDefaultComputedStyle might be reliably used only on attached element\\n        display = window.getDefaultComputedStyle && (style = window.getDefaultComputedStyle(elem[0])) ?\\n\\n        // Use of this method is a temporary fix (more like optmization) until something better comes along,\\n        // since it was removed from specification and supported only in FF\\n        style.display : jQuery.css(elem[0], \"display\");\\n\\n        // We don\\'t have any data stored on the element,\\n        // so use \"detach\" method as fast way to get rid of the element\\n        elem.detach();\\n\\n        return display;\\n    }\\n\\n    /**\\r\\n     * Try to determine the default display value of an element\\r\\n     * @param {String} nodeName\\r\\n     */\\n    function defaultDisplay(nodeName) {\\n        var doc = document,\\n            display = elemdisplay[nodeName];\\n\\n        if (!display) {\\n            display = actualDisplay(nodeName, doc);\\n\\n            // If the simple way fails, read from inside an iframe\\n            if (display === \"none\" || !display) {\\n\\n                // Use the already-created iframe if possible\\n                iframe = (iframe || jQuery(\"<iframe frameborder=\\'0\\' width=\\'0\\' height=\\'0\\'/>\")).appendTo(doc.documentElement);\\n\\n                // Always write a new HTML skeleton so Webkit and Firefox don\\'t choke on reuse\\n                doc = iframe[0].contentDocument;\\n\\n                // Support: IE\\n                doc.write();\\n                doc.close();\\n\\n                display = actualDisplay(nodeName, doc);\\n                iframe.detach();\\n            }\\n\\n            // Store the correct default display\\n            elemdisplay[nodeName] = display;\\n        }\\n\\n        return display;\\n    }\\n    var rmargin = /^margin/;\\n\\n    var rnumnonpx = new RegExp(\"^(\" + pnum + \")(?!px)[a-z%]+$\", \"i\");\\n\\n    var getStyles = function getStyles(elem) {\\n        return elem.ownerDocument.defaultView.getComputedStyle(elem, null);\\n    };\\n\\n    function curCSS(elem, name, computed) {\\n        var width,\\n            minWidth,\\n            maxWidth,\\n            ret,\\n            style = elem.style;\\n\\n        computed = computed || getStyles(elem);\\n\\n        // Support: IE9\\n        // getPropertyValue is only needed for .css(\\'filter\\') in IE9, see #12537\\n        if (computed) {\\n            ret = computed.getPropertyValue(name) || computed[name];\\n        }\\n\\n        if (computed) {\\n\\n            if (ret === \"\" && !jQuery.contains(elem.ownerDocument, elem)) {\\n                ret = jQuery.style(elem, name);\\n            }\\n\\n            // Support: iOS < 6\\n            // A tribute to the \"awesome hack by Dean Edwards\"\\n            // iOS < 6 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels\\n            // this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values\\n            if (rnumnonpx.test(ret) && rmargin.test(name)) {\\n\\n                // Remember the original values\\n                width = style.width;\\n                minWidth = style.minWidth;\\n                maxWidth = style.maxWidth;\\n\\n                // Put in the new values to get a computed value out\\n                style.minWidth = style.maxWidth = style.width = ret;\\n                ret = computed.width;\\n\\n                // Revert the changed values\\n                style.width = width;\\n                style.minWidth = minWidth;\\n                style.maxWidth = maxWidth;\\n            }\\n        }\\n\\n        return ret !== undefined ?\\n        // Support: IE\\n        // IE returns zIndex value as an integer.\\n        ret + \"\" : ret;\\n    }\\n\\n    function addGetHookIf(conditionFn, hookFn) {\\n        // Define the hook, we\\'ll check on the first run if it\\'s really needed.\\n        return {\\n            get: function get() {\\n                if (conditionFn()) {\\n                    // Hook not needed (or it\\'s not possible to use it due to missing dependency),\\n                    // remove it.\\n                    // Since there are no other hooks for marginRight, remove the whole object.\\n                    delete this.get;\\n                    return;\\n                }\\n\\n                // Hook needed; redefine it so that the support test is not executed again.\\n\\n                return (this.get = hookFn).apply(this, arguments);\\n            }\\n        };\\n    }\\n\\n    (function () {\\n        var pixelPositionVal,\\n            boxSizingReliableVal,\\n            docElem = document.documentElement,\\n            container = document.createElement(\"div\"),\\n            div = document.createElement(\"div\");\\n\\n        if (!div.style) {\\n            return;\\n        }\\n\\n        div.style.backgroundClip = \"content-box\";\\n        div.cloneNode(true).style.backgroundClip = \"\";\\n        support.clearCloneStyle = div.style.backgroundClip === \"content-box\";\\n\\n        container.style.cssText = \"border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;\" + \"position:absolute\";\\n        container.appendChild(div);\\n\\n        // Executing both pixelPosition & boxSizingReliable tests require only one layout\\n        // so they\\'re executed at the same time to save the second computation.\\n        function computePixelPositionAndBoxSizingReliable() {\\n            div.style.cssText =\\n            // Support: Firefox<29, Android 2.3\\n            // Vendor-prefix box-sizing\\n            \"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;\" + \"box-sizing:border-box;display:block;margin-top:1%;top:1%;\" + \"border:1px;padding:1px;width:4px;position:absolute\";\\n            div.innerHTML = \"\";\\n            docElem.appendChild(container);\\n\\n            var divStyle = window.getComputedStyle(div, null);\\n            pixelPositionVal = divStyle.top !== \"1%\";\\n            boxSizingReliableVal = divStyle.width === \"4px\";\\n\\n            docElem.removeChild(container);\\n        }\\n\\n        // Support: node.js jsdom\\n        // Don\\'t assume that getComputedStyle is a property of the global object\\n        if (window.getComputedStyle) {\\n            jQuery.extend(support, {\\n                pixelPosition: function pixelPosition() {\\n                    // This test is executed only once but we still do memoizing\\n                    // since we can use the boxSizingReliable pre-computing.\\n                    // No need to check if the test was already performed, though.\\n                    computePixelPositionAndBoxSizingReliable();\\n                    return pixelPositionVal;\\n                },\\n                boxSizingReliable: function boxSizingReliable() {\\n                    if (boxSizingReliableVal == null) {\\n                        computePixelPositionAndBoxSizingReliable();\\n                    }\\n                    return boxSizingReliableVal;\\n                },\\n                reliableMarginRight: function reliableMarginRight() {\\n                    // Support: Android 2.3\\n                    // Check if div with explicit width and no margin-right incorrectly\\n                    // gets computed margin-right based on width of container. (#3333)\\n                    // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right\\n                    // This support function is only executed once so no memoizing is needed.\\n                    var ret,\\n                        marginDiv = div.appendChild(document.createElement(\"div\"));\\n\\n                    // Reset CSS: box-sizing; display; margin; border; padding\\n                    marginDiv.style.cssText = div.style.cssText =\\n                    // Support: Firefox<29, Android 2.3\\n                    // Vendor-prefix box-sizing\\n                    \"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;\" + \"box-sizing:content-box;display:block;margin:0;border:0;padding:0\";\\n                    marginDiv.style.marginRight = marginDiv.style.width = \"0\";\\n                    div.style.width = \"1px\";\\n                    docElem.appendChild(container);\\n\\n                    ret = !parseFloat(window.getComputedStyle(marginDiv, null).marginRight);\\n\\n                    docElem.removeChild(container);\\n\\n                    return ret;\\n                }\\n            });\\n        }\\n    })();\\n\\n    // A method for quickly swapping in/out CSS properties to get correct calculations.\\n    jQuery.swap = function (elem, options, callback, args) {\\n        var ret,\\n            name,\\n            old = {};\\n\\n        // Remember the old values, and insert the new ones\\n        for (name in options) {\\n            old[name] = elem.style[name];\\n            elem.style[name] = options[name];\\n        }\\n\\n        ret = callback.apply(elem, args || []);\\n\\n        // Revert the old values\\n        for (name in options) {\\n            elem.style[name] = old[name];\\n        }\\n\\n        return ret;\\n    };\\n\\n    var\\n    // swappable if display is none or starts with table except \"table\", \"table-cell\", or \"table-caption\"\\n    // see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\\n    rdisplayswap = /^(none|table(?!-c[ea]).+)/,\\n        rnumsplit = new RegExp(\"^(\" + pnum + \")(.*)$\", \"i\"),\\n        rrelNum = new RegExp(\"^([+-])=(\" + pnum + \")\", \"i\"),\\n        cssShow = { position: \"absolute\", visibility: \"hidden\", display: \"block\" },\\n        cssNormalTransform = {\\n        letterSpacing: \"0\",\\n        fontWeight: \"400\"\\n    },\\n        cssPrefixes = [\"Webkit\", \"O\", \"Moz\", \"ms\"];\\n\\n    // return a css property mapped to a potentially vendor prefixed property\\n    function vendorPropName(style, name) {\\n\\n        // shortcut for names that are not vendor prefixed\\n        if (name in style) {\\n            return name;\\n        }\\n\\n        // check for vendor prefixed names\\n        var capName = name[0].toUpperCase() + name.slice(1),\\n            origName = name,\\n            i = cssPrefixes.length;\\n\\n        while (i--) {\\n            name = cssPrefixes[i] + capName;\\n            if (name in style) {\\n                return name;\\n            }\\n        }\\n\\n        return origName;\\n    }\\n\\n    function setPositiveNumber(elem, value, subtract) {\\n        var matches = rnumsplit.exec(value);\\n        return matches ?\\n        // Guard against undefined \"subtract\", e.g., when used as in cssHooks\\n        Math.max(0, matches[1] - (subtract || 0)) + (matches[2] || \"px\") : value;\\n    }\\n\\n    function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {\\n        var i = extra === (isBorderBox ? \"border\" : \"content\") ?\\n        // If we already have the right measurement, avoid augmentation\\n        4 :\\n        // Otherwise initialize for horizontal or vertical properties\\n        name === \"width\" ? 1 : 0,\\n            val = 0;\\n\\n        for (; i < 4; i += 2) {\\n            // both box models exclude margin, so add it if we want it\\n            if (extra === \"margin\") {\\n                val += jQuery.css(elem, extra + cssExpand[i], true, styles);\\n            }\\n\\n            if (isBorderBox) {\\n                // border-box includes padding, so remove it if we want content\\n                if (extra === \"content\") {\\n                    val -= jQuery.css(elem, \"padding\" + cssExpand[i], true, styles);\\n                }\\n\\n                // at this point, extra isn\\'t border nor margin, so remove border\\n                if (extra !== \"margin\") {\\n                    val -= jQuery.css(elem, \"border\" + cssExpand[i] + \"Width\", true, styles);\\n                }\\n            } else {\\n                // at this point, extra isn\\'t content, so add padding\\n                val += jQuery.css(elem, \"padding\" + cssExpand[i], true, styles);\\n\\n                // at this point, extra isn\\'t content nor padding, so add border\\n                if (extra !== \"padding\") {\\n                    val += jQuery.css(elem, \"border\" + cssExpand[i] + \"Width\", true, styles);\\n                }\\n            }\\n        }\\n\\n        return val;\\n    }\\n\\n    function getWidthOrHeight(elem, name, extra) {\\n\\n        // Start with offset property, which is equivalent to the border-box value\\n        var valueIsBorderBox = true,\\n            val = name === \"width\" ? elem.offsetWidth : elem.offsetHeight,\\n            styles = getStyles(elem),\\n            isBorderBox = jQuery.css(elem, \"boxSizing\", false, styles) === \"border-box\";\\n\\n        // some non-html elements return undefined for offsetWidth, so check for null/undefined\\n        // svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285\\n        // MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668\\n        if (val <= 0 || val == null) {\\n            // Fall back to computed then uncomputed css if necessary\\n            val = curCSS(elem, name, styles);\\n            if (val < 0 || val == null) {\\n                val = elem.style[name];\\n            }\\n\\n            // Computed unit is not pixels. Stop here and return.\\n            if (rnumnonpx.test(val)) {\\n                return val;\\n            }\\n\\n            // we need the check for style in case a browser which returns unreliable values\\n            // for getComputedStyle silently falls back to the reliable elem.style\\n            valueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name]);\\n\\n            // Normalize \"\", auto, and prepare for extra\\n            val = parseFloat(val) || 0;\\n        }\\n\\n        // use the active box-sizing model to add/subtract irrelevant styles\\n        return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? \"border\" : \"content\"), valueIsBorderBox, styles) + \"px\";\\n    }\\n\\n    function showHide(elements, show) {\\n        var display,\\n            elem,\\n            hidden,\\n            values = [],\\n            index = 0,\\n            length = elements.length;\\n\\n        for (; index < length; index++) {\\n            elem = elements[index];\\n            if (!elem.style) {\\n                continue;\\n            }\\n\\n            values[index] = data_priv.get(elem, \"olddisplay\");\\n            display = elem.style.display;\\n            if (show) {\\n                // Reset the inline display of this element to learn if it is\\n                // being hidden by cascaded rules or not\\n                if (!values[index] && display === \"none\") {\\n                    elem.style.display = \"\";\\n                }\\n\\n                // Set elements which have been overridden with display: none\\n                // in a stylesheet to whatever the default browser style is\\n                // for such an element\\n                if (elem.style.display === \"\" && isHidden(elem)) {\\n                    values[index] = data_priv.access(elem, \"olddisplay\", defaultDisplay(elem.nodeName));\\n                }\\n            } else {\\n                hidden = isHidden(elem);\\n\\n                if (display !== \"none\" || !hidden) {\\n                    data_priv.set(elem, \"olddisplay\", hidden ? display : jQuery.css(elem, \"display\"));\\n                }\\n            }\\n        }\\n\\n        // Set the display of most of the elements in a second loop\\n        // to avoid the constant reflow\\n        for (index = 0; index < length; index++) {\\n            elem = elements[index];\\n            if (!elem.style) {\\n                continue;\\n            }\\n            if (!show || elem.style.display === \"none\" || elem.style.display === \"\") {\\n                elem.style.display = show ? values[index] || \"\" : \"none\";\\n            }\\n        }\\n\\n        return elements;\\n    }\\n\\n    jQuery.extend({\\n        // Add in style property hooks for overriding the default\\n        // behavior of getting and setting a style property\\n        cssHooks: {\\n            opacity: {\\n                get: function get(elem, computed) {\\n                    if (computed) {\\n                        // We should always get a number back from opacity\\n                        var ret = curCSS(elem, \"opacity\");\\n                        return ret === \"\" ? \"1\" : ret;\\n                    }\\n                }\\n            }\\n        },\\n\\n        // Don\\'t automatically add \"px\" to these possibly-unitless properties\\n        cssNumber: {\\n            \"columnCount\": true,\\n            \"fillOpacity\": true,\\n            \"flexGrow\": true,\\n            \"flexShrink\": true,\\n            \"fontWeight\": true,\\n            \"lineHeight\": true,\\n            \"opacity\": true,\\n            \"order\": true,\\n            \"orphans\": true,\\n            \"widows\": true,\\n            \"zIndex\": true,\\n            \"zoom\": true\\n        },\\n\\n        // Add in properties whose names you wish to fix before\\n        // setting or getting the value\\n        cssProps: {\\n            // normalize float css property\\n            \"float\": \"cssFloat\"\\n        },\\n\\n        // Get and set the style property on a DOM Node\\n        style: function style(elem, name, value, extra) {\\n            // Don\\'t set styles on text and comment nodes\\n            if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {\\n                return;\\n            }\\n\\n            // Make sure that we\\'re working with the right name\\n            var ret,\\n                type,\\n                hooks,\\n                origName = jQuery.camelCase(name),\\n                style = elem.style;\\n\\n            name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(style, origName));\\n\\n            // gets hook for the prefixed version\\n            // followed by the unprefixed version\\n            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];\\n\\n            // Check if we\\'re setting a value\\n            if (value !== undefined) {\\n                type = typeof value === \"undefined\" ? \"undefined\" : _typeof(value);\\n\\n                // convert relative number strings (+= or -=) to relative numbers. #7345\\n                if (type === \"string\" && (ret = rrelNum.exec(value))) {\\n                    value = (ret[1] + 1) * ret[2] + parseFloat(jQuery.css(elem, name));\\n                    // Fixes bug #9237\\n                    type = \"number\";\\n                }\\n\\n                // Make sure that null and NaN values aren\\'t set. See: #7116\\n                if (value == null || value !== value) {\\n                    return;\\n                }\\n\\n                // If a number was passed in, add \\'px\\' to the (except for certain CSS properties)\\n                if (type === \"number\" && !jQuery.cssNumber[origName]) {\\n                    value += \"px\";\\n                }\\n\\n                // Fixes #8908, it can be done more correctly by specifying setters in cssHooks,\\n                // but it would mean to define eight (for every problematic property) identical functions\\n                if (!support.clearCloneStyle && value === \"\" && name.indexOf(\"background\") === 0) {\\n                    style[name] = \"inherit\";\\n                }\\n\\n                // If a hook was provided, use that value, otherwise just set the specified value\\n                if (!hooks || !(\"set\" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {\\n                    style[name] = value;\\n                }\\n            } else {\\n                // If a hook was provided get the non-computed value from there\\n                if (hooks && \"get\" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {\\n                    return ret;\\n                }\\n\\n                // Otherwise just get the value from the style object\\n                return style[name];\\n            }\\n        },\\n\\n        css: function css(elem, name, extra, styles) {\\n            var val,\\n                num,\\n                hooks,\\n                origName = jQuery.camelCase(name);\\n\\n            // Make sure that we\\'re working with the right name\\n            name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(elem.style, origName));\\n\\n            // gets hook for the prefixed version\\n            // followed by the unprefixed version\\n            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];\\n\\n            // If a hook was provided get the computed value from there\\n            if (hooks && \"get\" in hooks) {\\n                val = hooks.get(elem, true, extra);\\n            }\\n\\n            // Otherwise, if a way to get the computed value exists, use that\\n            if (val === undefined) {\\n                val = curCSS(elem, name, styles);\\n            }\\n\\n            //convert \"normal\" to computed value\\n            if (val === \"normal\" && name in cssNormalTransform) {\\n                val = cssNormalTransform[name];\\n            }\\n\\n            // Return, converting to number if forced or a qualifier was provided and val looks numeric\\n            if (extra === \"\" || extra) {\\n                num = parseFloat(val);\\n                return extra === true || jQuery.isNumeric(num) ? num || 0 : val;\\n            }\\n            return val;\\n        }\\n    });\\n\\n    jQuery.each([\"height\", \"width\"], function (i, name) {\\n        jQuery.cssHooks[name] = {\\n            get: function get(elem, computed, extra) {\\n                if (computed) {\\n                    // certain elements can have dimension info if we invisibly show them\\n                    // however, it must have a current display style that would benefit from this\\n                    return rdisplayswap.test(jQuery.css(elem, \"display\")) && elem.offsetWidth === 0 ? jQuery.swap(elem, cssShow, function () {\\n                        return getWidthOrHeight(elem, name, extra);\\n                    }) : getWidthOrHeight(elem, name, extra);\\n                }\\n            },\\n\\n            set: function set(elem, value, extra) {\\n                var styles = extra && getStyles(elem);\\n                return setPositiveNumber(elem, value, extra ? augmentWidthOrHeight(elem, name, extra, jQuery.css(elem, \"boxSizing\", false, styles) === \"border-box\", styles) : 0);\\n            }\\n        };\\n    });\\n\\n    // Support: Android 2.3\\n    jQuery.cssHooks.marginRight = addGetHookIf(support.reliableMarginRight, function (elem, computed) {\\n        if (computed) {\\n            // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right\\n            // Work around by temporarily setting element display to inline-block\\n            return jQuery.swap(elem, { \"display\": \"inline-block\" }, curCSS, [elem, \"marginRight\"]);\\n        }\\n    });\\n\\n    // These hooks are used by animate to expand properties\\n    jQuery.each({\\n        margin: \"\",\\n        padding: \"\",\\n        border: \"Width\"\\n    }, function (prefix, suffix) {\\n        jQuery.cssHooks[prefix + suffix] = {\\n            expand: function expand(value) {\\n                var i = 0,\\n                    expanded = {},\\n\\n\\n                // assumes a single number if not a string\\n                parts = typeof value === \"string\" ? value.split(\" \") : [value];\\n\\n                for (; i < 4; i++) {\\n                    expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];\\n                }\\n\\n                return expanded;\\n            }\\n        };\\n\\n        if (!rmargin.test(prefix)) {\\n            jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;\\n        }\\n    });\\n\\n    jQuery.fn.extend({\\n        css: function css(name, value) {\\n            return access(this, function (elem, name, value) {\\n                var styles,\\n                    len,\\n                    map = {},\\n                    i = 0;\\n\\n                if (jQuery.isArray(name)) {\\n                    styles = getStyles(elem);\\n                    len = name.length;\\n\\n                    for (; i < len; i++) {\\n                        map[name[i]] = jQuery.css(elem, name[i], false, styles);\\n                    }\\n\\n                    return map;\\n                }\\n\\n                return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);\\n            }, name, value, arguments.length > 1);\\n        },\\n        show: function show() {\\n            return showHide(this, true);\\n        },\\n        hide: function hide() {\\n            return showHide(this);\\n        },\\n        toggle: function toggle(state) {\\n            if (typeof state === \"boolean\") {\\n                return state ? this.show() : this.hide();\\n            }\\n\\n            return this.each(function () {\\n                if (isHidden(this)) {\\n                    jQuery(this).show();\\n                } else {\\n                    jQuery(this).hide();\\n                }\\n            });\\n        }\\n    });\\n\\n    function Tween(elem, options, prop, end, easing) {\\n        return new Tween.prototype.init(elem, options, prop, end, easing);\\n    }\\n    jQuery.Tween = Tween;\\n\\n    Tween.prototype = {\\n        constructor: Tween,\\n        init: function init(elem, options, prop, end, easing, unit) {\\n            this.elem = elem;\\n            this.prop = prop;\\n            this.easing = easing || \"swing\";\\n            this.options = options;\\n            this.start = this.now = this.cur();\\n            this.end = end;\\n            this.unit = unit || (jQuery.cssNumber[prop] ? \"\" : \"px\");\\n        },\\n        cur: function cur() {\\n            var hooks = Tween.propHooks[this.prop];\\n\\n            return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);\\n        },\\n        run: function run(percent) {\\n            var eased,\\n                hooks = Tween.propHooks[this.prop];\\n\\n            if (this.options.duration) {\\n                this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);\\n            } else {\\n                this.pos = eased = percent;\\n            }\\n            this.now = (this.end - this.start) * eased + this.start;\\n\\n            if (this.options.step) {\\n                this.options.step.call(this.elem, this.now, this);\\n            }\\n\\n            if (hooks && hooks.set) {\\n                hooks.set(this);\\n            } else {\\n                Tween.propHooks._default.set(this);\\n            }\\n            return this;\\n        }\\n    };\\n\\n    Tween.prototype.init.prototype = Tween.prototype;\\n\\n    Tween.propHooks = {\\n        _default: {\\n            get: function get(tween) {\\n                var result;\\n\\n                if (tween.elem[tween.prop] != null && (!tween.elem.style || tween.elem.style[tween.prop] == null)) {\\n                    return tween.elem[tween.prop];\\n                }\\n\\n                // passing an empty string as a 3rd parameter to .css will automatically\\n                // attempt a parseFloat and fallback to a string if the parse fails\\n                // so, simple values such as \"10px\" are parsed to Float.\\n                // complex values such as \"rotate(1rad)\" are returned as is.\\n                result = jQuery.css(tween.elem, tween.prop, \"\");\\n                // Empty strings, null, undefined and \"auto\" are converted to 0.\\n                return !result || result === \"auto\" ? 0 : result;\\n            },\\n            set: function set(tween) {\\n                // use step hook for back compat - use cssHook if its there - use .style if its\\n                // available and use plain properties where available\\n                if (jQuery.fx.step[tween.prop]) {\\n                    jQuery.fx.step[tween.prop](tween);\\n                } else if (tween.elem.style && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {\\n                    jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);\\n                } else {\\n                    tween.elem[tween.prop] = tween.now;\\n                }\\n            }\\n        }\\n    };\\n\\n    // Support: IE9\\n    // Panic based approach to setting things on disconnected nodes\\n\\n    Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\\n        set: function set(tween) {\\n            if (tween.elem.nodeType && tween.elem.parentNode) {\\n                tween.elem[tween.prop] = tween.now;\\n            }\\n        }\\n    };\\n\\n    jQuery.easing = {\\n        linear: function linear(p) {\\n            return p;\\n        },\\n        swing: function swing(p) {\\n            return 0.5 - Math.cos(p * Math.PI) / 2;\\n        }\\n    };\\n\\n    jQuery.fx = Tween.prototype.init;\\n\\n    // Back Compat <1.8 extension point\\n    jQuery.fx.step = {};\\n\\n    var fxNow,\\n        timerId,\\n        rfxtypes = /^(?:toggle|show|hide)$/,\\n        rfxnum = new RegExp(\"^(?:([+-])=|)(\" + pnum + \")([a-z%]*)$\", \"i\"),\\n        rrun = /queueHooks$/,\\n        animationPrefilters = [defaultPrefilter],\\n        tweeners = {\\n        \"*\": [function (prop, value) {\\n            var tween = this.createTween(prop, value),\\n                target = tween.cur(),\\n                parts = rfxnum.exec(value),\\n                unit = parts && parts[3] || (jQuery.cssNumber[prop] ? \"\" : \"px\"),\\n\\n\\n            // Starting value computation is required for potential unit mismatches\\n            start = (jQuery.cssNumber[prop] || unit !== \"px\" && +target) && rfxnum.exec(jQuery.css(tween.elem, prop)),\\n                scale = 1,\\n                maxIterations = 20;\\n\\n            if (start && start[3] !== unit) {\\n                // Trust units reported by jQuery.css\\n                unit = unit || start[3];\\n\\n                // Make sure we update the tween properties later on\\n                parts = parts || [];\\n\\n                // Iteratively approximate from a nonzero starting point\\n                start = +target || 1;\\n\\n                do {\\n                    // If previous iteration zeroed out, double until we get *something*\\n                    // Use a string for doubling factor so we don\\'t accidentally see scale as unchanged below\\n                    scale = scale || \".5\";\\n\\n                    // Adjust and apply\\n                    start = start / scale;\\n                    jQuery.style(tween.elem, prop, start + unit);\\n\\n                    // Update scale, tolerating zero or NaN from tween.cur()\\n                    // And breaking the loop if scale is unchanged or perfect, or if we\\'ve just had enough\\n                } while (scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations);\\n            }\\n\\n            // Update tween properties\\n            if (parts) {\\n                start = tween.start = +start || +target || 0;\\n                tween.unit = unit;\\n                // If a +=/-= token was provided, we\\'re doing a relative animation\\n                tween.end = parts[1] ? start + (parts[1] + 1) * parts[2] : +parts[2];\\n            }\\n\\n            return tween;\\n        }]\\n    };\\n\\n    // Animations created synchronously will run synchronously\\n    function createFxNow() {\\n        setTimeout(function () {\\n            fxNow = undefined;\\n        });\\n        return fxNow = jQuery.now();\\n    }\\n\\n    // Generate parameters to create a standard animation\\n    function genFx(type, includeWidth) {\\n        var which,\\n            i = 0,\\n            attrs = { height: type };\\n\\n        // if we include width, step value is 1 to do all cssExpand values,\\n        // if we don\\'t include width, step value is 2 to skip over Left and Right\\n        includeWidth = includeWidth ? 1 : 0;\\n        for (; i < 4; i += 2 - includeWidth) {\\n            which = cssExpand[i];\\n            attrs[\"margin\" + which] = attrs[\"padding\" + which] = type;\\n        }\\n\\n        if (includeWidth) {\\n            attrs.opacity = attrs.width = type;\\n        }\\n\\n        return attrs;\\n    }\\n\\n    function createTween(value, prop, animation) {\\n        var tween,\\n            collection = (tweeners[prop] || []).concat(tweeners[\"*\"]),\\n            index = 0,\\n            length = collection.length;\\n        for (; index < length; index++) {\\n            if (tween = collection[index].call(animation, prop, value)) {\\n\\n                // we\\'re done with this property\\n                return tween;\\n            }\\n        }\\n    }\\n\\n    function defaultPrefilter(elem, props, opts) {\\n        /* jshint validthis: true */\\n        var prop,\\n            value,\\n            toggle,\\n            tween,\\n            hooks,\\n            oldfire,\\n            display,\\n            checkDisplay,\\n            anim = this,\\n            orig = {},\\n            style = elem.style,\\n            hidden = elem.nodeType && isHidden(elem),\\n            dataShow = data_priv.get(elem, \"fxshow\");\\n\\n        // handle queue: false promises\\n        if (!opts.queue) {\\n            hooks = jQuery._queueHooks(elem, \"fx\");\\n            if (hooks.unqueued == null) {\\n                hooks.unqueued = 0;\\n                oldfire = hooks.empty.fire;\\n                hooks.empty.fire = function () {\\n                    if (!hooks.unqueued) {\\n                        oldfire();\\n                    }\\n                };\\n            }\\n            hooks.unqueued++;\\n\\n            anim.always(function () {\\n                // doing this makes sure that the complete handler will be called\\n                // before this completes\\n                anim.always(function () {\\n                    hooks.unqueued--;\\n                    if (!jQuery.queue(elem, \"fx\").length) {\\n                        hooks.empty.fire();\\n                    }\\n                });\\n            });\\n        }\\n\\n        // height/width overflow pass\\n        if (elem.nodeType === 1 && (\"height\" in props || \"width\" in props)) {\\n            // Make sure that nothing sneaks out\\n            // Record all 3 overflow attributes because IE9-10 do not\\n            // change the overflow attribute when overflowX and\\n            // overflowY are set to the same value\\n            opts.overflow = [style.overflow, style.overflowX, style.overflowY];\\n\\n            // Set display property to inline-block for height/width\\n            // animations on inline elements that are having width/height animated\\n            display = jQuery.css(elem, \"display\");\\n\\n            // Test default display if display is currently \"none\"\\n            checkDisplay = display === \"none\" ? data_priv.get(elem, \"olddisplay\") || defaultDisplay(elem.nodeName) : display;\\n\\n            if (checkDisplay === \"inline\" && jQuery.css(elem, \"float\") === \"none\") {\\n                style.display = \"inline-block\";\\n            }\\n        }\\n\\n        if (opts.overflow) {\\n            style.overflow = \"hidden\";\\n            anim.always(function () {\\n                style.overflow = opts.overflow[0];\\n                style.overflowX = opts.overflow[1];\\n                style.overflowY = opts.overflow[2];\\n            });\\n        }\\n\\n        // show/hide pass\\n        for (prop in props) {\\n            value = props[prop];\\n            if (rfxtypes.exec(value)) {\\n                delete props[prop];\\n                toggle = toggle || value === \"toggle\";\\n                if (value === (hidden ? \"hide\" : \"show\")) {\\n\\n                    // If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden\\n                    if (value === \"show\" && dataShow && dataShow[prop] !== undefined) {\\n                        hidden = true;\\n                    } else {\\n                        continue;\\n                    }\\n                }\\n                orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);\\n\\n                // Any non-fx value stops us from restoring the original display value\\n            } else {\\n                display = undefined;\\n            }\\n        }\\n\\n        if (!jQuery.isEmptyObject(orig)) {\\n            if (dataShow) {\\n                if (\"hidden\" in dataShow) {\\n                    hidden = dataShow.hidden;\\n                }\\n            } else {\\n                dataShow = data_priv.access(elem, \"fxshow\", {});\\n            }\\n\\n            // store state if its toggle - enables .stop().toggle() to \"reverse\"\\n            if (toggle) {\\n                dataShow.hidden = !hidden;\\n            }\\n            if (hidden) {\\n                jQuery(elem).show();\\n            } else {\\n                anim.done(function () {\\n                    jQuery(elem).hide();\\n                });\\n            }\\n            anim.done(function () {\\n                var prop;\\n\\n                data_priv.remove(elem, \"fxshow\");\\n                for (prop in orig) {\\n                    jQuery.style(elem, prop, orig[prop]);\\n                }\\n            });\\n            for (prop in orig) {\\n                tween = createTween(hidden ? dataShow[prop] : 0, prop, anim);\\n\\n                if (!(prop in dataShow)) {\\n                    dataShow[prop] = tween.start;\\n                    if (hidden) {\\n                        tween.end = tween.start;\\n                        tween.start = prop === \"width\" || prop === \"height\" ? 1 : 0;\\n                    }\\n                }\\n            }\\n\\n            // If this is a noop like .hide().hide(), restore an overwritten display value\\n        } else if ((display === \"none\" ? defaultDisplay(elem.nodeName) : display) === \"inline\") {\\n            style.display = display;\\n        }\\n    }\\n\\n    function propFilter(props, specialEasing) {\\n        var index, name, easing, value, hooks;\\n\\n        // camelCase, specialEasing and expand cssHook pass\\n        for (index in props) {\\n            name = jQuery.camelCase(index);\\n            easing = specialEasing[name];\\n            value = props[index];\\n            if (jQuery.isArray(value)) {\\n                easing = value[1];\\n                value = props[index] = value[0];\\n            }\\n\\n            if (index !== name) {\\n                props[name] = value;\\n                delete props[index];\\n            }\\n\\n            hooks = jQuery.cssHooks[name];\\n            if (hooks && \"expand\" in hooks) {\\n                value = hooks.expand(value);\\n                delete props[name];\\n\\n                // not quite $.extend, this wont overwrite keys already present.\\n                // also - reusing \\'index\\' from above because we have the correct \"name\"\\n                for (index in value) {\\n                    if (!(index in props)) {\\n                        props[index] = value[index];\\n                        specialEasing[index] = easing;\\n                    }\\n                }\\n            } else {\\n                specialEasing[name] = easing;\\n            }\\n        }\\n    }\\n\\n    function Animation(elem, properties, options) {\\n        var result,\\n            stopped,\\n            index = 0,\\n            length = animationPrefilters.length,\\n            deferred = jQuery.Deferred().always(function () {\\n            // don\\'t match elem in the :animated selector\\n            delete tick.elem;\\n        }),\\n            tick = function tick() {\\n            if (stopped) {\\n                return false;\\n            }\\n            var currentTime = fxNow || createFxNow(),\\n                remaining = Math.max(0, animation.startTime + animation.duration - currentTime),\\n\\n            // archaic crash bug won\\'t allow us to use 1 - ( 0.5 || 0 ) (#12497)\\n            temp = remaining / animation.duration || 0,\\n                percent = 1 - temp,\\n                index = 0,\\n                length = animation.tweens.length;\\n\\n            for (; index < length; index++) {\\n                animation.tweens[index].run(percent);\\n            }\\n\\n            deferred.notifyWith(elem, [animation, percent, remaining]);\\n\\n            if (percent < 1 && length) {\\n                return remaining;\\n            } else {\\n                deferred.resolveWith(elem, [animation]);\\n                return false;\\n            }\\n        },\\n            animation = deferred.promise({\\n            elem: elem,\\n            props: jQuery.extend({}, properties),\\n            opts: jQuery.extend(true, { specialEasing: {} }, options),\\n            originalProperties: properties,\\n            originalOptions: options,\\n            startTime: fxNow || createFxNow(),\\n            duration: options.duration,\\n            tweens: [],\\n            createTween: function createTween(prop, end) {\\n                var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);\\n                animation.tweens.push(tween);\\n                return tween;\\n            },\\n            stop: function stop(gotoEnd) {\\n                var index = 0,\\n\\n                // if we are going to the end, we want to run all the tweens\\n                // otherwise we skip this part\\n                length = gotoEnd ? animation.tweens.length : 0;\\n                if (stopped) {\\n                    return this;\\n                }\\n                stopped = true;\\n                for (; index < length; index++) {\\n                    animation.tweens[index].run(1);\\n                }\\n\\n                // resolve when we played the last frame\\n                // otherwise, reject\\n                if (gotoEnd) {\\n                    deferred.resolveWith(elem, [animation, gotoEnd]);\\n                } else {\\n                    deferred.rejectWith(elem, [animation, gotoEnd]);\\n                }\\n                return this;\\n            }\\n        }),\\n            props = animation.props;\\n\\n        propFilter(props, animation.opts.specialEasing);\\n\\n        for (; index < length; index++) {\\n            result = animationPrefilters[index].call(animation, elem, props, animation.opts);\\n            if (result) {\\n                return result;\\n            }\\n        }\\n\\n        jQuery.map(props, createTween, animation);\\n\\n        if (jQuery.isFunction(animation.opts.start)) {\\n            animation.opts.start.call(elem, animation);\\n        }\\n\\n        jQuery.fx.timer(jQuery.extend(tick, {\\n            elem: elem,\\n            anim: animation,\\n            queue: animation.opts.queue\\n        }));\\n\\n        // attach callbacks from options\\n        return animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);\\n    }\\n\\n    jQuery.Animation = jQuery.extend(Animation, {\\n\\n        tweener: function tweener(props, callback) {\\n            if (jQuery.isFunction(props)) {\\n                callback = props;\\n                props = [\"*\"];\\n            } else {\\n                props = props.split(\" \");\\n            }\\n\\n            var prop,\\n                index = 0,\\n                length = props.length;\\n\\n            for (; index < length; index++) {\\n                prop = props[index];\\n                tweeners[prop] = tweeners[prop] || [];\\n                tweeners[prop].unshift(callback);\\n            }\\n        },\\n\\n        prefilter: function prefilter(callback, prepend) {\\n            if (prepend) {\\n                animationPrefilters.unshift(callback);\\n            } else {\\n                animationPrefilters.push(callback);\\n            }\\n        }\\n    });\\n\\n    jQuery.speed = function (speed, easing, fn) {\\n        var opt = speed && (typeof speed === \"undefined\" ? \"undefined\" : _typeof(speed)) === \"object\" ? jQuery.extend({}, speed) : {\\n            complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,\\n            duration: speed,\\n            easing: fn && easing || easing && !jQuery.isFunction(easing) && easing\\n        };\\n\\n        opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === \"number\" ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;\\n\\n        // normalize opt.queue - true/undefined/null -> \"fx\"\\n        if (opt.queue == null || opt.queue === true) {\\n            opt.queue = \"fx\";\\n        }\\n\\n        // Queueing\\n        opt.old = opt.complete;\\n\\n        opt.complete = function () {\\n            if (jQuery.isFunction(opt.old)) {\\n                opt.old.call(this);\\n            }\\n\\n            if (opt.queue) {\\n                jQuery.dequeue(this, opt.queue);\\n            }\\n        };\\n\\n        return opt;\\n    };\\n\\n    jQuery.fn.extend({\\n        fadeTo: function fadeTo(speed, to, easing, callback) {\\n\\n            // show any hidden elements after setting opacity to 0\\n            return this.filter(isHidden).css(\"opacity\", 0).show()\\n\\n            // animate to the value specified\\n            .end().animate({ opacity: to }, speed, easing, callback);\\n        },\\n        animate: function animate(prop, speed, easing, callback) {\\n            var empty = jQuery.isEmptyObject(prop),\\n                optall = jQuery.speed(speed, easing, callback),\\n                doAnimation = function doAnimation() {\\n                // Operate on a copy of prop so per-property easing won\\'t be lost\\n                var anim = Animation(this, jQuery.extend({}, prop), optall);\\n\\n                // Empty animations, or finishing resolves immediately\\n                if (empty || data_priv.get(this, \"finish\")) {\\n                    anim.stop(true);\\n                }\\n            };\\n            doAnimation.finish = doAnimation;\\n\\n            return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);\\n        },\\n        stop: function stop(type, clearQueue, gotoEnd) {\\n            var stopQueue = function stopQueue(hooks) {\\n                var stop = hooks.stop;\\n                delete hooks.stop;\\n                stop(gotoEnd);\\n            };\\n\\n            if (typeof type !== \"string\") {\\n                gotoEnd = clearQueue;\\n                clearQueue = type;\\n                type = undefined;\\n            }\\n            if (clearQueue && type !== false) {\\n                this.queue(type || \"fx\", []);\\n            }\\n\\n            return this.each(function () {\\n                var dequeue = true,\\n                    index = type != null && type + \"queueHooks\",\\n                    timers = jQuery.timers,\\n                    data = data_priv.get(this);\\n\\n                if (index) {\\n                    if (data[index] && data[index].stop) {\\n                        stopQueue(data[index]);\\n                    }\\n                } else {\\n                    for (index in data) {\\n                        if (data[index] && data[index].stop && rrun.test(index)) {\\n                            stopQueue(data[index]);\\n                        }\\n                    }\\n                }\\n\\n                for (index = timers.length; index--;) {\\n                    if (timers[index].elem === this && (type == null || timers[index].queue === type)) {\\n                        timers[index].anim.stop(gotoEnd);\\n                        dequeue = false;\\n                        timers.splice(index, 1);\\n                    }\\n                }\\n\\n                // start the next in the queue if the last step wasn\\'t forced\\n                // timers currently will call their complete callbacks, which will dequeue\\n                // but only if they were gotoEnd\\n                if (dequeue || !gotoEnd) {\\n                    jQuery.dequeue(this, type);\\n                }\\n            });\\n        },\\n        finish: function finish(type) {\\n            if (type !== false) {\\n                type = type || \"fx\";\\n            }\\n            return this.each(function () {\\n                var index,\\n                    data = data_priv.get(this),\\n                    queue = data[type + \"queue\"],\\n                    hooks = data[type + \"queueHooks\"],\\n                    timers = jQuery.timers,\\n                    length = queue ? queue.length : 0;\\n\\n                // enable finishing flag on private data\\n                data.finish = true;\\n\\n                // empty the queue first\\n                jQuery.queue(this, type, []);\\n\\n                if (hooks && hooks.stop) {\\n                    hooks.stop.call(this, true);\\n                }\\n\\n                // look for any active animations, and finish them\\n                for (index = timers.length; index--;) {\\n                    if (timers[index].elem === this && timers[index].queue === type) {\\n                        timers[index].anim.stop(true);\\n                        timers.splice(index, 1);\\n                    }\\n                }\\n\\n                // look for any animations in the old queue and finish them\\n                for (index = 0; index < length; index++) {\\n                    if (queue[index] && queue[index].finish) {\\n                        queue[index].finish.call(this);\\n                    }\\n                }\\n\\n                // turn off finishing flag\\n                delete data.finish;\\n            });\\n        }\\n    });\\n\\n    jQuery.each([\"toggle\", \"show\", \"hide\"], function (i, name) {\\n        var cssFn = jQuery.fn[name];\\n        jQuery.fn[name] = function (speed, easing, callback) {\\n            return speed == null || typeof speed === \"boolean\" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);\\n        };\\n    });\\n\\n    // Generate shortcuts for custom animations\\n    jQuery.each({\\n        slideDown: genFx(\"show\"),\\n        slideUp: genFx(\"hide\"),\\n        slideToggle: genFx(\"toggle\"),\\n        fadeIn: { opacity: \"show\" },\\n        fadeOut: { opacity: \"hide\" },\\n        fadeToggle: { opacity: \"toggle\" }\\n    }, function (name, props) {\\n        jQuery.fn[name] = function (speed, easing, callback) {\\n            return this.animate(props, speed, easing, callback);\\n        };\\n    });\\n\\n    jQuery.timers = [];\\n    jQuery.fx.tick = function () {\\n        var timer,\\n            i = 0,\\n            timers = jQuery.timers;\\n\\n        fxNow = jQuery.now();\\n\\n        for (; i < timers.length; i++) {\\n            timer = timers[i];\\n            // Checks the timer has not already been removed\\n            if (!timer() && timers[i] === timer) {\\n                timers.splice(i--, 1);\\n            }\\n        }\\n\\n        if (!timers.length) {\\n            jQuery.fx.stop();\\n        }\\n        fxNow = undefined;\\n    };\\n\\n    jQuery.fx.timer = function (timer) {\\n        jQuery.timers.push(timer);\\n        if (timer()) {\\n            jQuery.fx.start();\\n        } else {\\n            jQuery.timers.pop();\\n        }\\n    };\\n\\n    jQuery.fx.interval = 13;\\n\\n    jQuery.fx.start = function () {\\n        if (!timerId) {\\n            timerId = setInterval(jQuery.fx.tick, jQuery.fx.interval);\\n        }\\n    };\\n\\n    jQuery.fx.stop = function () {\\n        clearInterval(timerId);\\n        timerId = null;\\n    };\\n\\n    jQuery.fx.speeds = {\\n        slow: 600,\\n        fast: 200,\\n        // Default speed\\n        _default: 400\\n    };\\n\\n    // Based off of the plugin by Clint Helfers, with permission.\\n    // http://blindsignals.com/index.php/2009/07/jquery-delay/\\n    jQuery.fn.delay = function (time, type) {\\n        time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;\\n        type = type || \"fx\";\\n\\n        return this.queue(type, function (next, hooks) {\\n            var timeout = setTimeout(next, time);\\n            hooks.stop = function () {\\n                clearTimeout(timeout);\\n            };\\n        });\\n    };\\n\\n    (function () {\\n        var input = document.createElement(\"input\"),\\n            select = document.createElement(\"select\"),\\n            opt = select.appendChild(document.createElement(\"option\"));\\n\\n        input.type = \"checkbox\";\\n\\n        // Support: iOS 5.1, Android 4.x, Android 2.3\\n        // Check the default checkbox/radio value (\"\" on old WebKit; \"on\" elsewhere)\\n        support.checkOn = input.value !== \"\";\\n\\n        // Must access the parent to make an option select properly\\n        // Support: IE9, IE10\\n        support.optSelected = opt.selected;\\n\\n        // Make sure that the options inside disabled selects aren\\'t marked as disabled\\n        // (WebKit marks them as disabled)\\n        select.disabled = true;\\n        support.optDisabled = !opt.disabled;\\n\\n        // Check if an input maintains its value after becoming a radio\\n        // Support: IE9, IE10\\n        input = document.createElement(\"input\");\\n        input.value = \"t\";\\n        input.type = \"radio\";\\n        support.radioValue = input.value === \"t\";\\n    })();\\n\\n    var nodeHook,\\n        boolHook,\\n        attrHandle = jQuery.expr.attrHandle;\\n\\n    jQuery.fn.extend({\\n        attr: function attr(name, value) {\\n            return access(this, jQuery.attr, name, value, arguments.length > 1);\\n        },\\n\\n        removeAttr: function removeAttr(name) {\\n            return this.each(function () {\\n                jQuery.removeAttr(this, name);\\n            });\\n        }\\n    });\\n\\n    jQuery.extend({\\n        attr: function attr(elem, name, value) {\\n            var hooks,\\n                ret,\\n                nType = elem.nodeType;\\n\\n            // don\\'t get/set attributes on text, comment and attribute nodes\\n            if (!elem || nType === 3 || nType === 8 || nType === 2) {\\n                return;\\n            }\\n\\n            // Fallback to prop when attributes are not supported\\n            if (_typeof(elem.getAttribute) === strundefined) {\\n                return jQuery.prop(elem, name, value);\\n            }\\n\\n            // All attributes are lowercase\\n            // Grab necessary hook if one is defined\\n            if (nType !== 1 || !jQuery.isXMLDoc(elem)) {\\n                name = name.toLowerCase();\\n                hooks = jQuery.attrHooks[name] || (jQuery.expr.match.bool.test(name) ? boolHook : nodeHook);\\n            }\\n\\n            if (value !== undefined) {\\n\\n                if (value === null) {\\n                    jQuery.removeAttr(elem, name);\\n                } else if (hooks && \"set\" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {\\n                    return ret;\\n                } else {\\n                    elem.setAttribute(name, value + \"\");\\n                    return value;\\n                }\\n            } else if (hooks && \"get\" in hooks && (ret = hooks.get(elem, name)) !== null) {\\n                return ret;\\n            } else {\\n                ret = jQuery.find.attr(elem, name);\\n\\n                // Non-existent attributes return null, we normalize to undefined\\n                return ret == null ? undefined : ret;\\n            }\\n        },\\n\\n        removeAttr: function removeAttr(elem, value) {\\n            var name,\\n                propName,\\n                i = 0,\\n                attrNames = value && value.match(rnotwhite);\\n\\n            if (attrNames && elem.nodeType === 1) {\\n                while (name = attrNames[i++]) {\\n                    propName = jQuery.propFix[name] || name;\\n\\n                    // Boolean attributes get special treatment (#10870)\\n                    if (jQuery.expr.match.bool.test(name)) {\\n                        // Set corresponding property to false\\n                        elem[propName] = false;\\n                    }\\n\\n                    elem.removeAttribute(name);\\n                }\\n            }\\n        },\\n\\n        attrHooks: {\\n            type: {\\n                set: function set(elem, value) {\\n                    if (!support.radioValue && value === \"radio\" && jQuery.nodeName(elem, \"input\")) {\\n                        // Setting the type on a radio button after the value resets the value in IE6-9\\n                        // Reset value to default in case type is set after value during creation\\n                        var val = elem.value;\\n                        elem.setAttribute(\"type\", value);\\n                        if (val) {\\n                            elem.value = val;\\n                        }\\n                        return value;\\n                    }\\n                }\\n            }\\n        }\\n    });\\n\\n    // Hooks for boolean attributes\\n    boolHook = {\\n        set: function set(elem, value, name) {\\n            if (value === false) {\\n                // Remove boolean attributes when set to false\\n                jQuery.removeAttr(elem, name);\\n            } else {\\n                elem.setAttribute(name, name);\\n            }\\n            return name;\\n        }\\n    };\\n    jQuery.each(jQuery.expr.match.bool.source.match(/\\\\w+/g), function (i, name) {\\n        var getter = attrHandle[name] || jQuery.find.attr;\\n\\n        attrHandle[name] = function (elem, name, isXML) {\\n            var ret, handle;\\n            if (!isXML) {\\n                // Avoid an infinite loop by temporarily removing this function from the getter\\n                handle = attrHandle[name];\\n                attrHandle[name] = ret;\\n                ret = getter(elem, name, isXML) != null ? name.toLowerCase() : null;\\n                attrHandle[name] = handle;\\n            }\\n            return ret;\\n        };\\n    });\\n\\n    var rfocusable = /^(?:input|select|textarea|button)$/i;\\n\\n    jQuery.fn.extend({\\n        prop: function prop(name, value) {\\n            return access(this, jQuery.prop, name, value, arguments.length > 1);\\n        },\\n\\n        removeProp: function removeProp(name) {\\n            return this.each(function () {\\n                delete this[jQuery.propFix[name] || name];\\n            });\\n        }\\n    });\\n\\n    jQuery.extend({\\n        propFix: {\\n            \"for\": \"htmlFor\",\\n            \"class\": \"className\"\\n        },\\n\\n        prop: function prop(elem, name, value) {\\n            var ret,\\n                hooks,\\n                notxml,\\n                nType = elem.nodeType;\\n\\n            // don\\'t get/set properties on text, comment and attribute nodes\\n            if (!elem || nType === 3 || nType === 8 || nType === 2) {\\n                return;\\n            }\\n\\n            notxml = nType !== 1 || !jQuery.isXMLDoc(elem);\\n\\n            if (notxml) {\\n                // Fix name and attach hooks\\n                name = jQuery.propFix[name] || name;\\n                hooks = jQuery.propHooks[name];\\n            }\\n\\n            if (value !== undefined) {\\n                return hooks && \"set\" in hooks && (ret = hooks.set(elem, value, name)) !== undefined ? ret : elem[name] = value;\\n            } else {\\n                return hooks && \"get\" in hooks && (ret = hooks.get(elem, name)) !== null ? ret : elem[name];\\n            }\\n        },\\n\\n        propHooks: {\\n            tabIndex: {\\n                get: function get(elem) {\\n                    return elem.hasAttribute(\"tabindex\") || rfocusable.test(elem.nodeName) || elem.href ? elem.tabIndex : -1;\\n                }\\n            }\\n        }\\n    });\\n\\n    // Support: IE9+\\n    // Selectedness for an option in an optgroup can be inaccurate\\n    if (!support.optSelected) {\\n        jQuery.propHooks.selected = {\\n            get: function get(elem) {\\n                var parent = elem.parentNode;\\n                if (parent && parent.parentNode) {\\n                    parent.parentNode.selectedIndex;\\n                }\\n                return null;\\n            }\\n        };\\n    }\\n\\n    jQuery.each([\"tabIndex\", \"readOnly\", \"maxLength\", \"cellSpacing\", \"cellPadding\", \"rowSpan\", \"colSpan\", \"useMap\", \"frameBorder\", \"contentEditable\"], function () {\\n        jQuery.propFix[this.toLowerCase()] = this;\\n    });\\n\\n    var rclass = /[\\\\t\\\\r\\\\n\\\\f]/g;\\n\\n    jQuery.fn.extend({\\n        addClass: function addClass(value) {\\n            var classes,\\n                elem,\\n                cur,\\n                clazz,\\n                j,\\n                finalValue,\\n                proceed = typeof value === \"string\" && value,\\n                i = 0,\\n                len = this.length;\\n\\n            if (jQuery.isFunction(value)) {\\n                return this.each(function (j) {\\n                    jQuery(this).addClass(value.call(this, j, this.className));\\n                });\\n            }\\n\\n            if (proceed) {\\n                // The disjunction here is for better compressibility (see removeClass)\\n                classes = (value || \"\").match(rnotwhite) || [];\\n\\n                for (; i < len; i++) {\\n                    elem = this[i];\\n                    cur = elem.nodeType === 1 && (elem.className ? (\" \" + elem.className + \" \").replace(rclass, \" \") : \" \");\\n\\n                    if (cur) {\\n                        j = 0;\\n                        while (clazz = classes[j++]) {\\n                            if (cur.indexOf(\" \" + clazz + \" \") < 0) {\\n                                cur += clazz + \" \";\\n                            }\\n                        }\\n\\n                        // only assign if different to avoid unneeded rendering.\\n                        finalValue = jQuery.trim(cur);\\n                        if (elem.className !== finalValue) {\\n                            elem.className = finalValue;\\n                        }\\n                    }\\n                }\\n            }\\n\\n            return this;\\n        },\\n\\n        removeClass: function removeClass(value) {\\n            var classes,\\n                elem,\\n                cur,\\n                clazz,\\n                j,\\n                finalValue,\\n                proceed = arguments.length === 0 || typeof value === \"string\" && value,\\n                i = 0,\\n                len = this.length;\\n\\n            if (jQuery.isFunction(value)) {\\n                return this.each(function (j) {\\n                    jQuery(this).removeClass(value.call(this, j, this.className));\\n                });\\n            }\\n            if (proceed) {\\n                classes = (value || \"\").match(rnotwhite) || [];\\n\\n                for (; i < len; i++) {\\n                    elem = this[i];\\n                    // This expression is here for better compressibility (see addClass)\\n                    cur = elem.nodeType === 1 && (elem.className ? (\" \" + elem.className + \" \").replace(rclass, \" \") : \"\");\\n\\n                    if (cur) {\\n                        j = 0;\\n                        while (clazz = classes[j++]) {\\n                            // Remove *all* instances\\n                            while (cur.indexOf(\" \" + clazz + \" \") >= 0) {\\n                                cur = cur.replace(\" \" + clazz + \" \", \" \");\\n                            }\\n                        }\\n\\n                        // only assign if different to avoid unneeded rendering.\\n                        finalValue = value ? jQuery.trim(cur) : \"\";\\n                        if (elem.className !== finalValue) {\\n                            elem.className = finalValue;\\n                        }\\n                    }\\n                }\\n            }\\n\\n            return this;\\n        },\\n\\n        toggleClass: function toggleClass(value, stateVal) {\\n            var type = typeof value === \"undefined\" ? \"undefined\" : _typeof(value);\\n\\n            if (typeof stateVal === \"boolean\" && type === \"string\") {\\n                return stateVal ? this.addClass(value) : this.removeClass(value);\\n            }\\n\\n            if (jQuery.isFunction(value)) {\\n                return this.each(function (i) {\\n                    jQuery(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal);\\n                });\\n            }\\n\\n            return this.each(function () {\\n                if (type === \"string\") {\\n                    // toggle individual class names\\n                    var className,\\n                        i = 0,\\n                        self = jQuery(this),\\n                        classNames = value.match(rnotwhite) || [];\\n\\n                    while (className = classNames[i++]) {\\n                        // check each className given, space separated list\\n                        if (self.hasClass(className)) {\\n                            self.removeClass(className);\\n                        } else {\\n                            self.addClass(className);\\n                        }\\n                    }\\n\\n                    // Toggle whole class name\\n                } else if (type === strundefined || type === \"boolean\") {\\n                    if (this.className) {\\n                        // store className if set\\n                        data_priv.set(this, \"__className__\", this.className);\\n                    }\\n\\n                    // If the element has a class name or if we\\'re passed \"false\",\\n                    // then remove the whole classname (if there was one, the above saved it).\\n                    // Otherwise bring back whatever was previously saved (if anything),\\n                    // falling back to the empty string if nothing was stored.\\n                    this.className = this.className || value === false ? \"\" : data_priv.get(this, \"__className__\") || \"\";\\n                }\\n            });\\n        },\\n\\n        hasClass: function hasClass(selector) {\\n            var className = \" \" + selector + \" \",\\n                i = 0,\\n                l = this.length;\\n            for (; i < l; i++) {\\n                if (this[i].nodeType === 1 && (\" \" + this[i].className + \" \").replace(rclass, \" \").indexOf(className) >= 0) {\\n                    return true;\\n                }\\n            }\\n\\n            return false;\\n        }\\n    });\\n\\n    var rreturn = /\\\\r/g;\\n\\n    jQuery.fn.extend({\\n        val: function val(value) {\\n            var hooks,\\n                ret,\\n                isFunction,\\n                elem = this[0];\\n\\n            if (!arguments.length) {\\n                if (elem) {\\n                    hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];\\n\\n                    if (hooks && \"get\" in hooks && (ret = hooks.get(elem, \"value\")) !== undefined) {\\n                        return ret;\\n                    }\\n\\n                    ret = elem.value;\\n\\n                    return typeof ret === \"string\" ?\\n                    // handle most common string cases\\n                    ret.replace(rreturn, \"\") :\\n                    // handle cases where value is null/undef or number\\n                    ret == null ? \"\" : ret;\\n                }\\n\\n                return;\\n            }\\n\\n            isFunction = jQuery.isFunction(value);\\n\\n            return this.each(function (i) {\\n                var val;\\n\\n                if (this.nodeType !== 1) {\\n                    return;\\n                }\\n\\n                if (isFunction) {\\n                    val = value.call(this, i, jQuery(this).val());\\n                } else {\\n                    val = value;\\n                }\\n\\n                // Treat null/undefined as \"\"; convert numbers to string\\n                if (val == null) {\\n                    val = \"\";\\n                } else if (typeof val === \"number\") {\\n                    val += \"\";\\n                } else if (jQuery.isArray(val)) {\\n                    val = jQuery.map(val, function (value) {\\n                        return value == null ? \"\" : value + \"\";\\n                    });\\n                }\\n\\n                hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];\\n\\n                // If set returns undefined, fall back to normal setting\\n                if (!hooks || !(\"set\" in hooks) || hooks.set(this, val, \"value\") === undefined) {\\n                    this.value = val;\\n                }\\n            });\\n        }\\n    });\\n\\n    jQuery.extend({\\n        valHooks: {\\n            option: {\\n                get: function get(elem) {\\n                    var val = jQuery.find.attr(elem, \"value\");\\n                    return val != null ? val :\\n                    // Support: IE10-11+\\n                    // option.text throws exceptions (#14686, #14858)\\n                    jQuery.trim(jQuery.text(elem));\\n                }\\n            },\\n            select: {\\n                get: function get(elem) {\\n                    var value,\\n                        option,\\n                        options = elem.options,\\n                        index = elem.selectedIndex,\\n                        one = elem.type === \"select-one\" || index < 0,\\n                        values = one ? null : [],\\n                        max = one ? index + 1 : options.length,\\n                        i = index < 0 ? max : one ? index : 0;\\n\\n                    // Loop through all the selected options\\n                    for (; i < max; i++) {\\n                        option = options[i];\\n\\n                        // IE6-9 doesn\\'t update selected after form reset (#2551)\\n                        if ((option.selected || i === index) && (\\n                        // Don\\'t return options that are disabled or in a disabled optgroup\\n                        support.optDisabled ? !option.disabled : option.getAttribute(\"disabled\") === null) && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, \"optgroup\"))) {\\n\\n                            // Get the specific value for the option\\n                            value = jQuery(option).val();\\n\\n                            // We don\\'t need an array for one selects\\n                            if (one) {\\n                                return value;\\n                            }\\n\\n                            // Multi-Selects return an array\\n                            values.push(value);\\n                        }\\n                    }\\n\\n                    return values;\\n                },\\n\\n                set: function set(elem, value) {\\n                    var optionSet,\\n                        option,\\n                        options = elem.options,\\n                        values = jQuery.makeArray(value),\\n                        i = options.length;\\n\\n                    while (i--) {\\n                        option = options[i];\\n                        if (option.selected = jQuery.inArray(option.value, values) >= 0) {\\n                            optionSet = true;\\n                        }\\n                    }\\n\\n                    // force browsers to behave consistently when non-matching value is set\\n                    if (!optionSet) {\\n                        elem.selectedIndex = -1;\\n                    }\\n                    return values;\\n                }\\n            }\\n        }\\n    });\\n\\n    // Radios and checkboxes getter/setter\\n    jQuery.each([\"radio\", \"checkbox\"], function () {\\n        jQuery.valHooks[this] = {\\n            set: function set(elem, value) {\\n                if (jQuery.isArray(value)) {\\n                    return elem.checked = jQuery.inArray(jQuery(elem).val(), value) >= 0;\\n                }\\n            }\\n        };\\n        if (!support.checkOn) {\\n            jQuery.valHooks[this].get = function (elem) {\\n                // Support: Webkit\\n                // \"\" is returned instead of \"on\" if a value isn\\'t specified\\n                return elem.getAttribute(\"value\") === null ? \"on\" : elem.value;\\n            };\\n        }\\n    });\\n\\n    // Return jQuery for attributes-only inclusion\\n\\n\\n    jQuery.each((\"blur focus focusin focusout load resize scroll unload click dblclick \" + \"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" + \"change select submit keydown keypress keyup error contextmenu\").split(\" \"), function (i, name) {\\n\\n        // Handle event binding\\n        jQuery.fn[name] = function (data, fn) {\\n            return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);\\n        };\\n    });\\n\\n    jQuery.fn.extend({\\n        hover: function hover(fnOver, fnOut) {\\n            return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);\\n        },\\n\\n        bind: function bind(types, data, fn) {\\n            return this.on(types, null, data, fn);\\n        },\\n        unbind: function unbind(types, fn) {\\n            return this.off(types, null, fn);\\n        },\\n\\n        delegate: function delegate(selector, types, data, fn) {\\n            return this.on(types, selector, data, fn);\\n        },\\n        undelegate: function undelegate(selector, types, fn) {\\n            // ( namespace ) or ( selector, types [, fn] )\\n            return arguments.length === 1 ? this.off(selector, \"**\") : this.off(types, selector || \"**\", fn);\\n        }\\n    });\\n\\n    var nonce = jQuery.now();\\n\\n    var rquery = /\\\\?/;\\n\\n    // Support: Android 2.3\\n    // Workaround failure to string-cast null input\\n    jQuery.parseJSON = function (data) {\\n        return JSON.parse(data + \"\");\\n    };\\n\\n    // Cross-browser xml parsing\\n    jQuery.parseXML = function (data) {\\n        var xml, tmp;\\n        if (!data || typeof data !== \"string\") {\\n            return null;\\n        }\\n\\n        // Support: IE9\\n        try {\\n            tmp = new DOMParser();\\n            xml = tmp.parseFromString(data, \"text/xml\");\\n        } catch (e) {\\n            xml = undefined;\\n        }\\n\\n        if (!xml || xml.getElementsByTagName(\"parsererror\").length) {\\n            jQuery.error(\"Invalid XML: \" + data);\\n        }\\n        return xml;\\n    };\\n\\n    var\\n    // Document location\\n    ajaxLocParts,\\n        ajaxLocation,\\n        rhash = /#.*$/,\\n        rts = /([?&])_=[^&]*/,\\n        rheaders = /^(.*?):[ \\\\t]*([^\\\\r\\\\n]*)$/mg,\\n\\n    // #7653, #8125, #8152: local protocol detection\\n    rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\\n        rnoContent = /^(?:GET|HEAD)$/,\\n        rprotocol = /^\\\\/\\\\//,\\n        rurl = /^([\\\\w.+-]+:)(?:\\\\/\\\\/(?:[^\\\\/?#]*@|)([^\\\\/?#:]*)(?::(\\\\d+)|)|)/,\\n\\n\\n    /* Prefilters\\r\\n     * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\\r\\n     * 2) These are called:\\r\\n     *    - BEFORE asking for a transport\\r\\n     *    - AFTER param serialization (s.data is a string if s.processData is true)\\r\\n     * 3) key is the dataType\\r\\n     * 4) the catchall symbol \"*\" can be used\\r\\n     * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\\r\\n     */\\n    prefilters = {},\\n\\n\\n    /* Transports bindings\\r\\n     * 1) key is the dataType\\r\\n     * 2) the catchall symbol \"*\" can be used\\r\\n     * 3) selection will start with transport dataType and THEN go to \"*\" if needed\\r\\n     */\\n    transports = {},\\n\\n\\n    // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\\n    allTypes = \"*/\".concat(\"*\");\\n\\n    // #8138, IE may throw an exception when accessing\\n    // a field from window.location if document.domain has been set\\n    try {\\n        ajaxLocation = location.href;\\n    } catch (e) {\\n        // Use the href attribute of an A element\\n        // since IE will modify it given document.location\\n        ajaxLocation = document.createElement(\"a\");\\n        ajaxLocation.href = \"\";\\n        ajaxLocation = ajaxLocation.href;\\n    }\\n\\n    // Segment location into parts\\n    ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [];\\n\\n    // Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\\n    function addToPrefiltersOrTransports(structure) {\\n\\n        // dataTypeExpression is optional and defaults to \"*\"\\n        return function (dataTypeExpression, func) {\\n\\n            if (typeof dataTypeExpression !== \"string\") {\\n                func = dataTypeExpression;\\n                dataTypeExpression = \"*\";\\n            }\\n\\n            var dataType,\\n                i = 0,\\n                dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];\\n\\n            if (jQuery.isFunction(func)) {\\n                // For each dataType in the dataTypeExpression\\n                while (dataType = dataTypes[i++]) {\\n                    // Prepend if requested\\n                    if (dataType[0] === \"+\") {\\n                        dataType = dataType.slice(1) || \"*\";\\n                        (structure[dataType] = structure[dataType] || []).unshift(func);\\n\\n                        // Otherwise append\\n                    } else {\\n                        (structure[dataType] = structure[dataType] || []).push(func);\\n                    }\\n                }\\n            }\\n        };\\n    }\\n\\n    // Base inspection function for prefilters and transports\\n    function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {\\n\\n        var inspected = {},\\n            seekingTransport = structure === transports;\\n\\n        function inspect(dataType) {\\n            var selected;\\n            inspected[dataType] = true;\\n            jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {\\n                var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);\\n                if (typeof dataTypeOrTransport === \"string\" && !seekingTransport && !inspected[dataTypeOrTransport]) {\\n                    options.dataTypes.unshift(dataTypeOrTransport);\\n                    inspect(dataTypeOrTransport);\\n                    return false;\\n                } else if (seekingTransport) {\\n                    return !(selected = dataTypeOrTransport);\\n                }\\n            });\\n            return selected;\\n        }\\n\\n        return inspect(options.dataTypes[0]) || !inspected[\"*\"] && inspect(\"*\");\\n    }\\n\\n    // A special extend for ajax options\\n    // that takes \"flat\" options (not to be deep extended)\\n    // Fixes #9887\\n    function ajaxExtend(target, src) {\\n        var key,\\n            deep,\\n            flatOptions = jQuery.ajaxSettings.flatOptions || {};\\n\\n        for (key in src) {\\n            if (src[key] !== undefined) {\\n                (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];\\n            }\\n        }\\n        if (deep) {\\n            jQuery.extend(true, target, deep);\\n        }\\n\\n        return target;\\n    }\\n\\n    /* Handles responses to an ajax request:\\r\\n     * - finds the right dataType (mediates between content-type and expected dataType)\\r\\n     * - returns the corresponding response\\r\\n     */\\n    function ajaxHandleResponses(s, jqXHR, responses) {\\n\\n        var ct,\\n            type,\\n            finalDataType,\\n            firstDataType,\\n            contents = s.contents,\\n            dataTypes = s.dataTypes;\\n\\n        // Remove auto dataType and get content-type in the process\\n        while (dataTypes[0] === \"*\") {\\n            dataTypes.shift();\\n            if (ct === undefined) {\\n                ct = s.mimeType || jqXHR.getResponseHeader(\"Content-Type\");\\n            }\\n        }\\n\\n        // Check if we\\'re dealing with a known content-type\\n        if (ct) {\\n            for (type in contents) {\\n                if (contents[type] && contents[type].test(ct)) {\\n                    dataTypes.unshift(type);\\n                    break;\\n                }\\n            }\\n        }\\n\\n        // Check to see if we have a response for the expected dataType\\n        if (dataTypes[0] in responses) {\\n            finalDataType = dataTypes[0];\\n        } else {\\n            // Try convertible dataTypes\\n            for (type in responses) {\\n                if (!dataTypes[0] || s.converters[type + \" \" + dataTypes[0]]) {\\n                    finalDataType = type;\\n                    break;\\n                }\\n                if (!firstDataType) {\\n                    firstDataType = type;\\n                }\\n            }\\n            // Or just use first one\\n            finalDataType = finalDataType || firstDataType;\\n        }\\n\\n        // If we found a dataType\\n        // We add the dataType to the list if needed\\n        // and return the corresponding response\\n        if (finalDataType) {\\n            if (finalDataType !== dataTypes[0]) {\\n                dataTypes.unshift(finalDataType);\\n            }\\n            return responses[finalDataType];\\n        }\\n    }\\n\\n    /* Chain conversions given the request and the original response\\r\\n     * Also sets the responseXXX fields on the jqXHR instance\\r\\n     */\\n    function ajaxConvert(s, response, jqXHR, isSuccess) {\\n        var conv2,\\n            current,\\n            conv,\\n            tmp,\\n            prev,\\n            converters = {},\\n\\n        // Work with a copy of dataTypes in case we need to modify it for conversion\\n        dataTypes = s.dataTypes.slice();\\n\\n        // Create converters map with lowercased keys\\n        if (dataTypes[1]) {\\n            for (conv in s.converters) {\\n                converters[conv.toLowerCase()] = s.converters[conv];\\n            }\\n        }\\n\\n        current = dataTypes.shift();\\n\\n        // Convert to each sequential dataType\\n        while (current) {\\n\\n            if (s.responseFields[current]) {\\n                jqXHR[s.responseFields[current]] = response;\\n            }\\n\\n            // Apply the dataFilter if provided\\n            if (!prev && isSuccess && s.dataFilter) {\\n                response = s.dataFilter(response, s.dataType);\\n            }\\n\\n            prev = current;\\n            current = dataTypes.shift();\\n\\n            if (current) {\\n\\n                // There\\'s only work to do if current dataType is non-auto\\n                if (current === \"*\") {\\n\\n                    current = prev;\\n\\n                    // Convert response if prev dataType is non-auto and differs from current\\n                } else if (prev !== \"*\" && prev !== current) {\\n\\n                    // Seek a direct converter\\n                    conv = converters[prev + \" \" + current] || converters[\"* \" + current];\\n\\n                    // If none found, seek a pair\\n                    if (!conv) {\\n                        for (conv2 in converters) {\\n\\n                            // If conv2 outputs current\\n                            tmp = conv2.split(\" \");\\n                            if (tmp[1] === current) {\\n\\n                                // If prev can be converted to accepted input\\n                                conv = converters[prev + \" \" + tmp[0]] || converters[\"* \" + tmp[0]];\\n                                if (conv) {\\n                                    // Condense equivalence converters\\n                                    if (conv === true) {\\n                                        conv = converters[conv2];\\n\\n                                        // Otherwise, insert the intermediate dataType\\n                                    } else if (converters[conv2] !== true) {\\n                                        current = tmp[0];\\n                                        dataTypes.unshift(tmp[1]);\\n                                    }\\n                                    break;\\n                                }\\n                            }\\n                        }\\n                    }\\n\\n                    // Apply converter (if not an equivalence)\\n                    if (conv !== true) {\\n\\n                        // Unless errors are allowed to bubble, catch and return them\\n                        if (conv && s[\"throws\"]) {\\n                            response = conv(response);\\n                        } else {\\n                            try {\\n                                response = conv(response);\\n                            } catch (e) {\\n                                return { state: \"parsererror\", error: conv ? e : \"No conversion from \" + prev + \" to \" + current };\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return { state: \"success\", data: response };\\n    }\\n\\n    jQuery.extend({\\n\\n        // Counter for holding the number of active queries\\n        active: 0,\\n\\n        // Last-Modified header cache for next request\\n        lastModified: {},\\n        etag: {},\\n\\n        ajaxSettings: {\\n            url: ajaxLocation,\\n            type: \"GET\",\\n            isLocal: rlocalProtocol.test(ajaxLocParts[1]),\\n            global: true,\\n            processData: true,\\n            async: true,\\n            contentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\\n            /*\\r\\n            timeout: 0,\\r\\n            data: null,\\r\\n            dataType: null,\\r\\n            username: null,\\r\\n            password: null,\\r\\n            cache: null,\\r\\n            throws: false,\\r\\n            traditional: false,\\r\\n            headers: {},\\r\\n            */\\n\\n            accepts: {\\n                \"*\": allTypes,\\n                text: \"text/plain\",\\n                html: \"text/html\",\\n                xml: \"application/xml, text/xml\",\\n                json: \"application/json, text/javascript\"\\n            },\\n\\n            contents: {\\n                xml: /xml/,\\n                html: /html/,\\n                json: /json/\\n            },\\n\\n            responseFields: {\\n                xml: \"responseXML\",\\n                text: \"responseText\",\\n                json: \"responseJSON\"\\n            },\\n\\n            // Data converters\\n            // Keys separate source (or catchall \"*\") and destination types with a single space\\n            converters: {\\n\\n                // Convert anything to text\\n                \"* text\": String,\\n\\n                // Text to html (true = no transformation)\\n                \"text html\": true,\\n\\n                // Evaluate text as a json expression\\n                \"text json\": jQuery.parseJSON,\\n\\n                // Parse text as xml\\n                \"text xml\": jQuery.parseXML\\n            },\\n\\n            // For options that shouldn\\'t be deep extended:\\n            // you can add your own custom options here if\\n            // and when you create one that shouldn\\'t be\\n            // deep extended (see ajaxExtend)\\n            flatOptions: {\\n                url: true,\\n                context: true\\n            }\\n        },\\n\\n        // Creates a full fledged settings object into target\\n        // with both ajaxSettings and settings fields.\\n        // If target is omitted, writes into ajaxSettings.\\n        ajaxSetup: function ajaxSetup(target, settings) {\\n            return settings ?\\n\\n            // Building a settings object\\n            ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) :\\n\\n            // Extending ajaxSettings\\n            ajaxExtend(jQuery.ajaxSettings, target);\\n        },\\n\\n        ajaxPrefilter: addToPrefiltersOrTransports(prefilters),\\n        ajaxTransport: addToPrefiltersOrTransports(transports),\\n\\n        // Main method\\n        ajax: function ajax(url, options) {\\n\\n            // If url is an object, simulate pre-1.5 signature\\n            if ((typeof url === \"undefined\" ? \"undefined\" : _typeof(url)) === \"object\") {\\n                options = url;\\n                url = undefined;\\n            }\\n\\n            // Force options to be an object\\n            options = options || {};\\n\\n            var transport,\\n\\n            // URL without anti-cache param\\n            cacheURL,\\n\\n            // Response headers\\n            responseHeadersString,\\n                responseHeaders,\\n\\n            // timeout handle\\n            timeoutTimer,\\n\\n            // Cross-domain detection vars\\n            parts,\\n\\n            // To know if global events are to be dispatched\\n            fireGlobals,\\n\\n            // Loop variable\\n            i,\\n\\n            // Create the final options object\\n            s = jQuery.ajaxSetup({}, options),\\n\\n            // Callbacks context\\n            callbackContext = s.context || s,\\n\\n            // Context for global events is callbackContext if it is a DOM node or jQuery collection\\n            globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,\\n\\n            // Deferreds\\n            deferred = jQuery.Deferred(),\\n                completeDeferred = jQuery.Callbacks(\"once memory\"),\\n\\n            // Status-dependent callbacks\\n            _statusCode = s.statusCode || {},\\n\\n            // Headers (they are sent all at once)\\n            requestHeaders = {},\\n                requestHeadersNames = {},\\n\\n            // The jqXHR state\\n            state = 0,\\n\\n            // Default abort message\\n            strAbort = \"canceled\",\\n\\n            // Fake xhr\\n            jqXHR = {\\n                readyState: 0,\\n\\n                // Builds headers hashtable if needed\\n                getResponseHeader: function getResponseHeader(key) {\\n                    var match;\\n                    if (state === 2) {\\n                        if (!responseHeaders) {\\n                            responseHeaders = {};\\n                            while (match = rheaders.exec(responseHeadersString)) {\\n                                responseHeaders[match[1].toLowerCase()] = match[2];\\n                            }\\n                        }\\n                        match = responseHeaders[key.toLowerCase()];\\n                    }\\n                    return match == null ? null : match;\\n                },\\n\\n                // Raw string\\n                getAllResponseHeaders: function getAllResponseHeaders() {\\n                    return state === 2 ? responseHeadersString : null;\\n                },\\n\\n                // Caches the header\\n                setRequestHeader: function setRequestHeader(name, value) {\\n                    var lname = name.toLowerCase();\\n                    if (!state) {\\n                        name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;\\n                        requestHeaders[name] = value;\\n                    }\\n                    return this;\\n                },\\n\\n                // Overrides response content-type header\\n                overrideMimeType: function overrideMimeType(type) {\\n                    if (!state) {\\n                        s.mimeType = type;\\n                    }\\n                    return this;\\n                },\\n\\n                // Status-dependent callbacks\\n                statusCode: function statusCode(map) {\\n                    var code;\\n                    if (map) {\\n                        if (state < 2) {\\n                            for (code in map) {\\n                                // Lazy-add the new callback in a way that preserves old ones\\n                                _statusCode[code] = [_statusCode[code], map[code]];\\n                            }\\n                        } else {\\n                            // Execute the appropriate callbacks\\n                            jqXHR.always(map[jqXHR.status]);\\n                        }\\n                    }\\n                    return this;\\n                },\\n\\n                // Cancel the request\\n                abort: function abort(statusText) {\\n                    var finalText = statusText || strAbort;\\n                    if (transport) {\\n                        transport.abort(finalText);\\n                    }\\n                    done(0, finalText);\\n                    return this;\\n                }\\n            };\\n\\n            // Attach deferreds\\n            deferred.promise(jqXHR).complete = completeDeferred.add;\\n            jqXHR.success = jqXHR.done;\\n            jqXHR.error = jqXHR.fail;\\n\\n            // Remove hash character (#7531: and string promotion)\\n            // Add protocol if not provided (prefilters might expect it)\\n            // Handle falsy url in the settings object (#10093: consistency with old signature)\\n            // We also use the url parameter if available\\n            s.url = ((url || s.url || ajaxLocation) + \"\").replace(rhash, \"\").replace(rprotocol, ajaxLocParts[1] + \"//\");\\n\\n            // Alias method option to type as per ticket #12004\\n            s.type = options.method || options.type || s.method || s.type;\\n\\n            // Extract dataTypes list\\n            s.dataTypes = jQuery.trim(s.dataType || \"*\").toLowerCase().match(rnotwhite) || [\"\"];\\n\\n            // A cross-domain request is in order when we have a protocol:host:port mismatch\\n            if (s.crossDomain == null) {\\n                parts = rurl.exec(s.url.toLowerCase());\\n                s.crossDomain = !!(parts && (parts[1] !== ajaxLocParts[1] || parts[2] !== ajaxLocParts[2] || (parts[3] || (parts[1] === \"http:\" ? \"80\" : \"443\")) !== (ajaxLocParts[3] || (ajaxLocParts[1] === \"http:\" ? \"80\" : \"443\"))));\\n            }\\n\\n            // Convert data if not already a string\\n            if (s.data && s.processData && typeof s.data !== \"string\") {\\n                s.data = jQuery.param(s.data, s.traditional);\\n            }\\n\\n            // Apply prefilters\\n            inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);\\n\\n            // If request was aborted inside a prefilter, stop there\\n            if (state === 2) {\\n                return jqXHR;\\n            }\\n\\n            // We can fire global events as of now if asked to\\n            fireGlobals = s.global;\\n\\n            // Watch for a new set of requests\\n            if (fireGlobals && jQuery.active++ === 0) {\\n                jQuery.event.trigger(\"ajaxStart\");\\n            }\\n\\n            // Uppercase the type\\n            s.type = s.type.toUpperCase();\\n\\n            // Determine if request has content\\n            s.hasContent = !rnoContent.test(s.type);\\n\\n            // Save the URL in case we\\'re toying with the If-Modified-Since\\n            // and/or If-None-Match header later on\\n            cacheURL = s.url;\\n\\n            // More options handling for requests with no content\\n            if (!s.hasContent) {\\n\\n                // If data is available, append data to url\\n                if (s.data) {\\n                    cacheURL = s.url += (rquery.test(cacheURL) ? \"&\" : \"?\") + s.data;\\n                    // #9682: remove data so that it\\'s not used in an eventual retry\\n                    delete s.data;\\n                }\\n\\n                // Add anti-cache in url if needed\\n                if (s.cache === false) {\\n                    s.url = rts.test(cacheURL) ?\\n\\n                    // If there is already a \\'_\\' parameter, set its value\\n                    cacheURL.replace(rts, \"$1_=\" + nonce++) :\\n\\n                    // Otherwise add one to the end\\n                    cacheURL + (rquery.test(cacheURL) ? \"&\" : \"?\") + \"_=\" + nonce++;\\n                }\\n            }\\n\\n            // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\\n            if (s.ifModified) {\\n                if (jQuery.lastModified[cacheURL]) {\\n                    jqXHR.setRequestHeader(\"If-Modified-Since\", jQuery.lastModified[cacheURL]);\\n                }\\n                if (jQuery.etag[cacheURL]) {\\n                    jqXHR.setRequestHeader(\"If-None-Match\", jQuery.etag[cacheURL]);\\n                }\\n            }\\n\\n            // Set the correct header, if data is being sent\\n            if (s.data && s.hasContent && s.contentType !== false || options.contentType) {\\n                jqXHR.setRequestHeader(\"Content-Type\", s.contentType);\\n            }\\n\\n            // Set the Accepts header for the server, depending on the dataType\\n            jqXHR.setRequestHeader(\"Accept\", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\") : s.accepts[\"*\"]);\\n\\n            // Check for headers option\\n            for (i in s.headers) {\\n                jqXHR.setRequestHeader(i, s.headers[i]);\\n            }\\n\\n            // Allow custom headers/mimetypes and early abort\\n            if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {\\n                // Abort if not done already and return\\n                return jqXHR.abort();\\n            }\\n\\n            // aborting is no longer a cancellation\\n            strAbort = \"abort\";\\n\\n            // Install callbacks on deferreds\\n            for (i in { success: 1, error: 1, complete: 1 }) {\\n                jqXHR[i](s[i]);\\n            }\\n\\n            // Get transport\\n            transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);\\n\\n            // If no transport, we auto-abort\\n            if (!transport) {\\n                done(-1, \"No Transport\");\\n            } else {\\n                jqXHR.readyState = 1;\\n\\n                // Send global event\\n                if (fireGlobals) {\\n                    globalEventContext.trigger(\"ajaxSend\", [jqXHR, s]);\\n                }\\n                // Timeout\\n                if (s.async && s.timeout > 0) {\\n                    timeoutTimer = setTimeout(function () {\\n                        jqXHR.abort(\"timeout\");\\n                    }, s.timeout);\\n                }\\n\\n                try {\\n                    state = 1;\\n                    transport.send(requestHeaders, done);\\n                } catch (e) {\\n                    // Propagate exception as error if not done\\n                    if (state < 2) {\\n                        done(-1, e);\\n                        // Simply rethrow otherwise\\n                    } else {\\n                        throw e;\\n                    }\\n                }\\n            }\\n\\n            // Callback for when everything is done\\n            function done(status, nativeStatusText, responses, headers) {\\n                var isSuccess,\\n                    success,\\n                    error,\\n                    response,\\n                    modified,\\n                    statusText = nativeStatusText;\\n\\n                // Called once\\n                if (state === 2) {\\n                    return;\\n                }\\n\\n                // State is \"done\" now\\n                state = 2;\\n\\n                // Clear timeout if it exists\\n                if (timeoutTimer) {\\n                    clearTimeout(timeoutTimer);\\n                }\\n\\n                // Dereference transport for early garbage collection\\n                // (no matter how long the jqXHR object will be used)\\n                transport = undefined;\\n\\n                // Cache response headers\\n                responseHeadersString = headers || \"\";\\n\\n                // Set readyState\\n                jqXHR.readyState = status > 0 ? 4 : 0;\\n\\n                // Determine if successful\\n                isSuccess = status >= 200 && status < 300 || status === 304;\\n\\n                // Get response data\\n                if (responses) {\\n                    response = ajaxHandleResponses(s, jqXHR, responses);\\n                }\\n\\n                // Convert no matter what (that way responseXXX fields are always set)\\n                response = ajaxConvert(s, response, jqXHR, isSuccess);\\n\\n                // If successful, handle type chaining\\n                if (isSuccess) {\\n\\n                    // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\\n                    if (s.ifModified) {\\n                        modified = jqXHR.getResponseHeader(\"Last-Modified\");\\n                        if (modified) {\\n                            jQuery.lastModified[cacheURL] = modified;\\n                        }\\n                        modified = jqXHR.getResponseHeader(\"etag\");\\n                        if (modified) {\\n                            jQuery.etag[cacheURL] = modified;\\n                        }\\n                    }\\n\\n                    // if no content\\n                    if (status === 204 || s.type === \"HEAD\") {\\n                        statusText = \"nocontent\";\\n\\n                        // if not modified\\n                    } else if (status === 304) {\\n                        statusText = \"notmodified\";\\n\\n                        // If we have data, let\\'s convert it\\n                    } else {\\n                        statusText = response.state;\\n                        success = response.data;\\n                        error = response.error;\\n                        isSuccess = !error;\\n                    }\\n                } else {\\n                    // We extract error from statusText\\n                    // then normalize statusText and status for non-aborts\\n                    error = statusText;\\n                    if (status || !statusText) {\\n                        statusText = \"error\";\\n                        if (status < 0) {\\n                            status = 0;\\n                        }\\n                    }\\n                }\\n\\n                // Set data for the fake xhr object\\n                jqXHR.status = status;\\n                jqXHR.statusText = (nativeStatusText || statusText) + \"\";\\n\\n                // Success/Error\\n                if (isSuccess) {\\n                    deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);\\n                } else {\\n                    deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);\\n                }\\n\\n                // Status-dependent callbacks\\n                jqXHR.statusCode(_statusCode);\\n                _statusCode = undefined;\\n\\n                if (fireGlobals) {\\n                    globalEventContext.trigger(isSuccess ? \"ajaxSuccess\" : \"ajaxError\", [jqXHR, s, isSuccess ? success : error]);\\n                }\\n\\n                // Complete\\n                completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);\\n\\n                if (fireGlobals) {\\n                    globalEventContext.trigger(\"ajaxComplete\", [jqXHR, s]);\\n                    // Handle the global AJAX counter\\n                    if (! --jQuery.active) {\\n                        jQuery.event.trigger(\"ajaxStop\");\\n                    }\\n                }\\n            }\\n\\n            return jqXHR;\\n        },\\n\\n        getJSON: function getJSON(url, data, callback) {\\n            return jQuery.get(url, data, callback, \"json\");\\n        },\\n\\n        getScript: function getScript(url, callback) {\\n            return jQuery.get(url, undefined, callback, \"script\");\\n        }\\n    });\\n\\n    jQuery.each([\"get\", \"post\"], function (i, method) {\\n        jQuery[method] = function (url, data, callback, type) {\\n            // shift arguments if data argument was omitted\\n            if (jQuery.isFunction(data)) {\\n                type = type || callback;\\n                callback = data;\\n                data = undefined;\\n            }\\n\\n            return jQuery.ajax({\\n                url: url,\\n                type: method,\\n                dataType: type,\\n                data: data,\\n                success: callback\\n            });\\n        };\\n    });\\n\\n    // Attach a bunch of functions for handling common AJAX events\\n    jQuery.each([\"ajaxStart\", \"ajaxStop\", \"ajaxComplete\", \"ajaxError\", \"ajaxSuccess\", \"ajaxSend\"], function (i, type) {\\n        jQuery.fn[type] = function (fn) {\\n            return this.on(type, fn);\\n        };\\n    });\\n\\n    jQuery._evalUrl = function (url) {\\n        return jQuery.ajax({\\n            url: url,\\n            type: \"GET\",\\n            dataType: \"script\",\\n            async: false,\\n            global: false,\\n            \"throws\": true\\n        });\\n    };\\n\\n    jQuery.fn.extend({\\n        wrapAll: function wrapAll(html) {\\n            var wrap;\\n\\n            if (jQuery.isFunction(html)) {\\n                return this.each(function (i) {\\n                    jQuery(this).wrapAll(html.call(this, i));\\n                });\\n            }\\n\\n            if (this[0]) {\\n\\n                // The elements to wrap the target around\\n                wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);\\n\\n                if (this[0].parentNode) {\\n                    wrap.insertBefore(this[0]);\\n                }\\n\\n                wrap.map(function () {\\n                    var elem = this;\\n\\n                    while (elem.firstElementChild) {\\n                        elem = elem.firstElementChild;\\n                    }\\n\\n                    return elem;\\n                }).append(this);\\n            }\\n\\n            return this;\\n        },\\n\\n        wrapInner: function wrapInner(html) {\\n            if (jQuery.isFunction(html)) {\\n                return this.each(function (i) {\\n                    jQuery(this).wrapInner(html.call(this, i));\\n                });\\n            }\\n\\n            return this.each(function () {\\n                var self = jQuery(this),\\n                    contents = self.contents();\\n\\n                if (contents.length) {\\n                    contents.wrapAll(html);\\n                } else {\\n                    self.append(html);\\n                }\\n            });\\n        },\\n\\n        wrap: function wrap(html) {\\n            var isFunction = jQuery.isFunction(html);\\n\\n            return this.each(function (i) {\\n                jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);\\n            });\\n        },\\n\\n        unwrap: function unwrap() {\\n            return this.parent().each(function () {\\n                if (!jQuery.nodeName(this, \"body\")) {\\n                    jQuery(this).replaceWith(this.childNodes);\\n                }\\n            }).end();\\n        }\\n    });\\n\\n    jQuery.expr.filters.hidden = function (elem) {\\n        // Support: Opera <= 12.12\\n        // Opera reports offsetWidths and offsetHeights less than zero on some elements\\n        return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;\\n    };\\n    jQuery.expr.filters.visible = function (elem) {\\n        return !jQuery.expr.filters.hidden(elem);\\n    };\\n\\n    var r20 = /%20/g,\\n        rbracket = /\\\\[\\\\]$/,\\n        rCRLF = /\\\\r?\\\\n/g,\\n        rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\\n        rsubmittable = /^(?:input|select|textarea|keygen)/i;\\n\\n    function buildParams(prefix, obj, traditional, add) {\\n        var name;\\n\\n        if (jQuery.isArray(obj)) {\\n            // Serialize array item.\\n            jQuery.each(obj, function (i, v) {\\n                if (traditional || rbracket.test(prefix)) {\\n                    // Treat each array item as a scalar.\\n                    add(prefix, v);\\n                } else {\\n                    // Item is non-scalar (array or object), encode its numeric index.\\n                    buildParams(prefix + \"[\" + ((typeof v === \"undefined\" ? \"undefined\" : _typeof(v)) === \"object\" ? i : \"\") + \"]\", v, traditional, add);\\n                }\\n            });\\n        } else if (!traditional && jQuery.type(obj) === \"object\") {\\n            // Serialize object item.\\n            for (name in obj) {\\n                buildParams(prefix + \"[\" + name + \"]\", obj[name], traditional, add);\\n            }\\n        } else {\\n            // Serialize scalar item.\\n            add(prefix, obj);\\n        }\\n    }\\n\\n    // Serialize an array of form elements or a set of\\n    // key/values into a query string\\n    jQuery.param = function (a, traditional) {\\n        var prefix,\\n            s = [],\\n            add = function add(key, value) {\\n            // If value is a function, invoke it and return its value\\n            value = jQuery.isFunction(value) ? value() : value == null ? \"\" : value;\\n            s[s.length] = encodeURIComponent(key) + \"=\" + encodeURIComponent(value);\\n        };\\n\\n        // Set traditional to true for jQuery <= 1.3.2 behavior.\\n        if (traditional === undefined) {\\n            traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;\\n        }\\n\\n        // If an array was passed in, assume that it is an array of form elements.\\n        if (jQuery.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {\\n            // Serialize the form elements\\n            jQuery.each(a, function () {\\n                add(this.name, this.value);\\n            });\\n        } else {\\n            // If traditional, encode the \"old\" way (the way 1.3.2 or older\\n            // did it), otherwise encode params recursively.\\n            for (prefix in a) {\\n                buildParams(prefix, a[prefix], traditional, add);\\n            }\\n        }\\n\\n        // Return the resulting serialization\\n        return s.join(\"&\").replace(r20, \"+\");\\n    };\\n\\n    jQuery.fn.extend({\\n        serialize: function serialize() {\\n            return jQuery.param(this.serializeArray());\\n        },\\n        serializeArray: function serializeArray() {\\n            return this.map(function () {\\n                // Can add propHook for \"elements\" to filter or add form elements\\n                var elements = jQuery.prop(this, \"elements\");\\n                return elements ? jQuery.makeArray(elements) : this;\\n            }).filter(function () {\\n                var type = this.type;\\n\\n                // Use .is( \":disabled\" ) so that fieldset[disabled] works\\n                return this.name && !jQuery(this).is(\":disabled\") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));\\n            }).map(function (i, elem) {\\n                var val = jQuery(this).val();\\n\\n                return val == null ? null : jQuery.isArray(val) ? jQuery.map(val, function (val) {\\n                    return { name: elem.name, value: val.replace(rCRLF, \"\\\\r\\\\n\") };\\n                }) : { name: elem.name, value: val.replace(rCRLF, \"\\\\r\\\\n\") };\\n            }).get();\\n        }\\n    });\\n\\n    jQuery.ajaxSettings.xhr = function () {\\n        try {\\n            return new XMLHttpRequest();\\n        } catch (e) {}\\n    };\\n\\n    var xhrId = 0,\\n        xhrCallbacks = {},\\n        xhrSuccessStatus = {\\n        // file protocol always yields status code 0, assume 200\\n        0: 200,\\n        // Support: IE9\\n        // #1450: sometimes IE returns 1223 when it should be 204\\n        1223: 204\\n    },\\n        xhrSupported = jQuery.ajaxSettings.xhr();\\n\\n    // Support: IE9\\n    // Open requests must be manually aborted on unload (#5280)\\n    if (window.ActiveXObject) {\\n        jQuery(window).on(\"unload\", function () {\\n            for (var key in xhrCallbacks) {\\n                xhrCallbacks[key]();\\n            }\\n        });\\n    }\\n\\n    support.cors = !!xhrSupported && \"withCredentials\" in xhrSupported;\\n    support.ajax = xhrSupported = !!xhrSupported;\\n\\n    jQuery.ajaxTransport(function (options) {\\n        var _callback;\\n\\n        // Cross domain only allowed if supported through XMLHttpRequest\\n        if (support.cors || xhrSupported && !options.crossDomain) {\\n            return {\\n                send: function send(headers, complete) {\\n                    var i,\\n                        xhr = options.xhr(),\\n                        id = ++xhrId;\\n\\n                    xhr.open(options.type, options.url, options.async, options.username, options.password);\\n\\n                    // Apply custom fields if provided\\n                    if (options.xhrFields) {\\n                        for (i in options.xhrFields) {\\n                            xhr[i] = options.xhrFields[i];\\n                        }\\n                    }\\n\\n                    // Override mime type if needed\\n                    if (options.mimeType && xhr.overrideMimeType) {\\n                        xhr.overrideMimeType(options.mimeType);\\n                    }\\n\\n                    // X-Requested-With header\\n                    // For cross-domain requests, seeing as conditions for a preflight are\\n                    // akin to a jigsaw puzzle, we simply never set it to be sure.\\n                    // (it can always be set on a per-request basis or even using ajaxSetup)\\n                    // For same-domain requests, won\\'t change header if already provided.\\n                    if (!options.crossDomain && !headers[\"X-Requested-With\"]) {\\n                        headers[\"X-Requested-With\"] = \"XMLHttpRequest\";\\n                    }\\n\\n                    // Set headers\\n                    for (i in headers) {\\n                        xhr.setRequestHeader(i, headers[i]);\\n                    }\\n\\n                    // Callback\\n                    _callback = function callback(type) {\\n                        return function () {\\n                            if (_callback) {\\n                                delete xhrCallbacks[id];\\n                                _callback = xhr.onload = xhr.onerror = null;\\n\\n                                if (type === \"abort\") {\\n                                    xhr.abort();\\n                                } else if (type === \"error\") {\\n                                    complete(\\n                                    // file: protocol always yields status 0; see #8605, #14207\\n                                    xhr.status, xhr.statusText);\\n                                } else {\\n                                    complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText,\\n                                    // Support: IE9\\n                                    // Accessing binary-data responseText throws an exception\\n                                    // (#11426)\\n                                    typeof xhr.responseText === \"string\" ? {\\n                                        text: xhr.responseText\\n                                    } : undefined, xhr.getAllResponseHeaders());\\n                                }\\n                            }\\n                        };\\n                    };\\n\\n                    // Listen to events\\n                    xhr.onload = _callback();\\n                    xhr.onerror = _callback(\"error\");\\n\\n                    // Create the abort callback\\n                    _callback = xhrCallbacks[id] = _callback(\"abort\");\\n\\n                    try {\\n                        // Do send the request (this may raise an exception)\\n                        xhr.send(options.hasContent && options.data || null);\\n                    } catch (e) {\\n                        // #14683: Only rethrow if this hasn\\'t been notified as an error yet\\n                        if (_callback) {\\n                            throw e;\\n                        }\\n                    }\\n                },\\n\\n                abort: function abort() {\\n                    if (_callback) {\\n                        _callback();\\n                    }\\n                }\\n            };\\n        }\\n    });\\n\\n    // Install script dataType\\n    jQuery.ajaxSetup({\\n        accepts: {\\n            script: \"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript\"\\n        },\\n        contents: {\\n            script: /(?:java|ecma)script/\\n        },\\n        converters: {\\n            \"text script\": function textScript(text) {\\n                jQuery.globalEval(text);\\n                return text;\\n            }\\n        }\\n    });\\n\\n    // Handle cache\\'s special case and crossDomain\\n    jQuery.ajaxPrefilter(\"script\", function (s) {\\n        if (s.cache === undefined) {\\n            s.cache = false;\\n        }\\n        if (s.crossDomain) {\\n            s.type = \"GET\";\\n        }\\n    });\\n\\n    // Bind script tag hack transport\\n    jQuery.ajaxTransport(\"script\", function (s) {\\n        // This transport only deals with cross domain requests\\n        if (s.crossDomain) {\\n            var script, _callback2;\\n            return {\\n                send: function send(_, complete) {\\n                    script = jQuery(\"<script>\").prop({\\n                        async: true,\\n                        charset: s.scriptCharset,\\n                        src: s.url\\n                    }).on(\"load error\", _callback2 = function callback(evt) {\\n                        script.remove();\\n                        _callback2 = null;\\n                        if (evt) {\\n                            complete(evt.type === \"error\" ? 404 : 200, evt.type);\\n                        }\\n                    });\\n                    document.head.appendChild(script[0]);\\n                },\\n                abort: function abort() {\\n                    if (_callback2) {\\n                        _callback2();\\n                    }\\n                }\\n            };\\n        }\\n    });\\n\\n    var oldCallbacks = [],\\n        rjsonp = /(=)\\\\?(?=&|$)|\\\\?\\\\?/;\\n\\n    // Default jsonp settings\\n    jQuery.ajaxSetup({\\n        jsonp: \"callback\",\\n        jsonpCallback: function jsonpCallback() {\\n            var callback = oldCallbacks.pop() || jQuery.expando + \"_\" + nonce++;\\n            this[callback] = true;\\n            return callback;\\n        }\\n    });\\n\\n    // Detect, normalize options and install callbacks for jsonp requests\\n    jQuery.ajaxPrefilter(\"json jsonp\", function (s, originalSettings, jqXHR) {\\n\\n        var callbackName,\\n            overwritten,\\n            responseContainer,\\n            jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? \"url\" : typeof s.data === \"string\" && !(s.contentType || \"\").indexOf(\"application/x-www-form-urlencoded\") && rjsonp.test(s.data) && \"data\");\\n\\n        // Handle iff the expected data type is \"jsonp\" or we have a parameter to set\\n        if (jsonProp || s.dataTypes[0] === \"jsonp\") {\\n\\n            // Get callback name, remembering preexisting value associated with it\\n            callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;\\n\\n            // Insert callback into url or form data\\n            if (jsonProp) {\\n                s[jsonProp] = s[jsonProp].replace(rjsonp, \"$1\" + callbackName);\\n            } else if (s.jsonp !== false) {\\n                s.url += (rquery.test(s.url) ? \"&\" : \"?\") + s.jsonp + \"=\" + callbackName;\\n            }\\n\\n            // Use data converter to retrieve json after script execution\\n            s.converters[\"script json\"] = function () {\\n                if (!responseContainer) {\\n                    jQuery.error(callbackName + \" was not called\");\\n                }\\n                return responseContainer[0];\\n            };\\n\\n            // force json dataType\\n            s.dataTypes[0] = \"json\";\\n\\n            // Install callback\\n            overwritten = window[callbackName];\\n            window[callbackName] = function () {\\n                responseContainer = arguments;\\n            };\\n\\n            // Clean-up function (fires after converters)\\n            jqXHR.always(function () {\\n                // Restore preexisting value\\n                window[callbackName] = overwritten;\\n\\n                // Save back as free\\n                if (s[callbackName]) {\\n                    // make sure that re-using the options doesn\\'t screw things around\\n                    s.jsonpCallback = originalSettings.jsonpCallback;\\n\\n                    // save the callback name for future use\\n                    oldCallbacks.push(callbackName);\\n                }\\n\\n                // Call if it was a function and we have a response\\n                if (responseContainer && jQuery.isFunction(overwritten)) {\\n                    overwritten(responseContainer[0]);\\n                }\\n\\n                responseContainer = overwritten = undefined;\\n            });\\n\\n            // Delegate to script\\n            return \"script\";\\n        }\\n    });\\n\\n    // data: string of html\\n    // context (optional): If specified, the fragment will be created in this context, defaults to document\\n    // keepScripts (optional): If true, will include scripts passed in the html string\\n    jQuery.parseHTML = function (data, context, keepScripts) {\\n        if (!data || typeof data !== \"string\") {\\n            return null;\\n        }\\n        if (typeof context === \"boolean\") {\\n            keepScripts = context;\\n            context = false;\\n        }\\n        context = context || document;\\n\\n        var parsed = rsingleTag.exec(data),\\n            scripts = !keepScripts && [];\\n\\n        // Single tag\\n        if (parsed) {\\n            return [context.createElement(parsed[1])];\\n        }\\n\\n        parsed = jQuery.buildFragment([data], context, scripts);\\n\\n        if (scripts && scripts.length) {\\n            jQuery(scripts).remove();\\n        }\\n\\n        return jQuery.merge([], parsed.childNodes);\\n    };\\n\\n    // Keep a copy of the old load method\\n    var _load = jQuery.fn.load;\\n\\n    /**\\r\\n     * Load a url into a page\\r\\n     */\\n    jQuery.fn.load = function (url, params, callback) {\\n        if (typeof url !== \"string\" && _load) {\\n            return _load.apply(this, arguments);\\n        }\\n\\n        var selector,\\n            type,\\n            response,\\n            self = this,\\n            off = url.indexOf(\" \");\\n\\n        if (off >= 0) {\\n            selector = jQuery.trim(url.slice(off));\\n            url = url.slice(0, off);\\n        }\\n\\n        // If it\\'s a function\\n        if (jQuery.isFunction(params)) {\\n\\n            // We assume that it\\'s the callback\\n            callback = params;\\n            params = undefined;\\n\\n            // Otherwise, build a param string\\n        } else if (params && (typeof params === \"undefined\" ? \"undefined\" : _typeof(params)) === \"object\") {\\n            type = \"POST\";\\n        }\\n\\n        // If we have elements to modify, make the request\\n        if (self.length > 0) {\\n            jQuery.ajax({\\n                url: url,\\n\\n                // if \"type\" variable is undefined, then \"GET\" method will be used\\n                type: type,\\n                dataType: \"html\",\\n                data: params\\n            }).done(function (responseText) {\\n\\n                // Save response for use in complete callback\\n                response = arguments;\\n\\n                self.html(selector ?\\n\\n                // If a selector was specified, locate the right elements in a dummy div\\n                // Exclude scripts to avoid IE \\'Permission Denied\\' errors\\n                jQuery(\"<div>\").append(jQuery.parseHTML(responseText)).find(selector) :\\n\\n                // Otherwise use the full result\\n                responseText);\\n            }).complete(callback && function (jqXHR, status) {\\n                self.each(callback, response || [jqXHR.responseText, status, jqXHR]);\\n            });\\n        }\\n\\n        return this;\\n    };\\n\\n    jQuery.expr.filters.animated = function (elem) {\\n        return jQuery.grep(jQuery.timers, function (fn) {\\n            return elem === fn.elem;\\n        }).length;\\n    };\\n\\n    var docElem = window.document.documentElement;\\n\\n    /**\\r\\n     * Gets a window from an element\\r\\n     */\\n    function getWindow(elem) {\\n        return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;\\n    }\\n\\n    jQuery.offset = {\\n        setOffset: function setOffset(elem, options, i) {\\n            var curPosition,\\n                curLeft,\\n                curCSSTop,\\n                curTop,\\n                curOffset,\\n                curCSSLeft,\\n                calculatePosition,\\n                position = jQuery.css(elem, \"position\"),\\n                curElem = jQuery(elem),\\n                props = {};\\n\\n            // Set position first, in-case top/left are set even on static elem\\n            if (position === \"static\") {\\n                elem.style.position = \"relative\";\\n            }\\n\\n            curOffset = curElem.offset();\\n            curCSSTop = jQuery.css(elem, \"top\");\\n            curCSSLeft = jQuery.css(elem, \"left\");\\n            calculatePosition = (position === \"absolute\" || position === \"fixed\") && (curCSSTop + curCSSLeft).indexOf(\"auto\") > -1;\\n\\n            // Need to be able to calculate position if either top or left is auto and position is either absolute or fixed\\n            if (calculatePosition) {\\n                curPosition = curElem.position();\\n                curTop = curPosition.top;\\n                curLeft = curPosition.left;\\n            } else {\\n                curTop = parseFloat(curCSSTop) || 0;\\n                curLeft = parseFloat(curCSSLeft) || 0;\\n            }\\n\\n            if (jQuery.isFunction(options)) {\\n                options = options.call(elem, i, curOffset);\\n            }\\n\\n            if (options.top != null) {\\n                props.top = options.top - curOffset.top + curTop;\\n            }\\n            if (options.left != null) {\\n                props.left = options.left - curOffset.left + curLeft;\\n            }\\n\\n            if (\"using\" in options) {\\n                options.using.call(elem, props);\\n            } else {\\n                curElem.css(props);\\n            }\\n        }\\n    };\\n\\n    jQuery.fn.extend({\\n        offset: function offset(options) {\\n            if (arguments.length) {\\n                return options === undefined ? this : this.each(function (i) {\\n                    jQuery.offset.setOffset(this, options, i);\\n                });\\n            }\\n\\n            var docElem,\\n                win,\\n                elem = this[0],\\n                box = { top: 0, left: 0 },\\n                doc = elem && elem.ownerDocument;\\n\\n            if (!doc) {\\n                return;\\n            }\\n\\n            docElem = doc.documentElement;\\n\\n            // Make sure it\\'s not a disconnected DOM node\\n            if (!jQuery.contains(docElem, elem)) {\\n                return box;\\n            }\\n\\n            // If we don\\'t have gBCR, just use 0,0 rather than error\\n            // BlackBerry 5, iOS 3 (original iPhone)\\n            if (_typeof(elem.getBoundingClientRect) !== strundefined) {\\n                box = elem.getBoundingClientRect();\\n            }\\n            win = getWindow(doc);\\n            return {\\n                top: box.top + win.pageYOffset - docElem.clientTop,\\n                left: box.left + win.pageXOffset - docElem.clientLeft\\n            };\\n        },\\n\\n        position: function position() {\\n            if (!this[0]) {\\n                return;\\n            }\\n\\n            var offsetParent,\\n                offset,\\n                elem = this[0],\\n                parentOffset = { top: 0, left: 0 };\\n\\n            // Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent\\n            if (jQuery.css(elem, \"position\") === \"fixed\") {\\n                // We assume that getBoundingClientRect is available when computed position is fixed\\n                offset = elem.getBoundingClientRect();\\n            } else {\\n                // Get *real* offsetParent\\n                offsetParent = this.offsetParent();\\n\\n                // Get correct offsets\\n                offset = this.offset();\\n                if (!jQuery.nodeName(offsetParent[0], \"html\")) {\\n                    parentOffset = offsetParent.offset();\\n                }\\n\\n                // Add offsetParent borders\\n                parentOffset.top += jQuery.css(offsetParent[0], \"borderTopWidth\", true);\\n                parentOffset.left += jQuery.css(offsetParent[0], \"borderLeftWidth\", true);\\n            }\\n\\n            // Subtract parent offsets and element margins\\n            return {\\n                top: offset.top - parentOffset.top - jQuery.css(elem, \"marginTop\", true),\\n                left: offset.left - parentOffset.left - jQuery.css(elem, \"marginLeft\", true)\\n            };\\n        },\\n\\n        offsetParent: function offsetParent() {\\n            return this.map(function () {\\n                var offsetParent = this.offsetParent || docElem;\\n\\n                while (offsetParent && !jQuery.nodeName(offsetParent, \"html\") && jQuery.css(offsetParent, \"position\") === \"static\") {\\n                    offsetParent = offsetParent.offsetParent;\\n                }\\n\\n                return offsetParent || docElem;\\n            });\\n        }\\n    });\\n\\n    // Create scrollLeft and scrollTop methods\\n    jQuery.each({ scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\" }, function (method, prop) {\\n        var top = \"pageYOffset\" === prop;\\n\\n        jQuery.fn[method] = function (val) {\\n            return access(this, function (elem, method, val) {\\n                var win = getWindow(elem);\\n\\n                if (val === undefined) {\\n                    return win ? win[prop] : elem[method];\\n                }\\n\\n                if (win) {\\n                    win.scrollTo(!top ? val : window.pageXOffset, top ? val : window.pageYOffset);\\n                } else {\\n                    elem[method] = val;\\n                }\\n            }, method, val, arguments.length, null);\\n        };\\n    });\\n\\n    // Add the top/left cssHooks using jQuery.fn.position\\n    // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\\n    // getComputedStyle returns percent when specified for top/left/bottom/right\\n    // rather than make the css module depend on the offset module, we just check for it here\\n    jQuery.each([\"top\", \"left\"], function (i, prop) {\\n        jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function (elem, computed) {\\n            if (computed) {\\n                computed = curCSS(elem, prop);\\n                // if curCSS returns percentage, fallback to offset\\n                return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + \"px\" : computed;\\n            }\\n        });\\n    });\\n\\n    // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\\n    jQuery.each({ Height: \"height\", Width: \"width\" }, function (name, type) {\\n        jQuery.each({ padding: \"inner\" + name, content: type, \"\": \"outer\" + name }, function (defaultExtra, funcName) {\\n            // margin is only for outerHeight, outerWidth\\n            jQuery.fn[funcName] = function (margin, value) {\\n                var chainable = arguments.length && (defaultExtra || typeof margin !== \"boolean\"),\\n                    extra = defaultExtra || (margin === true || value === true ? \"margin\" : \"border\");\\n\\n                return access(this, function (elem, type, value) {\\n                    var doc;\\n\\n                    if (jQuery.isWindow(elem)) {\\n                        // As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there\\n                        // isn\\'t a whole lot we can do. See pull request at this URL for discussion:\\n                        // https://github.com/jquery/jquery/pull/764\\n                        return elem.document.documentElement[\"client\" + name];\\n                    }\\n\\n                    // Get document width or height\\n                    if (elem.nodeType === 9) {\\n                        doc = elem.documentElement;\\n\\n                        // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\\n                        // whichever is greatest\\n                        return Math.max(elem.body[\"scroll\" + name], doc[\"scroll\" + name], elem.body[\"offset\" + name], doc[\"offset\" + name], doc[\"client\" + name]);\\n                    }\\n\\n                    return value === undefined ?\\n                    // Get width or height on the element, requesting but not forcing parseFloat\\n                    jQuery.css(elem, type, extra) :\\n\\n                    // Set width or height on the element\\n                    jQuery.style(elem, type, value, extra);\\n                }, type, chainable ? margin : undefined, chainable, null);\\n            };\\n        });\\n    });\\n\\n    // The number of elements contained in the matched element set\\n    jQuery.fn.size = function () {\\n        return this.length;\\n    };\\n\\n    jQuery.fn.andSelf = jQuery.fn.addBack;\\n\\n    // Register as a named AMD module, since jQuery can be concatenated with other\\n    // files that may use define, but not via a proper concatenation script that\\n    // understands anonymous AMD modules. A named AMD is safest and most robust\\n    // way to register. Lowercase jquery is used because AMD module names are\\n    // derived from file names, and jQuery is normally delivered in a lowercase\\n    // file name. Do this after creating the global so that if an AMD module wants\\n    // to call noConflict to hide this version of jQuery, it will work.\\n\\n    // Note that for maximum portability, libraries that are not jQuery should\\n    // declare themselves as anonymous modules, and avoid setting a global if an\\n    // AMD loader is present. jQuery is a special case. For more information, see\\n    // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\\n\\n    if (true) {\\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\\n            return jQuery;\\n        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\\n\\t\\t\\t\\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\\n    }\\n\\n    var\\n    // Map over jQuery in case of overwrite\\n    _jQuery = window.jQuery,\\n\\n\\n    // Map over the $ in case of overwrite\\n    _$ = window.$;\\n\\n    jQuery.noConflict = function (deep) {\\n        if (window.$ === jQuery) {\\n            window.$ = _$;\\n        }\\n\\n        if (deep && window.jQuery === jQuery) {\\n            window.jQuery = _jQuery;\\n        }\\n\\n        return jQuery;\\n    };\\n\\n    // Expose jQuery and $ identifiers, even in\\n    // AMD (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\\n    // and CommonJS for browser emulators (#13566)\\n    if ((typeof noGlobal === \"undefined\" ? \"undefined\" : _typeof(noGlobal)) === strundefined) {\\n        window.jQuery = window.$ = jQuery;\\n    }\\n\\n    return jQuery;\\n});\\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(5)(module)))//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wdWJsaWMvamF2YXNjcmlwdHMvanF1ZXJ5LmpzPzY1NDAiXSwibmFtZXMiOlsiZ2xvYmFsIiwiZmFjdG9yeSIsIm1vZHVsZSIsImV4cG9ydHMiLCJkb2N1bWVudCIsInciLCJFcnJvciIsIndpbmRvdyIsIm5vR2xvYmFsIiwiYXJyIiwic2xpY2UiLCJjb25jYXQiLCJwdXNoIiwiaW5kZXhPZiIsImNsYXNzMnR5cGUiLCJ0b1N0cmluZyIsImhhc093biIsImhhc093blByb3BlcnR5Iiwic3VwcG9ydCIsInZlcnNpb24iLCJqUXVlcnkiLCJzZWxlY3RvciIsImNvbnRleHQiLCJmbiIsImluaXQiLCJydHJpbSIsInJtc1ByZWZpeCIsInJkYXNoQWxwaGEiLCJmY2FtZWxDYXNlIiwiYWxsIiwibGV0dGVyIiwidG9VcHBlckNhc2UiLCJwcm90b3R5cGUiLCJqcXVlcnkiLCJjb25zdHJ1Y3RvciIsImxlbmd0aCIsInRvQXJyYXkiLCJjYWxsIiwiZ2V0IiwibnVtIiwicHVzaFN0YWNrIiwiZWxlbXMiLCJyZXQiLCJtZXJnZSIsInByZXZPYmplY3QiLCJlYWNoIiwiY2FsbGJhY2siLCJhcmdzIiwibWFwIiwiZWxlbSIsImkiLCJhcHBseSIsImFyZ3VtZW50cyIsImZpcnN0IiwiZXEiLCJsYXN0IiwibGVuIiwiaiIsImVuZCIsInNvcnQiLCJzcGxpY2UiLCJleHRlbmQiLCJvcHRpb25zIiwibmFtZSIsInNyYyIsImNvcHkiLCJjb3B5SXNBcnJheSIsImNsb25lIiwidGFyZ2V0IiwiZGVlcCIsImlzRnVuY3Rpb24iLCJpc1BsYWluT2JqZWN0IiwiaXNBcnJheSIsInVuZGVmaW5lZCIsImV4cGFuZG8iLCJNYXRoIiwicmFuZG9tIiwicmVwbGFjZSIsImlzUmVhZHkiLCJlcnJvciIsIm1zZyIsIm5vb3AiLCJvYmoiLCJ0eXBlIiwiQXJyYXkiLCJpc1dpbmRvdyIsImlzTnVtZXJpYyIsInBhcnNlRmxvYXQiLCJub2RlVHlwZSIsImlzRW1wdHlPYmplY3QiLCJnbG9iYWxFdmFsIiwiY29kZSIsInNjcmlwdCIsImluZGlyZWN0IiwiZXZhbCIsInRyaW0iLCJjcmVhdGVFbGVtZW50IiwidGV4dCIsImhlYWQiLCJhcHBlbmRDaGlsZCIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsImNhbWVsQ2FzZSIsInN0cmluZyIsIm5vZGVOYW1lIiwidG9Mb3dlckNhc2UiLCJ2YWx1ZSIsImlzQXJyYXlsaWtlIiwibWFrZUFycmF5IiwicmVzdWx0cyIsIk9iamVjdCIsImluQXJyYXkiLCJzZWNvbmQiLCJncmVwIiwiaW52ZXJ0IiwiY2FsbGJhY2tJbnZlcnNlIiwibWF0Y2hlcyIsImNhbGxiYWNrRXhwZWN0IiwiYXJnIiwiZ3VpZCIsInByb3h5IiwidG1wIiwibm93IiwiRGF0ZSIsInNwbGl0IiwiU2l6emxlIiwiRXhwciIsImdldFRleHQiLCJpc1hNTCIsInRva2VuaXplIiwiY29tcGlsZSIsInNlbGVjdCIsIm91dGVybW9zdENvbnRleHQiLCJzb3J0SW5wdXQiLCJoYXNEdXBsaWNhdGUiLCJzZXREb2N1bWVudCIsImRvY0VsZW0iLCJkb2N1bWVudElzSFRNTCIsInJidWdneVFTQSIsInJidWdneU1hdGNoZXMiLCJjb250YWlucyIsInByZWZlcnJlZERvYyIsImRpcnJ1bnMiLCJkb25lIiwiY2xhc3NDYWNoZSIsImNyZWF0ZUNhY2hlIiwidG9rZW5DYWNoZSIsImNvbXBpbGVyQ2FjaGUiLCJzb3J0T3JkZXIiLCJhIiwiYiIsInN0cnVuZGVmaW5lZCIsIk1BWF9ORUdBVElWRSIsInBvcCIsInB1c2hfbmF0aXZlIiwiYm9vbGVhbnMiLCJ3aGl0ZXNwYWNlIiwiY2hhcmFjdGVyRW5jb2RpbmciLCJpZGVudGlmaWVyIiwiYXR0cmlidXRlcyIsInBzZXVkb3MiLCJSZWdFeHAiLCJyY29tbWEiLCJyY29tYmluYXRvcnMiLCJyYXR0cmlidXRlUXVvdGVzIiwicnBzZXVkbyIsInJpZGVudGlmaWVyIiwibWF0Y2hFeHByIiwicmlucHV0cyIsInJoZWFkZXIiLCJybmF0aXZlIiwicnF1aWNrRXhwciIsInJzaWJsaW5nIiwicmVzY2FwZSIsInJ1bmVzY2FwZSIsImZ1bmVzY2FwZSIsIl8iLCJlc2NhcGVkIiwiZXNjYXBlZFdoaXRlc3BhY2UiLCJoaWdoIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiY2hpbGROb2RlcyIsImUiLCJlbHMiLCJzZWVkIiwibWF0Y2giLCJtIiwiZ3JvdXBzIiwib2xkIiwibmlkIiwibmV3Q29udGV4dCIsIm5ld1NlbGVjdG9yIiwib3duZXJEb2N1bWVudCIsImV4ZWMiLCJnZXRFbGVtZW50QnlJZCIsImlkIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJnZXRFbGVtZW50c0J5Q2xhc3NOYW1lIiwicXNhIiwidGVzdCIsImdldEF0dHJpYnV0ZSIsInNldEF0dHJpYnV0ZSIsInRvU2VsZWN0b3IiLCJ0ZXN0Q29udGV4dCIsImpvaW4iLCJxdWVyeVNlbGVjdG9yQWxsIiwicXNhRXJyb3IiLCJyZW1vdmVBdHRyaWJ1dGUiLCJrZXlzIiwiY2FjaGUiLCJrZXkiLCJjYWNoZUxlbmd0aCIsInNoaWZ0IiwibWFya0Z1bmN0aW9uIiwiYXNzZXJ0IiwiZGl2IiwiYWRkSGFuZGxlIiwiYXR0cnMiLCJoYW5kbGVyIiwiYXR0ckhhbmRsZSIsInNpYmxpbmdDaGVjayIsImN1ciIsImRpZmYiLCJzb3VyY2VJbmRleCIsIm5leHRTaWJsaW5nIiwiY3JlYXRlSW5wdXRQc2V1ZG8iLCJjcmVhdGVCdXR0b25Qc2V1ZG8iLCJjcmVhdGVQb3NpdGlvbmFsUHNldWRvIiwiYXJndW1lbnQiLCJtYXRjaEluZGV4ZXMiLCJkb2N1bWVudEVsZW1lbnQiLCJub2RlIiwiaGFzQ29tcGFyZSIsImRvYyIsInBhcmVudCIsImRlZmF1bHRWaWV3IiwidG9wIiwiYWRkRXZlbnRMaXN0ZW5lciIsImF0dGFjaEV2ZW50IiwiY2xhc3NOYW1lIiwiY3JlYXRlQ29tbWVudCIsImlubmVySFRNTCIsImZpcnN0Q2hpbGQiLCJnZXRCeUlkIiwiZ2V0RWxlbWVudHNCeU5hbWUiLCJmaW5kIiwiZmlsdGVyIiwiYXR0cklkIiwiZ2V0QXR0cmlidXRlTm9kZSIsInRhZyIsImlucHV0IiwibWF0Y2hlc1NlbGVjdG9yIiwid2Via2l0TWF0Y2hlc1NlbGVjdG9yIiwibW96TWF0Y2hlc1NlbGVjdG9yIiwib01hdGNoZXNTZWxlY3RvciIsIm1zTWF0Y2hlc1NlbGVjdG9yIiwiZGlzY29ubmVjdGVkTWF0Y2giLCJjb21wYXJlRG9jdW1lbnRQb3NpdGlvbiIsImFkb3duIiwiYnVwIiwiY29tcGFyZSIsInNvcnREZXRhY2hlZCIsImF1cCIsImFwIiwiYnAiLCJ1bnNoaWZ0IiwiZXhwciIsImVsZW1lbnRzIiwiYXR0ciIsInZhbCIsInNwZWNpZmllZCIsInVuaXF1ZVNvcnQiLCJkdXBsaWNhdGVzIiwiZGV0ZWN0RHVwbGljYXRlcyIsInNvcnRTdGFibGUiLCJ0ZXh0Q29udGVudCIsIm5vZGVWYWx1ZSIsInNlbGVjdG9ycyIsImNyZWF0ZVBzZXVkbyIsInJlbGF0aXZlIiwiZGlyIiwicHJlRmlsdGVyIiwiZXhjZXNzIiwidW5xdW90ZWQiLCJub2RlTmFtZVNlbGVjdG9yIiwicGF0dGVybiIsIm9wZXJhdG9yIiwiY2hlY2siLCJyZXN1bHQiLCJ3aGF0Iiwic2ltcGxlIiwiZm9yd2FyZCIsIm9mVHlwZSIsInhtbCIsIm91dGVyQ2FjaGUiLCJub2RlSW5kZXgiLCJzdGFydCIsInVzZUNhY2hlIiwibGFzdENoaWxkIiwicHNldWRvIiwic2V0RmlsdGVycyIsImlkeCIsIm1hdGNoZWQiLCJtYXRjaGVyIiwidW5tYXRjaGVkIiwiaW5uZXJUZXh0IiwibGFuZyIsImVsZW1MYW5nIiwiaGFzaCIsImxvY2F0aW9uIiwiYWN0aXZlRWxlbWVudCIsImhhc0ZvY3VzIiwiaHJlZiIsInRhYkluZGV4IiwiZGlzYWJsZWQiLCJjaGVja2VkIiwic2VsZWN0ZWQiLCJzZWxlY3RlZEluZGV4IiwicmFkaW8iLCJjaGVja2JveCIsImZpbGUiLCJwYXNzd29yZCIsImltYWdlIiwic3VibWl0IiwicmVzZXQiLCJmaWx0ZXJzIiwicGFyc2VPbmx5IiwidG9rZW5zIiwic29GYXIiLCJwcmVGaWx0ZXJzIiwiY2FjaGVkIiwiYWRkQ29tYmluYXRvciIsImNvbWJpbmF0b3IiLCJiYXNlIiwiY2hlY2tOb25FbGVtZW50cyIsImRvbmVOYW1lIiwib2xkQ2FjaGUiLCJuZXdDYWNoZSIsImVsZW1lbnRNYXRjaGVyIiwibWF0Y2hlcnMiLCJtdWx0aXBsZUNvbnRleHRzIiwiY29udGV4dHMiLCJjb25kZW5zZSIsIm5ld1VubWF0Y2hlZCIsIm1hcHBlZCIsInNldE1hdGNoZXIiLCJwb3N0RmlsdGVyIiwicG9zdEZpbmRlciIsInBvc3RTZWxlY3RvciIsInRlbXAiLCJwcmVNYXAiLCJwb3N0TWFwIiwicHJlZXhpc3RpbmciLCJtYXRjaGVySW4iLCJtYXRjaGVyT3V0IiwibWF0Y2hlckZyb21Ub2tlbnMiLCJjaGVja0NvbnRleHQiLCJsZWFkaW5nUmVsYXRpdmUiLCJpbXBsaWNpdFJlbGF0aXZlIiwibWF0Y2hDb250ZXh0IiwibWF0Y2hBbnlDb250ZXh0IiwibWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzIiwiZWxlbWVudE1hdGNoZXJzIiwic2V0TWF0Y2hlcnMiLCJieVNldCIsImJ5RWxlbWVudCIsInN1cGVyTWF0Y2hlciIsIm91dGVybW9zdCIsIm1hdGNoZWRDb3VudCIsInNldE1hdGNoZWQiLCJjb250ZXh0QmFja3VwIiwiZGlycnVuc1VuaXF1ZSIsInRva2VuIiwiY29tcGlsZWQiLCJkaXYxIiwiZGVmYXVsdFZhbHVlIiwidW5pcXVlIiwiaXNYTUxEb2MiLCJybmVlZHNDb250ZXh0IiwibmVlZHNDb250ZXh0IiwicnNpbmdsZVRhZyIsInJpc1NpbXBsZSIsIndpbm5vdyIsInF1YWxpZmllciIsIm5vdCIsInNlbGYiLCJpcyIsInJvb3RqUXVlcnkiLCJwYXJzZUhUTUwiLCJyZWFkeSIsInJwYXJlbnRzcHJldiIsImd1YXJhbnRlZWRVbmlxdWUiLCJjaGlsZHJlbiIsImNvbnRlbnRzIiwibmV4dCIsInByZXYiLCJ1bnRpbCIsInRydW5jYXRlIiwic2libGluZyIsIm4iLCJoYXMiLCJ0YXJnZXRzIiwibCIsImNsb3Nlc3QiLCJwb3MiLCJpbmRleCIsInByZXZBbGwiLCJhZGQiLCJhZGRCYWNrIiwicGFyZW50cyIsInBhcmVudHNVbnRpbCIsIm5leHRBbGwiLCJuZXh0VW50aWwiLCJwcmV2VW50aWwiLCJzaWJsaW5ncyIsImNvbnRlbnREb2N1bWVudCIsInJldmVyc2UiLCJybm90d2hpdGUiLCJvcHRpb25zQ2FjaGUiLCJjcmVhdGVPcHRpb25zIiwib2JqZWN0IiwiZmxhZyIsIkNhbGxiYWNrcyIsIm1lbW9yeSIsImZpcmVkIiwiZmlyaW5nIiwiZmlyaW5nU3RhcnQiLCJmaXJpbmdMZW5ndGgiLCJmaXJpbmdJbmRleCIsImxpc3QiLCJzdGFjayIsIm9uY2UiLCJmaXJlIiwiZGF0YSIsInN0b3BPbkZhbHNlIiwiZGlzYWJsZSIsInJlbW92ZSIsImVtcHR5IiwibG9jayIsImxvY2tlZCIsImZpcmVXaXRoIiwiRGVmZXJyZWQiLCJmdW5jIiwidHVwbGVzIiwic3RhdGUiLCJwcm9taXNlIiwiYWx3YXlzIiwiZGVmZXJyZWQiLCJmYWlsIiwidGhlbiIsImZucyIsIm5ld0RlZmVyIiwidHVwbGUiLCJyZXR1cm5lZCIsInJlc29sdmUiLCJyZWplY3QiLCJwcm9ncmVzcyIsIm5vdGlmeSIsInBpcGUiLCJzdGF0ZVN0cmluZyIsIndoZW4iLCJzdWJvcmRpbmF0ZSIsInJlc29sdmVWYWx1ZXMiLCJyZW1haW5pbmciLCJ1cGRhdGVGdW5jIiwidmFsdWVzIiwicHJvZ3Jlc3NWYWx1ZXMiLCJub3RpZnlXaXRoIiwicmVzb2x2ZVdpdGgiLCJwcm9ncmVzc0NvbnRleHRzIiwicmVzb2x2ZUNvbnRleHRzIiwicmVhZHlMaXN0IiwicmVhZHlXYWl0IiwiaG9sZFJlYWR5IiwiaG9sZCIsIndhaXQiLCJ0cmlnZ2VySGFuZGxlciIsIm9mZiIsImNvbXBsZXRlZCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJyZWFkeVN0YXRlIiwic2V0VGltZW91dCIsImFjY2VzcyIsImNoYWluYWJsZSIsImVtcHR5R2V0IiwicmF3IiwiYnVsayIsImFjY2VwdERhdGEiLCJvd25lciIsIkRhdGEiLCJkZWZpbmVQcm9wZXJ0eSIsInVpZCIsImFjY2VwdHMiLCJkZXNjcmlwdG9yIiwidW5sb2NrIiwiZGVmaW5lUHJvcGVydGllcyIsInNldCIsInByb3AiLCJzdG9yZWQiLCJjYW1lbCIsImhhc0RhdGEiLCJkaXNjYXJkIiwiZGF0YV9wcml2IiwiZGF0YV91c2VyIiwicmJyYWNlIiwicm11bHRpRGFzaCIsImRhdGFBdHRyIiwicGFyc2VKU09OIiwicmVtb3ZlRGF0YSIsIl9kYXRhIiwiX3JlbW92ZURhdGEiLCJjYW1lbEtleSIsInF1ZXVlIiwiZGVxdWV1ZSIsInN0YXJ0TGVuZ3RoIiwiaG9va3MiLCJfcXVldWVIb29rcyIsInN0b3AiLCJzZXR0ZXIiLCJjbGVhclF1ZXVlIiwiY291bnQiLCJkZWZlciIsInBudW0iLCJzb3VyY2UiLCJjc3NFeHBhbmQiLCJpc0hpZGRlbiIsImVsIiwiY3NzIiwicmNoZWNrYWJsZVR5cGUiLCJmcmFnbWVudCIsImNyZWF0ZURvY3VtZW50RnJhZ21lbnQiLCJjaGVja0Nsb25lIiwiY2xvbmVOb2RlIiwibm9DbG9uZUNoZWNrZWQiLCJmb2N1c2luQnViYmxlcyIsInJrZXlFdmVudCIsInJtb3VzZUV2ZW50IiwicmZvY3VzTW9ycGgiLCJydHlwZW5hbWVzcGFjZSIsInJldHVyblRydWUiLCJyZXR1cm5GYWxzZSIsInNhZmVBY3RpdmVFbGVtZW50IiwiZXJyIiwiZXZlbnQiLCJ0eXBlcyIsImhhbmRsZU9iakluIiwiZXZlbnRIYW5kbGUiLCJldmVudHMiLCJ0IiwiaGFuZGxlT2JqIiwic3BlY2lhbCIsImhhbmRsZXJzIiwibmFtZXNwYWNlcyIsIm9yaWdUeXBlIiwiZWxlbURhdGEiLCJoYW5kbGUiLCJ0cmlnZ2VyZWQiLCJkaXNwYXRjaCIsImRlbGVnYXRlVHlwZSIsImJpbmRUeXBlIiwibmFtZXNwYWNlIiwiZGVsZWdhdGVDb3VudCIsInNldHVwIiwibWFwcGVkVHlwZXMiLCJvcmlnQ291bnQiLCJ0ZWFyZG93biIsInJlbW92ZUV2ZW50IiwidHJpZ2dlciIsIm9ubHlIYW5kbGVycyIsImJ1YmJsZVR5cGUiLCJvbnR5cGUiLCJldmVudFBhdGgiLCJFdmVudCIsImlzVHJpZ2dlciIsIm5hbWVzcGFjZV9yZSIsIm5vQnViYmxlIiwicGFyZW50V2luZG93IiwiaXNQcm9wYWdhdGlvblN0b3BwZWQiLCJwcmV2ZW50RGVmYXVsdCIsImlzRGVmYXVsdFByZXZlbnRlZCIsIl9kZWZhdWx0IiwiZml4IiwiaGFuZGxlclF1ZXVlIiwiZGVsZWdhdGVUYXJnZXQiLCJwcmVEaXNwYXRjaCIsImN1cnJlbnRUYXJnZXQiLCJpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCIsInN0b3BQcm9wYWdhdGlvbiIsInBvc3REaXNwYXRjaCIsInNlbCIsImJ1dHRvbiIsInByb3BzIiwiZml4SG9va3MiLCJrZXlIb29rcyIsIm9yaWdpbmFsIiwid2hpY2giLCJjaGFyQ29kZSIsImtleUNvZGUiLCJtb3VzZUhvb2tzIiwiZXZlbnREb2MiLCJib2R5IiwicGFnZVgiLCJjbGllbnRYIiwic2Nyb2xsTGVmdCIsImNsaWVudExlZnQiLCJwYWdlWSIsImNsaWVudFkiLCJzY3JvbGxUb3AiLCJjbGllbnRUb3AiLCJvcmlnaW5hbEV2ZW50IiwiZml4SG9vayIsImxvYWQiLCJmb2N1cyIsImJsdXIiLCJjbGljayIsImJlZm9yZXVubG9hZCIsInJldHVyblZhbHVlIiwic2ltdWxhdGUiLCJidWJibGUiLCJpc1NpbXVsYXRlZCIsImRlZmF1bHRQcmV2ZW50ZWQiLCJ0aW1lU3RhbXAiLCJzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24iLCJtb3VzZWVudGVyIiwibW91c2VsZWF2ZSIsInBvaW50ZXJlbnRlciIsInBvaW50ZXJsZWF2ZSIsIm9yaWciLCJyZWxhdGVkIiwicmVsYXRlZFRhcmdldCIsImF0dGFjaGVzIiwib24iLCJvbmUiLCJvcmlnRm4iLCJyeGh0bWxUYWciLCJydGFnTmFtZSIsInJodG1sIiwicm5vSW5uZXJodG1sIiwicmNoZWNrZWQiLCJyc2NyaXB0VHlwZSIsInJzY3JpcHRUeXBlTWFza2VkIiwicmNsZWFuU2NyaXB0Iiwid3JhcE1hcCIsIm9wdGlvbiIsInRoZWFkIiwiY29sIiwidHIiLCJ0ZCIsIm9wdGdyb3VwIiwidGJvZHkiLCJ0Zm9vdCIsImNvbGdyb3VwIiwiY2FwdGlvbiIsInRoIiwibWFuaXB1bGF0aW9uVGFyZ2V0IiwiY29udGVudCIsImRpc2FibGVTY3JpcHQiLCJyZXN0b3JlU2NyaXB0Iiwic2V0R2xvYmFsRXZhbCIsInJlZkVsZW1lbnRzIiwiY2xvbmVDb3B5RXZlbnQiLCJkZXN0IiwicGRhdGFPbGQiLCJwZGF0YUN1ciIsInVkYXRhT2xkIiwidWRhdGFDdXIiLCJnZXRBbGwiLCJmaXhJbnB1dCIsImRhdGFBbmRFdmVudHMiLCJkZWVwRGF0YUFuZEV2ZW50cyIsInNyY0VsZW1lbnRzIiwiZGVzdEVsZW1lbnRzIiwiaW5QYWdlIiwiYnVpbGRGcmFnbWVudCIsInNjcmlwdHMiLCJzZWxlY3Rpb24iLCJ3cmFwIiwibm9kZXMiLCJjcmVhdGVUZXh0Tm9kZSIsImNsZWFuRGF0YSIsImFwcGVuZCIsImRvbU1hbmlwIiwicHJlcGVuZCIsImluc2VydEJlZm9yZSIsImJlZm9yZSIsImFmdGVyIiwia2VlcERhdGEiLCJodG1sIiwicmVwbGFjZVdpdGgiLCJyZXBsYWNlQ2hpbGQiLCJkZXRhY2giLCJoYXNTY3JpcHRzIiwiaU5vQ2xvbmUiLCJfZXZhbFVybCIsImFwcGVuZFRvIiwicHJlcGVuZFRvIiwiaW5zZXJ0QWZ0ZXIiLCJyZXBsYWNlQWxsIiwiaW5zZXJ0IiwiaWZyYW1lIiwiZWxlbWRpc3BsYXkiLCJhY3R1YWxEaXNwbGF5Iiwic3R5bGUiLCJkaXNwbGF5IiwiZ2V0RGVmYXVsdENvbXB1dGVkU3R5bGUiLCJkZWZhdWx0RGlzcGxheSIsIndyaXRlIiwiY2xvc2UiLCJybWFyZ2luIiwicm51bW5vbnB4IiwiZ2V0U3R5bGVzIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImN1ckNTUyIsImNvbXB1dGVkIiwid2lkdGgiLCJtaW5XaWR0aCIsIm1heFdpZHRoIiwiZ2V0UHJvcGVydHlWYWx1ZSIsImFkZEdldEhvb2tJZiIsImNvbmRpdGlvbkZuIiwiaG9va0ZuIiwicGl4ZWxQb3NpdGlvblZhbCIsImJveFNpemluZ1JlbGlhYmxlVmFsIiwiY29udGFpbmVyIiwiYmFja2dyb3VuZENsaXAiLCJjbGVhckNsb25lU3R5bGUiLCJjc3NUZXh0IiwiY29tcHV0ZVBpeGVsUG9zaXRpb25BbmRCb3hTaXppbmdSZWxpYWJsZSIsImRpdlN0eWxlIiwicGl4ZWxQb3NpdGlvbiIsImJveFNpemluZ1JlbGlhYmxlIiwicmVsaWFibGVNYXJnaW5SaWdodCIsIm1hcmdpbkRpdiIsIm1hcmdpblJpZ2h0Iiwic3dhcCIsInJkaXNwbGF5c3dhcCIsInJudW1zcGxpdCIsInJyZWxOdW0iLCJjc3NTaG93IiwicG9zaXRpb24iLCJ2aXNpYmlsaXR5IiwiY3NzTm9ybWFsVHJhbnNmb3JtIiwibGV0dGVyU3BhY2luZyIsImZvbnRXZWlnaHQiLCJjc3NQcmVmaXhlcyIsInZlbmRvclByb3BOYW1lIiwiY2FwTmFtZSIsIm9yaWdOYW1lIiwic2V0UG9zaXRpdmVOdW1iZXIiLCJzdWJ0cmFjdCIsIm1heCIsImF1Z21lbnRXaWR0aE9ySGVpZ2h0IiwiZXh0cmEiLCJpc0JvcmRlckJveCIsInN0eWxlcyIsImdldFdpZHRoT3JIZWlnaHQiLCJ2YWx1ZUlzQm9yZGVyQm94Iiwib2Zmc2V0V2lkdGgiLCJvZmZzZXRIZWlnaHQiLCJzaG93SGlkZSIsInNob3ciLCJoaWRkZW4iLCJjc3NIb29rcyIsIm9wYWNpdHkiLCJjc3NOdW1iZXIiLCJjc3NQcm9wcyIsIm1hcmdpbiIsInBhZGRpbmciLCJib3JkZXIiLCJwcmVmaXgiLCJzdWZmaXgiLCJleHBhbmQiLCJleHBhbmRlZCIsInBhcnRzIiwiaGlkZSIsInRvZ2dsZSIsIlR3ZWVuIiwiZWFzaW5nIiwidW5pdCIsInByb3BIb29rcyIsInJ1biIsInBlcmNlbnQiLCJlYXNlZCIsImR1cmF0aW9uIiwic3RlcCIsInR3ZWVuIiwiZngiLCJsaW5lYXIiLCJwIiwic3dpbmciLCJjb3MiLCJQSSIsImZ4Tm93IiwidGltZXJJZCIsInJmeHR5cGVzIiwicmZ4bnVtIiwicnJ1biIsImFuaW1hdGlvblByZWZpbHRlcnMiLCJkZWZhdWx0UHJlZmlsdGVyIiwidHdlZW5lcnMiLCJjcmVhdGVUd2VlbiIsInNjYWxlIiwibWF4SXRlcmF0aW9ucyIsImNyZWF0ZUZ4Tm93IiwiZ2VuRngiLCJpbmNsdWRlV2lkdGgiLCJoZWlnaHQiLCJhbmltYXRpb24iLCJjb2xsZWN0aW9uIiwib3B0cyIsIm9sZGZpcmUiLCJjaGVja0Rpc3BsYXkiLCJhbmltIiwiZGF0YVNob3ciLCJ1bnF1ZXVlZCIsIm92ZXJmbG93Iiwib3ZlcmZsb3dYIiwib3ZlcmZsb3dZIiwicHJvcEZpbHRlciIsInNwZWNpYWxFYXNpbmciLCJBbmltYXRpb24iLCJwcm9wZXJ0aWVzIiwic3RvcHBlZCIsInRpY2siLCJjdXJyZW50VGltZSIsInN0YXJ0VGltZSIsInR3ZWVucyIsIm9yaWdpbmFsUHJvcGVydGllcyIsIm9yaWdpbmFsT3B0aW9ucyIsImdvdG9FbmQiLCJyZWplY3RXaXRoIiwidGltZXIiLCJjb21wbGV0ZSIsInR3ZWVuZXIiLCJwcmVmaWx0ZXIiLCJzcGVlZCIsIm9wdCIsInNwZWVkcyIsImZhZGVUbyIsInRvIiwiYW5pbWF0ZSIsIm9wdGFsbCIsImRvQW5pbWF0aW9uIiwiZmluaXNoIiwic3RvcFF1ZXVlIiwidGltZXJzIiwiY3NzRm4iLCJzbGlkZURvd24iLCJzbGlkZVVwIiwic2xpZGVUb2dnbGUiLCJmYWRlSW4iLCJmYWRlT3V0IiwiZmFkZVRvZ2dsZSIsImludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwic2xvdyIsImZhc3QiLCJkZWxheSIsInRpbWUiLCJ0aW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwiY2hlY2tPbiIsIm9wdFNlbGVjdGVkIiwib3B0RGlzYWJsZWQiLCJyYWRpb1ZhbHVlIiwibm9kZUhvb2siLCJib29sSG9vayIsInJlbW92ZUF0dHIiLCJuVHlwZSIsImF0dHJIb29rcyIsImJvb2wiLCJwcm9wTmFtZSIsImF0dHJOYW1lcyIsInByb3BGaXgiLCJnZXR0ZXIiLCJyZm9jdXNhYmxlIiwicmVtb3ZlUHJvcCIsIm5vdHhtbCIsImhhc0F0dHJpYnV0ZSIsInJjbGFzcyIsImFkZENsYXNzIiwiY2xhc3NlcyIsImNsYXp6IiwiZmluYWxWYWx1ZSIsInByb2NlZWQiLCJyZW1vdmVDbGFzcyIsInRvZ2dsZUNsYXNzIiwic3RhdGVWYWwiLCJjbGFzc05hbWVzIiwiaGFzQ2xhc3MiLCJycmV0dXJuIiwidmFsSG9va3MiLCJvcHRpb25TZXQiLCJob3ZlciIsImZuT3ZlciIsImZuT3V0IiwiYmluZCIsInVuYmluZCIsImRlbGVnYXRlIiwidW5kZWxlZ2F0ZSIsIm5vbmNlIiwicnF1ZXJ5IiwiSlNPTiIsInBhcnNlIiwicGFyc2VYTUwiLCJET01QYXJzZXIiLCJwYXJzZUZyb21TdHJpbmciLCJhamF4TG9jUGFydHMiLCJhamF4TG9jYXRpb24iLCJyaGFzaCIsInJ0cyIsInJoZWFkZXJzIiwicmxvY2FsUHJvdG9jb2wiLCJybm9Db250ZW50IiwicnByb3RvY29sIiwicnVybCIsInByZWZpbHRlcnMiLCJ0cmFuc3BvcnRzIiwiYWxsVHlwZXMiLCJhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMiLCJzdHJ1Y3R1cmUiLCJkYXRhVHlwZUV4cHJlc3Npb24iLCJkYXRhVHlwZSIsImRhdGFUeXBlcyIsImluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzIiwianFYSFIiLCJpbnNwZWN0ZWQiLCJzZWVraW5nVHJhbnNwb3J0IiwiaW5zcGVjdCIsInByZWZpbHRlck9yRmFjdG9yeSIsImRhdGFUeXBlT3JUcmFuc3BvcnQiLCJhamF4RXh0ZW5kIiwiZmxhdE9wdGlvbnMiLCJhamF4U2V0dGluZ3MiLCJhamF4SGFuZGxlUmVzcG9uc2VzIiwicyIsInJlc3BvbnNlcyIsImN0IiwiZmluYWxEYXRhVHlwZSIsImZpcnN0RGF0YVR5cGUiLCJtaW1lVHlwZSIsImdldFJlc3BvbnNlSGVhZGVyIiwiY29udmVydGVycyIsImFqYXhDb252ZXJ0IiwicmVzcG9uc2UiLCJpc1N1Y2Nlc3MiLCJjb252MiIsImN1cnJlbnQiLCJjb252IiwicmVzcG9uc2VGaWVsZHMiLCJkYXRhRmlsdGVyIiwiYWN0aXZlIiwibGFzdE1vZGlmaWVkIiwiZXRhZyIsInVybCIsImlzTG9jYWwiLCJwcm9jZXNzRGF0YSIsImFzeW5jIiwiY29udGVudFR5cGUiLCJqc29uIiwiYWpheFNldHVwIiwic2V0dGluZ3MiLCJhamF4UHJlZmlsdGVyIiwiYWpheFRyYW5zcG9ydCIsImFqYXgiLCJ0cmFuc3BvcnQiLCJjYWNoZVVSTCIsInJlc3BvbnNlSGVhZGVyc1N0cmluZyIsInJlc3BvbnNlSGVhZGVycyIsInRpbWVvdXRUaW1lciIsImZpcmVHbG9iYWxzIiwiY2FsbGJhY2tDb250ZXh0IiwiZ2xvYmFsRXZlbnRDb250ZXh0IiwiY29tcGxldGVEZWZlcnJlZCIsInN0YXR1c0NvZGUiLCJyZXF1ZXN0SGVhZGVycyIsInJlcXVlc3RIZWFkZXJzTmFtZXMiLCJzdHJBYm9ydCIsImdldEFsbFJlc3BvbnNlSGVhZGVycyIsInNldFJlcXVlc3RIZWFkZXIiLCJsbmFtZSIsIm92ZXJyaWRlTWltZVR5cGUiLCJzdGF0dXMiLCJhYm9ydCIsInN0YXR1c1RleHQiLCJmaW5hbFRleHQiLCJzdWNjZXNzIiwibWV0aG9kIiwiY3Jvc3NEb21haW4iLCJwYXJhbSIsInRyYWRpdGlvbmFsIiwiaGFzQ29udGVudCIsImlmTW9kaWZpZWQiLCJoZWFkZXJzIiwiYmVmb3JlU2VuZCIsInNlbmQiLCJuYXRpdmVTdGF0dXNUZXh0IiwibW9kaWZpZWQiLCJnZXRKU09OIiwiZ2V0U2NyaXB0Iiwid3JhcEFsbCIsImZpcnN0RWxlbWVudENoaWxkIiwid3JhcElubmVyIiwidW53cmFwIiwidmlzaWJsZSIsInIyMCIsInJicmFja2V0IiwickNSTEYiLCJyc3VibWl0dGVyVHlwZXMiLCJyc3VibWl0dGFibGUiLCJidWlsZFBhcmFtcyIsInYiLCJlbmNvZGVVUklDb21wb25lbnQiLCJzZXJpYWxpemUiLCJzZXJpYWxpemVBcnJheSIsInhociIsIlhNTEh0dHBSZXF1ZXN0IiwieGhySWQiLCJ4aHJDYWxsYmFja3MiLCJ4aHJTdWNjZXNzU3RhdHVzIiwieGhyU3VwcG9ydGVkIiwiQWN0aXZlWE9iamVjdCIsImNvcnMiLCJvcGVuIiwidXNlcm5hbWUiLCJ4aHJGaWVsZHMiLCJvbmxvYWQiLCJvbmVycm9yIiwicmVzcG9uc2VUZXh0IiwiY2hhcnNldCIsInNjcmlwdENoYXJzZXQiLCJldnQiLCJvbGRDYWxsYmFja3MiLCJyanNvbnAiLCJqc29ucCIsImpzb25wQ2FsbGJhY2siLCJvcmlnaW5hbFNldHRpbmdzIiwiY2FsbGJhY2tOYW1lIiwib3ZlcndyaXR0ZW4iLCJyZXNwb25zZUNvbnRhaW5lciIsImpzb25Qcm9wIiwia2VlcFNjcmlwdHMiLCJwYXJzZWQiLCJfbG9hZCIsInBhcmFtcyIsImFuaW1hdGVkIiwiZ2V0V2luZG93Iiwib2Zmc2V0Iiwic2V0T2Zmc2V0IiwiY3VyUG9zaXRpb24iLCJjdXJMZWZ0IiwiY3VyQ1NTVG9wIiwiY3VyVG9wIiwiY3VyT2Zmc2V0IiwiY3VyQ1NTTGVmdCIsImNhbGN1bGF0ZVBvc2l0aW9uIiwiY3VyRWxlbSIsImxlZnQiLCJ1c2luZyIsIndpbiIsImJveCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInBhZ2VZT2Zmc2V0IiwicGFnZVhPZmZzZXQiLCJvZmZzZXRQYXJlbnQiLCJwYXJlbnRPZmZzZXQiLCJzY3JvbGxUbyIsIkhlaWdodCIsIldpZHRoIiwiZGVmYXVsdEV4dHJhIiwiZnVuY05hbWUiLCJzaXplIiwiYW5kU2VsZiIsImRlZmluZSIsIl9qUXVlcnkiLCJfJCIsIiQiLCJub0NvbmZsaWN0Il0sIm1hcHBpbmdzIjoiOzs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7O0FBY0MsV0FBU0EsTUFBVCxFQUFpQkMsT0FBakIsRUFBMEI7O0FBRXZCLFFBQUksOEJBQU9DLE1BQVAsT0FBa0IsUUFBbEIsSUFBOEIsUUFBT0Es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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQUksSUFBSixFQUFnRDtBQUM1QzBwQixRQUFBLGlDQUFpQixFQUFqQixtQ0FBcUIsWUFBVztBQUM1QixtQkFBTy9oQyxNQUFQO0FBQ0gsU0FGRDtBQUFBO0FBR0g7O0FBS0Q7QUFDQTtBQUNJZ2lDLGNBQVU3aUMsT0FBT2EsTUFGckI7OztBQUlJO0FBQ0FpaUMsU0FBSzlpQyxPQUFPK2lDLENBTGhCOztBQU9BbGlDLFdBQU9taUMsVUFBUCxHQUFvQixVQUFTbC9CLElBQVQsRUFBZTtBQUMvQixZQUFJOUQsT0FBTytpQyxDQUFQLEtBQWFsaUMsTUFBakIsRUFBeUI7QUFDckJiLG1CQUFPK2lDLENBQVAsR0FBV0QsRUFBWDtBQUNIOztBQUVELFlBQUloL0IsUUFBUTlELE9BQU9hLE1BQVAsS0FBa0JBLE1BQTlCLEVBQXNDO0FBQ2xDYixtQkFBT2EsTUFBUCxHQUFnQmdpQyxPQUFoQjtBQUNIOztBQUVELGVBQU9oaUMsTUFBUDtBQUNILEtBVkQ7O0FBWUE7QUFDQTtBQUNBO0FBQ0EsUUFBSSxRQUFPWixRQUFQLHlDQUFPQSxRQUFQLE9BQW9CK0ksWUFBeEIsRUFBc0M7QUFDbENoSixlQUFPYSxNQUFQLEdBQWdCYixPQUFPK2lDLENBQVAsR0FBV2xpQyxNQUEzQjtBQUNIOztBQUtELFdBQU9BLE1BQVA7QUFFSCxDQWo5UkEsQ0FBRCxDIiwiZmlsZSI6IjIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcclxuICogalF1ZXJ5IEphdmFTY3JpcHQgTGlicmFyeSB2Mi4xLjFcclxuICogaHR0cDovL2pxdWVyeS5jb20vXHJcbiAqXHJcbiAqIEluY2x1ZGVzIFNpenpsZS5qc1xyXG4gKiBodHRwOi8vc2l6emxlanMuY29tL1xyXG4gKlxyXG4gKiBDb3B5cmlnaHQgMjAwNSwgMjAxNCBqUXVlcnkgRm91bmRhdGlvbiwgSW5jLiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXHJcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXHJcbiAqXHJcbiAqIERhdGU6IDIwMTQtMDUtMDFUMTc6MTFaXHJcbiAqL1xyXG5cclxuKGZ1bmN0aW9uKGdsb2JhbCwgZmFjdG9yeSkge1xyXG5cclxuICAgIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgIC8vIEZvciBDb21tb25KUyBhbmQgQ29tbW9uSlMtbGlrZSBlbnZpcm9ubWVudHMgd2hlcmUgYSBwcm9wZXIgd2luZG93IGlzIHByZXNlbnQsXHJcbiAgICAgICAgLy8gZXhlY3V0ZSB0aGUgZmFjdG9yeSBhbmQgZ2V0IGpRdWVyeVxyXG4gICAgICAgIC8vIEZvciBlbnZpcm9ubWVudHMgdGhhdCBkbyBub3QgaW5oZXJlbnRseSBwb3NzZXMgYSB3aW5kb3cgd2l0aCBhIGRvY3VtZW50XHJcbiAgICAgICAgLy8gKHN1Y2ggYXMgTm9kZS5qcyksIGV4cG9zZSBhIGpRdWVyeS1tYWtpbmcgZmFjdG9yeSBhcyBtb2R1bGUuZXhwb3J0c1xyXG4gICAgICAgIC8vIFRoaXMgYWNjZW50dWF0ZXMgdGhlIG5lZWQgZm9yIHRoZSBjcmVhdGlvbiBvZiBhIHJlYWwgd2luZG93XHJcbiAgICAgICAgLy8gZS5nLiB2YXIgalF1ZXJ5ID0gcmVxdWlyZShcImpxdWVyeVwiKSh3aW5kb3cpO1xyXG4gICAgICAgIC8vIFNlZSB0aWNrZXQgIzE0NTQ5IGZvciBtb3JlIGluZm9cclxuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGdsb2JhbC5kb2N1bWVudCA/XHJcbiAgICAgICAgICAgIGZhY3RvcnkoZ2xvYmFsLCB0cnVlKSA6XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uKHcpIHtcclxuICAgICAgICAgICAgICAgIGlmICghdy5kb2N1bWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImpRdWVyeSByZXF1aXJlcyBhIHdpbmRvdyB3aXRoIGEgZG9jdW1lbnRcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFjdG9yeSh3KTtcclxuICAgICAgICAgICAgfTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZmFjdG9yeShnbG9iYWwpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFBhc3MgdGhpcyBpZiB3aW5kb3cgaXMgbm90IGRlZmluZWQgeWV0XHJcbn0odHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHRoaXMsIGZ1bmN0aW9uKHdpbmRvdywgbm9HbG9iYWwpIHtcclxuXHJcbiAgICAvLyBDYW4ndCBkbyB0aGlzIGJlY2F1c2Ugc2V2ZXJhbCBhcHBzIGluY2x1ZGluZyBBU1AuTkVUIHRyYWNlXHJcbiAgICAvLyB0aGUgc3RhY2sgdmlhIGFyZ3VtZW50cy5jYWxsZXIuY2FsbGVlIGFuZCBGaXJlZm94IGRpZXMgaWZcclxuICAgIC8vIHlvdSB0cnkgdG8gdHJhY2UgdGhyb3VnaCBcInVzZSBzdHJpY3RcIiBjYWxsIGNoYWlucy4gKCMxMzMzNSlcclxuICAgIC8vIFN1cHBvcnQ6IEZpcmVmb3ggMTgrXHJcbiAgICAvL1xyXG5cclxuICAgIHZhciBhcnIgPSBbXTtcclxuXHJcbiAgICB2YXIgc2xpY2UgPSBhcnIuc2xpY2U7XHJcblxyXG4gICAgdmFyIGNvbmNhdCA9IGFyci5jb25jYXQ7XHJcblxyXG4gICAgdmFyIHB1c2ggPSBhcnIucHVzaDtcclxuXHJcbiAgICB2YXIgaW5kZXhPZiA9IGFyci5pbmRleE9mO1xyXG5cclxuICAgIHZhciBjbGFzczJ0eXBlID0ge307XHJcblxyXG4gICAgdmFyIHRvU3RyaW5nID0gY2xhc3MydHlwZS50b1N0cmluZztcclxuXHJcbiAgICB2YXIgaGFzT3duID0gY2xhc3MydHlwZS5oYXNPd25Qcm9wZXJ0eTtcclxuXHJcbiAgICB2YXIgc3VwcG9ydCA9IHt9O1xyXG5cclxuXHJcblxyXG4gICAgdmFyXHJcbiAgICAvLyBVc2UgdGhlIGNvcnJlY3QgZG9jdW1lbnQgYWNjb3JkaW5nbHkgd2l0aCB3aW5kb3cgYXJndW1lbnQgKHNhbmRib3gpXHJcbiAgICAgICAgZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQsXHJcblxyXG4gICAgICAgIHZlcnNpb24gPSBcIjIuMS4xXCIsXHJcblxyXG4gICAgICAgIC8vIERlZmluZSBhIGxvY2FsIGNvcHkgb2YgalF1ZXJ5XHJcbiAgICAgICAgalF1ZXJ5ID0gZnVuY3Rpb24oc2VsZWN0b3IsIGNvbnRleHQpIHtcclxuICAgICAgICAgICAgLy8gVGhlIGpRdWVyeSBvYmplY3QgaXMgYWN0dWFsbHkganVzdCB0aGUgaW5pdCBjb25zdHJ1Y3RvciAnZW5oYW5jZWQnXHJcbiAgICAgICAgICAgIC8vIE5lZWQgaW5pdCBpZiBqUXVlcnkgaXMgY2FsbGVkIChqdXN0IGFsbG93IGVycm9yIHRvIGJlIHRocm93biBpZiBub3QgaW5jbHVkZWQpXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgalF1ZXJ5LmZuLmluaXQoc2VsZWN0b3IsIGNvbnRleHQpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4xXHJcbiAgICAgICAgLy8gTWFrZSBzdXJlIHdlIHRyaW0gQk9NIGFuZCBOQlNQXHJcbiAgICAgICAgcnRyaW0gPSAvXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2csXHJcblxyXG4gICAgICAgIC8vIE1hdGNoZXMgZGFzaGVkIHN0cmluZyBmb3IgY2FtZWxpemluZ1xyXG4gICAgICAgIHJtc1ByZWZpeCA9IC9eLW1zLS8sXHJcbiAgICAgICAgcmRhc2hBbHBoYSA9IC8tKFtcXGRhLXpdKS9naSxcclxuXHJcbiAgICAgICAgLy8gVXNlZCBieSBqUXVlcnkuY2FtZWxDYXNlIGFzIGNhbGxiYWNrIHRvIHJlcGxhY2UoKVxyXG4gICAgICAgIGZjYW1lbENhc2UgPSBmdW5jdGlvbihhbGwsIGxldHRlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gbGV0dGVyLnRvVXBwZXJDYXNlKCk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICBqUXVlcnkuZm4gPSBqUXVlcnkucHJvdG90eXBlID0ge1xyXG4gICAgICAgIC8vIFRoZSBjdXJyZW50IHZlcnNpb24gb2YgalF1ZXJ5IGJlaW5nIHVzZWRcclxuICAgICAgICBqcXVlcnk6IHZlcnNpb24sXHJcblxyXG4gICAgICAgIGNvbnN0cnVjdG9yOiBqUXVlcnksXHJcblxyXG4gICAgICAgIC8vIFN0YXJ0IHdpdGggYW4gZW1wdHkgc2VsZWN0b3JcclxuICAgICAgICBzZWxlY3RvcjogXCJcIixcclxuXHJcbiAgICAgICAgLy8gVGhlIGRlZmF1bHQgbGVuZ3RoIG9mIGEgalF1ZXJ5IG9iamVjdCBpcyAwXHJcbiAgICAgICAgbGVuZ3RoOiAwLFxyXG5cclxuICAgICAgICB0b0FycmF5OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNsaWNlLmNhbGwodGhpcyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy8gR2V0IHRoZSBOdGggZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBlbGVtZW50IHNldCBPUlxyXG4gICAgICAgIC8vIEdldCB0aGUgd2hvbGUgbWF0Y2hlZCBlbGVtZW50IHNldCBhcyBhIGNsZWFuIGFycmF5XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbihudW0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bSAhPSBudWxsID9cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSZXR1cm4ganVzdCB0aGUgb25lIGVsZW1lbnQgZnJvbSB0aGUgc2V0XHJcbiAgICAgICAgICAgICAgICAobnVtIDwgMCA/IHRoaXNbbnVtICsgdGhpcy5sZW5ndGhdIDogdGhpc1tudW1dKSA6XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgaW4gYSBjbGVhbiBhcnJheVxyXG4gICAgICAgICAgICAgICAgc2xpY2UuY2FsbCh0aGlzKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvLyBUYWtlIGFuIGFycmF5IG9mIGVsZW1lbnRzIGFuZCBwdXNoIGl0IG9udG8gdGhlIHN0YWNrXHJcbiAgICAgICAgLy8gKHJldHVybmluZyB0aGUgbmV3IG1hdGNoZWQgZWxlbWVudCBzZXQpXHJcbiAgICAgICAgcHVzaFN0YWNrOiBmdW5jdGlvbihlbGVtcykge1xyXG5cclxuICAgICAgICAgICAgLy8gQnVpbGQgYSBuZXcgalF1ZXJ5IG1hdGNoZWQgZWxlbWVudCBzZXRcclxuICAgICAgICAgICAgdmFyIHJldCA9IGpRdWVyeS5tZXJnZSh0aGlzLmNvbnN0cnVjdG9yKCksIGVsZW1zKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEFkZCB0aGUgb2xkIG9iamVjdCBvbnRvIHRoZSBzdGFjayAoYXMgYSByZWZlcmVuY2UpXHJcbiAgICAgICAgICAgIHJldC5wcmV2T2JqZWN0ID0gdGhpcztcclxuICAgICAgICAgICAgcmV0LmNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XHJcblxyXG4gICAgICAgICAgICAvLyBSZXR1cm4gdGhlIG5ld2x5LWZvcm1lZCBlbGVtZW50IHNldFxyXG4gICAgICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8vIEV4ZWN1dGUgYSBjYWxsYmFjayBmb3IgZXZlcnkgZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBzZXQuXHJcbiAgICAgICAgLy8gKFlvdSBjYW4gc2VlZCB0aGUgYXJndW1lbnRzIHdpdGggYW4gYXJyYXkgb2YgYXJncywgYnV0IHRoaXMgaXNcclxuICAgICAgICAvLyBvbmx5IHVzZWQgaW50ZXJuYWxseS4pXHJcbiAgICAgICAgZWFjaDogZnVuY3Rpb24oY2FsbGJhY2ssIGFyZ3MpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5lYWNoKHRoaXMsIGNhbGxiYWNrLCBhcmdzKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBtYXA6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayhqUXVlcnkubWFwKHRoaXMsIGZ1bmN0aW9uKGVsZW0sIGkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKGVsZW0sIGksIGVsZW0pO1xyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2xpY2U6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2soc2xpY2UuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZmlyc3Q6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lcSgwKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBsYXN0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXEoLTEpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGVxOiBmdW5jdGlvbihpKSB7XHJcbiAgICAgICAgICAgIHZhciBsZW4gPSB0aGlzLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgIGogPSAraSArIChpIDwgMCA/IGxlbiA6IDApO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2soaiA+PSAwICYmIGogPCBsZW4gPyBbdGhpc1tqXV0gOiBbXSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZW5kOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJldk9iamVjdCB8fCB0aGlzLmNvbnN0cnVjdG9yKG51bGwpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8vIEZvciBpbnRlcm5hbCB1c2Ugb25seS5cclxuICAgICAgICAvLyBCZWhhdmVzIGxpa2UgYW4gQXJyYXkncyBtZXRob2QsIG5vdCBsaWtlIGEgalF1ZXJ5IG1ldGhvZC5cclxuICAgICAgICBwdXNoOiBwdXNoLFxyXG4gICAgICAgIHNvcnQ6IGFyci5zb3J0LFxyXG4gICAgICAgIHNwbGljZTogYXJyLnNwbGljZVxyXG4gICAgfTtcclxuXHJcbiAgICBqUXVlcnkuZXh0ZW5kID0galF1ZXJ5LmZuLmV4dGVuZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBvcHRpb25zLCBuYW1lLCBzcmMsIGNvcHksIGNvcHlJc0FycmF5LCBjbG9uZSxcclxuICAgICAgICAgICAgdGFyZ2V0ID0gYXJndW1lbnRzWzBdIHx8IHt9LFxyXG4gICAgICAgICAgICBpID0gMSxcclxuICAgICAgICAgICAgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcclxuICAgICAgICAgICAgZGVlcCA9IGZhbHNlO1xyXG5cclxuICAgICAgICAvLyBIYW5kbGUgYSBkZWVwIGNvcHkgc2l0dWF0aW9uXHJcbiAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgPT09IFwiYm9vbGVhblwiKSB7XHJcbiAgICAgICAgICAgIGRlZXAgPSB0YXJnZXQ7XHJcblxyXG4gICAgICAgICAgICAvLyBza2lwIHRoZSBib29sZWFuIGFuZCB0aGUgdGFyZ2V0XHJcbiAgICAgICAgICAgIHRhcmdldCA9IGFyZ3VtZW50c1tpXSB8fCB7fTtcclxuICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSGFuZGxlIGNhc2Ugd2hlbiB0YXJnZXQgaXMgYSBzdHJpbmcgb3Igc29tZXRoaW5nIChwb3NzaWJsZSBpbiBkZWVwIGNvcHkpXHJcbiAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgIT09IFwib2JqZWN0XCIgJiYgIWpRdWVyeS5pc0Z1bmN0aW9uKHRhcmdldCkpIHtcclxuICAgICAgICAgICAgdGFyZ2V0ID0ge307XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBleHRlbmQgalF1ZXJ5IGl0c2VsZiBpZiBvbmx5IG9uZSBhcmd1bWVudCBpcyBwYXNzZWRcclxuICAgICAgICBpZiAoaSA9PT0gbGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRhcmdldCA9IHRoaXM7XHJcbiAgICAgICAgICAgIGktLTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgLy8gT25seSBkZWFsIHdpdGggbm9uLW51bGwvdW5kZWZpbmVkIHZhbHVlc1xyXG4gICAgICAgICAgICBpZiAoKG9wdGlvbnMgPSBhcmd1bWVudHNbaV0pICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIC8vIEV4dGVuZCB0aGUgYmFzZSBvYmplY3RcclxuICAgICAgICAgICAgICAgIGZvciAobmFtZSBpbiBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3JjID0gdGFyZ2V0W25hbWVdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvcHkgPSBvcHRpb25zW25hbWVdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IG5ldmVyLWVuZGluZyBsb29wXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldCA9PT0gY29weSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlY3Vyc2UgaWYgd2UncmUgbWVyZ2luZyBwbGFpbiBvYmplY3RzIG9yIGFycmF5c1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWVwICYmIGNvcHkgJiYgKGpRdWVyeS5pc1BsYWluT2JqZWN0KGNvcHkpIHx8IChjb3B5SXNBcnJheSA9IGpRdWVyeS5pc0FycmF5KGNvcHkpKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvcHlJc0FycmF5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3B5SXNBcnJheSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmUgPSBzcmMgJiYgalF1ZXJ5LmlzQXJyYXkoc3JjKSA/IHNyYyA6IFtdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lID0gc3JjICYmIGpRdWVyeS5pc1BsYWluT2JqZWN0KHNyYykgPyBzcmMgOiB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtuYW1lXSA9IGpRdWVyeS5leHRlbmQoZGVlcCwgY2xvbmUsIGNvcHkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgYnJpbmcgaW4gdW5kZWZpbmVkIHZhbHVlc1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29weSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtuYW1lXSA9IGNvcHk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZXR1cm4gdGhlIG1vZGlmaWVkIG9iamVjdFxyXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgICB9O1xyXG5cclxuICAgIGpRdWVyeS5leHRlbmQoe1xyXG4gICAgICAgIC8vIFVuaXF1ZSBmb3IgZWFjaCBjb3B5IG9mIGpRdWVyeSBvbiB0aGUgcGFnZVxyXG4gICAgICAgIGV4cGFuZG86IFwialF1ZXJ5XCIgKyAodmVyc2lvbiArIE1hdGgucmFuZG9tKCkpLnJlcGxhY2UoL1xcRC9nLCBcIlwiKSxcclxuXHJcbiAgICAgICAgLy8gQXNzdW1lIGpRdWVyeSBpcyByZWFkeSB3aXRob3V0IHRoZSByZWFkeSBtb2R1bGVcclxuICAgICAgICBpc1JlYWR5OiB0cnVlLFxyXG5cclxuICAgICAgICBlcnJvcjogZnVuY3Rpb24obXNnKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIG5vb3A6IGZ1bmN0aW9uKCkge30sXHJcblxyXG4gICAgICAgIC8vIFNlZSB0ZXN0L3VuaXQvY29yZS5qcyBmb3IgZGV0YWlscyBjb25jZXJuaW5nIGlzRnVuY3Rpb24uXHJcbiAgICAgICAgLy8gU2luY2UgdmVyc2lvbiAxLjMsIERPTSBtZXRob2RzIGFuZCBmdW5jdGlvbnMgbGlrZSBhbGVydFxyXG4gICAgICAgIC8vIGFyZW4ndCBzdXBwb3J0ZWQuIFRoZXkgcmV0dXJuIGZhbHNlIG9uIElFICgjMjk2OCkuXHJcbiAgICAgICAgaXNGdW5jdGlvbjogZnVuY3Rpb24ob2JqKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkudHlwZShvYmopID09PSBcImZ1bmN0aW9uXCI7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgaXNBcnJheTogQXJyYXkuaXNBcnJheSxcclxuXHJcbiAgICAgICAgaXNXaW5kb3c6IGZ1bmN0aW9uKG9iaikge1xyXG4gICAgICAgICAgICByZXR1cm4gb2JqICE9IG51bGwgJiYgb2JqID09PSBvYmoud2luZG93O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGlzTnVtZXJpYzogZnVuY3Rpb24ob2JqKSB7XHJcbiAgICAgICAgICAgIC8vIHBhcnNlRmxvYXQgTmFOcyBudW1lcmljLWNhc3QgZmFsc2UgcG9zaXRpdmVzIChudWxsfHRydWV8ZmFsc2V8XCJcIilcclxuICAgICAgICAgICAgLy8gLi4uYnV0IG1pc2ludGVycHJldHMgbGVhZGluZy1udW1iZXIgc3RyaW5ncywgcGFydGljdWxhcmx5IGhleCBsaXRlcmFscyAoXCIweC4uLlwiKVxyXG4gICAgICAgICAgICAvLyBzdWJ0cmFjdGlvbiBmb3JjZXMgaW5maW5pdGllcyB0byBOYU5cclxuICAgICAgICAgICAgcmV0dXJuICFqUXVlcnkuaXNBcnJheShvYmopICYmIG9iaiAtIHBhcnNlRmxvYXQob2JqKSA+PSAwO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGlzUGxhaW5PYmplY3Q6IGZ1bmN0aW9uKG9iaikge1xyXG4gICAgICAgICAgICAvLyBOb3QgcGxhaW4gb2JqZWN0czpcclxuICAgICAgICAgICAgLy8gLSBBbnkgb2JqZWN0IG9yIHZhbHVlIHdob3NlIGludGVybmFsIFtbQ2xhc3NdXSBwcm9wZXJ0eSBpcyBub3QgXCJbb2JqZWN0IE9iamVjdF1cIlxyXG4gICAgICAgICAgICAvLyAtIERPTSBub2Rlc1xyXG4gICAgICAgICAgICAvLyAtIHdpbmRvd1xyXG4gICAgICAgICAgICBpZiAoalF1ZXJ5LnR5cGUob2JqKSAhPT0gXCJvYmplY3RcIiB8fCBvYmoubm9kZVR5cGUgfHwgalF1ZXJ5LmlzV2luZG93KG9iaikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKG9iai5jb25zdHJ1Y3RvciAmJlxyXG4gICAgICAgICAgICAgICAgIWhhc093bi5jYWxsKG9iai5jb25zdHJ1Y3Rvci5wcm90b3R5cGUsIFwiaXNQcm90b3R5cGVPZlwiKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBJZiB0aGUgZnVuY3Rpb24gaGFzbid0IHJldHVybmVkIGFscmVhZHksIHdlJ3JlIGNvbmZpZGVudCB0aGF0XHJcbiAgICAgICAgICAgIC8vIHxvYmp8IGlzIGEgcGxhaW4gb2JqZWN0LCBjcmVhdGVkIGJ5IHt9IG9yIGNvbnN0cnVjdGVkIHdpdGggbmV3IE9iamVjdFxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBpc0VtcHR5T2JqZWN0OiBmdW5jdGlvbihvYmopIHtcclxuICAgICAgICAgICAgdmFyIG5hbWU7XHJcbiAgICAgICAgICAgIGZvciAobmFtZSBpbiBvYmopIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICB0eXBlOiBmdW5jdGlvbihvYmopIHtcclxuICAgICAgICAgICAgaWYgKG9iaiA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqICsgXCJcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBTdXBwb3J0OiBBbmRyb2lkIDwgNC4wLCBpT1MgPCA2IChmdW5jdGlvbmlzaCBSZWdFeHApXHJcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIiA/XHJcbiAgICAgICAgICAgICAgICBjbGFzczJ0eXBlW3RvU3RyaW5nLmNhbGwob2JqKV0gfHwgXCJvYmplY3RcIiA6XHJcbiAgICAgICAgICAgICAgICB0eXBlb2Ygb2JqO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8vIEV2YWx1YXRlcyBhIHNjcmlwdCBpbiBhIGdsb2JhbCBjb250ZXh0XHJcbiAgICAgICAgZ2xvYmFsRXZhbDogZnVuY3Rpb24oY29kZSkge1xyXG4gICAgICAgICAgICB2YXIgc2NyaXB0LFxyXG4gICAgICAgICAgICAgICAgaW5kaXJlY3QgPSBldmFsO1xyXG5cclxuICAgICAgICAgICAgY29kZSA9IGpRdWVyeS50cmltKGNvZGUpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGNvZGUpIHtcclxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjb2RlIGluY2x1ZGVzIGEgdmFsaWQsIHByb2xvZ3VlIHBvc2l0aW9uXHJcbiAgICAgICAgICAgICAgICAvLyBzdHJpY3QgbW9kZSBwcmFnbWEsIGV4ZWN1dGUgY29kZSBieSBpbmplY3RpbmcgYVxyXG4gICAgICAgICAgICAgICAgLy8gc2NyaXB0IHRhZyBpbnRvIHRoZSBkb2N1bWVudC5cclxuICAgICAgICAgICAgICAgIGlmIChjb2RlLmluZGV4T2YoXCJ1c2Ugc3RyaWN0XCIpID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcclxuICAgICAgICAgICAgICAgICAgICBzY3JpcHQudGV4dCA9IGNvZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBhdm9pZCB0aGUgRE9NIG5vZGUgY3JlYXRpb24sIGluc2VydGlvblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCByZW1vdmFsIGJ5IHVzaW5nIGFuIGluZGlyZWN0IGdsb2JhbCBldmFsXHJcbiAgICAgICAgICAgICAgICAgICAgaW5kaXJlY3QoY29kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvLyBDb252ZXJ0IGRhc2hlZCB0byBjYW1lbENhc2U7IHVzZWQgYnkgdGhlIGNzcyBhbmQgZGF0YSBtb2R1bGVzXHJcbiAgICAgICAgLy8gTWljcm9zb2Z0IGZvcmdvdCB0byBodW1wIHRoZWlyIHZlbmRvciBwcmVmaXggKCM5NTcyKVxyXG4gICAgICAgIGNhbWVsQ2FzZTogZnVuY3Rpb24oc3RyaW5nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZShybXNQcmVmaXgsIFwibXMtXCIpLnJlcGxhY2UocmRhc2hBbHBoYSwgZmNhbWVsQ2FzZSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgbm9kZU5hbWU6IGZ1bmN0aW9uKGVsZW0sIG5hbWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy8gYXJncyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxyXG4gICAgICAgIGVhY2g6IGZ1bmN0aW9uKG9iaiwgY2FsbGJhY2ssIGFyZ3MpIHtcclxuICAgICAgICAgICAgdmFyIHZhbHVlLFxyXG4gICAgICAgICAgICAgICAgaSA9IDAsXHJcbiAgICAgICAgICAgICAgICBsZW5ndGggPSBvYmoubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgaXNBcnJheSA9IGlzQXJyYXlsaWtlKG9iaik7XHJcblxyXG4gICAgICAgICAgICBpZiAoYXJncykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzQXJyYXkpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gY2FsbGJhY2suYXBwbHkob2JqW2ldLCBhcmdzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgaW4gb2JqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gY2FsbGJhY2suYXBwbHkob2JqW2ldLCBhcmdzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIEEgc3BlY2lhbCwgZmFzdCwgY2FzZSBmb3IgdGhlIG1vc3QgY29tbW9uIHVzZSBvZiBlYWNoXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNBcnJheSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBjYWxsYmFjay5jYWxsKG9ialtpXSwgaSwgb2JqW2ldKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgaW4gb2JqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gY2FsbGJhY2suY2FsbChvYmpbaV0sIGksIG9ialtpXSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG9iajtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMVxyXG4gICAgICAgIHRyaW06IGZ1bmN0aW9uKHRleHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRleHQgPT0gbnVsbCA/XHJcbiAgICAgICAgICAgICAgICBcIlwiIDpcclxuICAgICAgICAgICAgICAgICh0ZXh0ICsgXCJcIikucmVwbGFjZShydHJpbSwgXCJcIik7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy8gcmVzdWx0cyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxyXG4gICAgICAgIG1ha2VBcnJheTogZnVuY3Rpb24oYXJyLCByZXN1bHRzKSB7XHJcbiAgICAgICAgICAgIHZhciByZXQgPSByZXN1bHRzIHx8IFtdO1xyXG5cclxuICAgICAgICAgICAgaWYgKGFyciAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNBcnJheWxpa2UoT2JqZWN0KGFycikpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5Lm1lcmdlKHJldCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGFyciA9PT0gXCJzdHJpbmdcIiA/IFthcnJdIDogYXJyXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHVzaC5jYWxsKHJldCwgYXJyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBpbkFycmF5OiBmdW5jdGlvbihlbGVtLCBhcnIsIGkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFyciA9PSBudWxsID8gLTEgOiBpbmRleE9mLmNhbGwoYXJyLCBlbGVtLCBpKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBtZXJnZTogZnVuY3Rpb24oZmlyc3QsIHNlY29uZCkge1xyXG4gICAgICAgICAgICB2YXIgbGVuID0gK3NlY29uZC5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICBqID0gMCxcclxuICAgICAgICAgICAgICAgIGkgPSBmaXJzdC5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICBmb3IgKDsgaiA8IGxlbjsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICBmaXJzdFtpKytdID0gc2Vjb25kW2pdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmaXJzdC5sZW5ndGggPSBpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGZpcnN0O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGdyZXA6IGZ1bmN0aW9uKGVsZW1zLCBjYWxsYmFjaywgaW52ZXJ0KSB7XHJcbiAgICAgICAgICAgIHZhciBjYWxsYmFja0ludmVyc2UsXHJcbiAgICAgICAgICAgICAgICBtYXRjaGVzID0gW10sXHJcbiAgICAgICAgICAgICAgICBpID0gMCxcclxuICAgICAgICAgICAgICAgIGxlbmd0aCA9IGVsZW1zLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrRXhwZWN0ID0gIWludmVydDtcclxuXHJcbiAgICAgICAgICAgIC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCBvbmx5IHNhdmluZyB0aGUgaXRlbXNcclxuICAgICAgICAgICAgLy8gdGhhdCBwYXNzIHRoZSB2YWxpZGF0b3IgZnVuY3Rpb25cclxuICAgICAgICAgICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2tJbnZlcnNlID0gIWNhbGxiYWNrKGVsZW1zW2ldLCBpKTtcclxuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFja0ludmVyc2UgIT09IGNhbGxiYWNrRXhwZWN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcy5wdXNoKGVsZW1zW2ldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXM7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy8gYXJnIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XHJcbiAgICAgICAgbWFwOiBmdW5jdGlvbihlbGVtcywgY2FsbGJhY2ssIGFyZykge1xyXG4gICAgICAgICAgICB2YXIgdmFsdWUsXHJcbiAgICAgICAgICAgICAgICBpID0gMCxcclxuICAgICAgICAgICAgICAgIGxlbmd0aCA9IGVsZW1zLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgIGlzQXJyYXkgPSBpc0FycmF5bGlrZShlbGVtcyksXHJcbiAgICAgICAgICAgICAgICByZXQgPSBbXTtcclxuXHJcbiAgICAgICAgICAgIC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCB0cmFuc2xhdGluZyBlYWNoIG9mIHRoZSBpdGVtcyB0byB0aGVpciBuZXcgdmFsdWVzXHJcbiAgICAgICAgICAgIGlmIChpc0FycmF5KSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBjYWxsYmFjayhlbGVtc1tpXSwgaSwgYXJnKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2godmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBHbyB0aHJvdWdoIGV2ZXJ5IGtleSBvbiB0aGUgb2JqZWN0LFxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpIGluIGVsZW1zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBjYWxsYmFjayhlbGVtc1tpXSwgaSwgYXJnKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2godmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xyXG4gICAgICAgICAgICByZXR1cm4gY29uY2F0LmFwcGx5KFtdLCByZXQpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8vIEEgZ2xvYmFsIEdVSUQgY291bnRlciBmb3Igb2JqZWN0c1xyXG4gICAgICAgIGd1aWQ6IDEsXHJcblxyXG4gICAgICAgIC8vIEJpbmQgYSBmdW5jdGlvbiB0byBhIGNvbnRleHQsIG9wdGlvbmFsbHkgcGFydGlhbGx5IGFwcGx5aW5nIGFueVxyXG4gICAgICAgIC8vIGFyZ3VtZW50cy5cclxuICAgICAgICBwcm94eTogZnVuY3Rpb24oZm4sIGNvbnRleHQpIHtcclxuICAgICAgICAgICAgdmFyIHRtcCwgYXJncywgcHJveHk7XHJcblxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRleHQgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgICAgIHRtcCA9IGZuW2NvbnRleHRdO1xyXG4gICAgICAgICAgICAgICAgY29udGV4dCA9IGZuO1xyXG4gICAgICAgICAgICAgICAgZm4gPSB0bXA7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFF1aWNrIGNoZWNrIHRvIGRldGVybWluZSBpZiB0YXJnZXQgaXMgY2FsbGFibGUsIGluIHRoZSBzcGVjXHJcbiAgICAgICAgICAgIC8vIHRoaXMgdGhyb3dzIGEgVHlwZUVycm9yLCBidXQgd2Ugd2lsbCBqdXN0IHJldHVybiB1bmRlZmluZWQuXHJcbiAgICAgICAgICAgIGlmICghalF1ZXJ5LmlzRnVuY3Rpb24oZm4pKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBTaW11bGF0ZWQgYmluZFxyXG4gICAgICAgICAgICBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xyXG4gICAgICAgICAgICBwcm94eSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KGNvbnRleHQgfHwgdGhpcywgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvLyBTZXQgdGhlIGd1aWQgb2YgdW5pcXVlIGhhbmRsZXIgdG8gdGhlIHNhbWUgb2Ygb3JpZ2luYWwgaGFuZGxlciwgc28gaXQgY2FuIGJlIHJlbW92ZWRcclxuICAgICAgICAgICAgcHJveHkuZ3VpZCA9IGZuLmd1aWQgPSBmbi5ndWlkIHx8IGpRdWVyeS5ndWlkKys7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcHJveHk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgbm93OiBEYXRlLm5vdyxcclxuXHJcbiAgICAgICAgLy8galF1ZXJ5LnN1cHBvcnQgaXMgbm90IHVzZWQgaW4gQ29yZSBidXQgb3RoZXIgcHJvamVjdHMgYXR0YWNoIHRoZWlyXHJcbiAgICAgICAgLy8gcHJvcGVydGllcyB0byBpdCBzbyBpdCBuZWVkcyB0byBleGlzdC5cclxuICAgICAgICBzdXBwb3J0OiBzdXBwb3J0XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBQb3B1bGF0ZSB0aGUgY2xhc3MydHlwZSBtYXBcclxuICAgIGpRdWVyeS5lYWNoKFwiQm9vbGVhbiBOdW1iZXIgU3RyaW5nIEZ1bmN0aW9uIEFycmF5IERhdGUgUmVnRXhwIE9iamVjdCBFcnJvclwiLnNwbGl0KFwiIFwiKSwgZnVuY3Rpb24oaSwgbmFtZSkge1xyXG4gICAgICAgIGNsYXNzMnR5cGVbXCJbb2JqZWN0IFwiICsgbmFtZSArIFwiXVwiXSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGZ1bmN0aW9uIGlzQXJyYXlsaWtlKG9iaikge1xyXG4gICAgICAgIHZhciBsZW5ndGggPSBvYmoubGVuZ3RoLFxyXG4gICAgICAgICAgICB0eXBlID0galF1ZXJ5LnR5cGUob2JqKTtcclxuXHJcbiAgICAgICAgaWYgKHR5cGUgPT09IFwiZnVuY3Rpb25cIiB8fCBqUXVlcnkuaXNXaW5kb3cob2JqKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAob2JqLm5vZGVUeXBlID09PSAxICYmIGxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0eXBlID09PSBcImFycmF5XCIgfHwgbGVuZ3RoID09PSAwIHx8XHJcbiAgICAgICAgICAgIHR5cGVvZiBsZW5ndGggPT09IFwibnVtYmVyXCIgJiYgbGVuZ3RoID4gMCAmJiAobGVuZ3RoIC0gMSkgaW4gb2JqO1xyXG4gICAgfVxyXG4gICAgdmFyIFNpenpsZSA9XHJcbiAgICAgICAgLyohXHJcbiAgICAgICAgICogU2l6emxlIENTUyBTZWxlY3RvciBFbmdpbmUgdjEuMTAuMTlcclxuICAgICAgICAgKiBodHRwOi8vc2l6emxlanMuY29tL1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQ29weXJpZ2h0IDIwMTMgalF1ZXJ5IEZvdW5kYXRpb24sIEluYy4gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xyXG4gICAgICAgICAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gICAgICAgICAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIERhdGU6IDIwMTQtMDQtMThcclxuICAgICAgICAgKi9cclxuICAgICAgICAoZnVuY3Rpb24od2luZG93KSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgaSxcclxuICAgICAgICAgICAgICAgIHN1cHBvcnQsXHJcbiAgICAgICAgICAgICAgICBFeHByLFxyXG4gICAgICAgICAgICAgICAgZ2V0VGV4dCxcclxuICAgICAgICAgICAgICAgIGlzWE1MLFxyXG4gICAgICAgICAgICAgICAgdG9rZW5pemUsXHJcbiAgICAgICAgICAgICAgICBjb21waWxlLFxyXG4gICAgICAgICAgICAgICAgc2VsZWN0LFxyXG4gICAgICAgICAgICAgICAgb3V0ZXJtb3N0Q29udGV4dCxcclxuICAgICAgICAgICAgICAgIHNvcnRJbnB1dCxcclxuICAgICAgICAgICAgICAgIGhhc0R1cGxpY2F0ZSxcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBMb2NhbCBkb2N1bWVudCB2YXJzXHJcbiAgICAgICAgICAgICAgICBzZXREb2N1bWVudCxcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50LFxyXG4gICAgICAgICAgICAgICAgZG9jRWxlbSxcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50SXNIVE1MLFxyXG4gICAgICAgICAgICAgICAgcmJ1Z2d5UVNBLFxyXG4gICAgICAgICAgICAgICAgcmJ1Z2d5TWF0Y2hlcyxcclxuICAgICAgICAgICAgICAgIG1hdGNoZXMsXHJcbiAgICAgICAgICAgICAgICBjb250YWlucyxcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJbnN0YW5jZS1zcGVjaWZpYyBkYXRhXHJcbiAgICAgICAgICAgICAgICBleHBhbmRvID0gXCJzaXp6bGVcIiArIC0obmV3IERhdGUoKSksXHJcbiAgICAgICAgICAgICAgICBwcmVmZXJyZWREb2MgPSB3aW5kb3cuZG9jdW1lbnQsXHJcbiAgICAgICAgICAgICAgICBkaXJydW5zID0gMCxcclxuICAgICAgICAgICAgICAgIGRvbmUgPSAwLFxyXG4gICAgICAgICAgICAgICAgY2xhc3NDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXHJcbiAgICAgICAgICAgICAgICB0b2tlbkNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcclxuICAgICAgICAgICAgICAgIGNvbXBpbGVyQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxyXG4gICAgICAgICAgICAgICAgc29ydE9yZGVyID0gZnVuY3Rpb24oYSwgYikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhID09PSBiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc0R1cGxpY2F0ZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBHZW5lcmFsLXB1cnBvc2UgY29uc3RhbnRzXHJcbiAgICAgICAgICAgICAgICBzdHJ1bmRlZmluZWQgPSB0eXBlb2YgdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgTUFYX05FR0FUSVZFID0gMSA8PCAzMSxcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJbnN0YW5jZSBtZXRob2RzXHJcbiAgICAgICAgICAgICAgICBoYXNPd24gPSAoe30pLmhhc093blByb3BlcnR5LFxyXG4gICAgICAgICAgICAgICAgYXJyID0gW10sXHJcbiAgICAgICAgICAgICAgICBwb3AgPSBhcnIucG9wLFxyXG4gICAgICAgICAgICAgICAgcHVzaF9uYXRpdmUgPSBhcnIucHVzaCxcclxuICAgICAgICAgICAgICAgIHB1c2ggPSBhcnIucHVzaCxcclxuICAgICAgICAgICAgICAgIHNsaWNlID0gYXJyLnNsaWNlLFxyXG4gICAgICAgICAgICAgICAgLy8gVXNlIGEgc3RyaXBwZWQtZG93biBpbmRleE9mIGlmIHdlIGNhbid0IHVzZSBhIG5hdGl2ZSBvbmVcclxuICAgICAgICAgICAgICAgIGluZGV4T2YgPSBhcnIuaW5kZXhPZiB8fCBmdW5jdGlvbihlbGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZW4gPSB0aGlzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzW2ldID09PSBlbGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIGJvb2xlYW5zID0gXCJjaGVja2VkfHNlbGVjdGVkfGFzeW5jfGF1dG9mb2N1c3xhdXRvcGxheXxjb250cm9sc3xkZWZlcnxkaXNhYmxlZHxoaWRkZW58aXNtYXB8bG9vcHxtdWx0aXBsZXxvcGVufHJlYWRvbmx5fHJlcXVpcmVkfHNjb3BlZFwiLFxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFJlZ3VsYXIgZXhwcmVzc2lvbnNcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBXaGl0ZXNwYWNlIGNoYXJhY3RlcnMgaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1zZWxlY3RvcnMvI3doaXRlc3BhY2VcclxuICAgICAgICAgICAgICAgIHdoaXRlc3BhY2UgPSBcIltcXFxceDIwXFxcXHRcXFxcclxcXFxuXFxcXGZdXCIsXHJcbiAgICAgICAgICAgICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXN5bnRheC8jY2hhcmFjdGVyc1xyXG4gICAgICAgICAgICAgICAgY2hhcmFjdGVyRW5jb2RpbmcgPSBcIig/OlxcXFxcXFxcLnxbXFxcXHctXXxbXlxcXFx4MDAtXFxcXHhhMF0pK1wiLFxyXG5cclxuICAgICAgICAgICAgICAgIC8vIExvb3NlbHkgbW9kZWxlZCBvbiBDU1MgaWRlbnRpZmllciBjaGFyYWN0ZXJzXHJcbiAgICAgICAgICAgICAgICAvLyBBbiB1bnF1b3RlZCB2YWx1ZSBzaG91bGQgYmUgYSBDU1MgaWRlbnRpZmllciBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXNlbGVjdG9ycy8jYXR0cmlidXRlLXNlbGVjdG9yc1xyXG4gICAgICAgICAgICAgICAgLy8gUHJvcGVyIHN5bnRheDogaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI3ZhbHVlLWRlZi1pZGVudGlmaWVyXHJcbiAgICAgICAgICAgICAgICBpZGVudGlmaWVyID0gY2hhcmFjdGVyRW5jb2RpbmcucmVwbGFjZShcIndcIiwgXCJ3I1wiKSxcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBBdHRyaWJ1dGUgc2VsZWN0b3JzOiBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2F0dHJpYnV0ZS1zZWxlY3RvcnNcclxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMgPSBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFwiICsgY2hhcmFjdGVyRW5jb2RpbmcgKyBcIikoPzpcIiArIHdoaXRlc3BhY2UgK1xyXG4gICAgICAgICAgICAgICAgLy8gT3BlcmF0b3IgKGNhcHR1cmUgMilcclxuICAgICAgICAgICAgICAgIFwiKihbKl4kfCF+XT89KVwiICsgd2hpdGVzcGFjZSArXHJcbiAgICAgICAgICAgICAgICAvLyBcIkF0dHJpYnV0ZSB2YWx1ZXMgbXVzdCBiZSBDU1MgaWRlbnRpZmllcnMgW2NhcHR1cmUgNV0gb3Igc3RyaW5ncyBbY2FwdHVyZSAzIG9yIGNhcHR1cmUgNF1cIlxyXG4gICAgICAgICAgICAgICAgXCIqKD86JygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwifChcIiArIGlkZW50aWZpZXIgKyBcIikpfClcIiArIHdoaXRlc3BhY2UgK1xyXG4gICAgICAgICAgICAgICAgXCIqXFxcXF1cIixcclxuXHJcbiAgICAgICAgICAgICAgICBwc2V1ZG9zID0gXCI6KFwiICsgY2hhcmFjdGVyRW5jb2RpbmcgKyBcIikoPzpcXFxcKChcIiArXHJcbiAgICAgICAgICAgICAgICAvLyBUbyByZWR1Y2UgdGhlIG51bWJlciBvZiBzZWxlY3RvcnMgbmVlZGluZyB0b2tlbml6ZSBpbiB0aGUgcHJlRmlsdGVyLCBwcmVmZXIgYXJndW1lbnRzOlxyXG4gICAgICAgICAgICAgICAgLy8gMS4gcXVvdGVkIChjYXB0dXJlIDM7IGNhcHR1cmUgNCBvciBjYXB0dXJlIDUpXHJcbiAgICAgICAgICAgICAgICBcIignKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCIpfFwiICtcclxuICAgICAgICAgICAgICAgIC8vIDIuIHNpbXBsZSAoY2FwdHVyZSA2KVxyXG4gICAgICAgICAgICAgICAgXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKVtcXFxcXV18XCIgKyBhdHRyaWJ1dGVzICsgXCIpKil8XCIgK1xyXG4gICAgICAgICAgICAgICAgLy8gMy4gYW55dGhpbmcgZWxzZSAoY2FwdHVyZSAyKVxyXG4gICAgICAgICAgICAgICAgXCIuKlwiICtcclxuICAgICAgICAgICAgICAgIFwiKVxcXFwpfClcIixcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBMZWFkaW5nIGFuZCBub24tZXNjYXBlZCB0cmFpbGluZyB3aGl0ZXNwYWNlLCBjYXB0dXJpbmcgc29tZSBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXJzIHByZWNlZGluZyB0aGUgbGF0dGVyXHJcbiAgICAgICAgICAgICAgICBydHJpbSA9IG5ldyBSZWdFeHAoXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIrfCgoPzpefFteXFxcXFxcXFxdKSg/OlxcXFxcXFxcLikqKVwiICsgd2hpdGVzcGFjZSArIFwiKyRcIiwgXCJnXCIpLFxyXG5cclxuICAgICAgICAgICAgICAgIHJjb21tYSA9IG5ldyBSZWdFeHAoXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqLFwiICsgd2hpdGVzcGFjZSArIFwiKlwiKSxcclxuICAgICAgICAgICAgICAgIHJjb21iaW5hdG9ycyA9IG5ldyBSZWdFeHAoXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFs+K35dfFwiICsgd2hpdGVzcGFjZSArIFwiKVwiICsgd2hpdGVzcGFjZSArIFwiKlwiKSxcclxuXHJcbiAgICAgICAgICAgICAgICByYXR0cmlidXRlUXVvdGVzID0gbmV3IFJlZ0V4cChcIj1cIiArIHdoaXRlc3BhY2UgKyBcIiooW15cXFxcXSdcXFwiXSo/KVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFxdXCIsIFwiZ1wiKSxcclxuXHJcbiAgICAgICAgICAgICAgICBycHNldWRvID0gbmV3IFJlZ0V4cChwc2V1ZG9zKSxcclxuICAgICAgICAgICAgICAgIHJpZGVudGlmaWVyID0gbmV3IFJlZ0V4cChcIl5cIiArIGlkZW50aWZpZXIgKyBcIiRcIiksXHJcblxyXG4gICAgICAgICAgICAgICAgbWF0Y2hFeHByID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIFwiSURcIjogbmV3IFJlZ0V4cChcIl4jKFwiICsgY2hhcmFjdGVyRW5jb2RpbmcgKyBcIilcIiksXHJcbiAgICAgICAgICAgICAgICAgICAgXCJDTEFTU1wiOiBuZXcgUmVnRXhwKFwiXlxcXFwuKFwiICsgY2hhcmFjdGVyRW5jb2RpbmcgKyBcIilcIiksXHJcbiAgICAgICAgICAgICAgICAgICAgXCJUQUdcIjogbmV3IFJlZ0V4cChcIl4oXCIgKyBjaGFyYWN0ZXJFbmNvZGluZy5yZXBsYWNlKFwid1wiLCBcIncqXCIpICsgXCIpXCIpLFxyXG4gICAgICAgICAgICAgICAgICAgIFwiQVRUUlwiOiBuZXcgUmVnRXhwKFwiXlwiICsgYXR0cmlidXRlcyksXHJcbiAgICAgICAgICAgICAgICAgICAgXCJQU0VVRE9cIjogbmV3IFJlZ0V4cChcIl5cIiArIHBzZXVkb3MpLFxyXG4gICAgICAgICAgICAgICAgICAgIFwiQ0hJTERcIjogbmV3IFJlZ0V4cChcIl46KG9ubHl8Zmlyc3R8bGFzdHxudGh8bnRoLWxhc3QpLShjaGlsZHxvZi10eXBlKSg/OlxcXFwoXCIgKyB3aGl0ZXNwYWNlICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCIqKGV2ZW58b2RkfCgoWystXXwpKFxcXFxkKilufClcIiArIHdoaXRlc3BhY2UgKyBcIiooPzooWystXXwpXCIgKyB3aGl0ZXNwYWNlICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCIqKFxcXFxkKyl8KSlcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcKXwpXCIsIFwiaVwiKSxcclxuICAgICAgICAgICAgICAgICAgICBcImJvb2xcIjogbmV3IFJlZ0V4cChcIl4oPzpcIiArIGJvb2xlYW5zICsgXCIpJFwiLCBcImlcIiksXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIHVzZSBpbiBsaWJyYXJpZXMgaW1wbGVtZW50aW5nIC5pcygpXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgdXNlIHRoaXMgZm9yIFBPUyBtYXRjaGluZyBpbiBgc2VsZWN0YFxyXG4gICAgICAgICAgICAgICAgICAgIFwibmVlZHNDb250ZXh0XCI6IG5ldyBSZWdFeHAoXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqWz4rfl18OihldmVufG9kZHxlcXxndHxsdHxudGh8Zmlyc3R8bGFzdCkoPzpcXFxcKFwiICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpdGVzcGFjZSArIFwiKigoPzotXFxcXGQpP1xcXFxkKilcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcKXwpKD89W14tXXwkKVwiLCBcImlcIilcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgcmlucHV0cyA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXHJcbiAgICAgICAgICAgICAgICByaGVhZGVyID0gL15oXFxkJC9pLFxyXG5cclxuICAgICAgICAgICAgICAgIHJuYXRpdmUgPSAvXltee10rXFx7XFxzKlxcW25hdGl2ZSBcXHcvLFxyXG5cclxuICAgICAgICAgICAgICAgIC8vIEVhc2lseS1wYXJzZWFibGUvcmV0cmlldmFibGUgSUQgb3IgVEFHIG9yIENMQVNTIHNlbGVjdG9yc1xyXG4gICAgICAgICAgICAgICAgcnF1aWNrRXhwciA9IC9eKD86IyhbXFx3LV0rKXwoXFx3Kyl8XFwuKFtcXHctXSspKSQvLFxyXG5cclxuICAgICAgICAgICAgICAgIHJzaWJsaW5nID0gL1srfl0vLFxyXG4gICAgICAgICAgICAgICAgcmVzY2FwZSA9IC8nfFxcXFwvZyxcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDU1MgZXNjYXBlcyBodHRwOi8vd3d3LnczLm9yZy9UUi9DU1MyMS9zeW5kYXRhLmh0bWwjZXNjYXBlZC1jaGFyYWN0ZXJzXHJcbiAgICAgICAgICAgICAgICBydW5lc2NhcGUgPSBuZXcgUmVnRXhwKFwiXFxcXFxcXFwoW1xcXFxkYS1mXXsxLDZ9XCIgKyB3aGl0ZXNwYWNlICsgXCI/fChcIiArIHdoaXRlc3BhY2UgKyBcIil8LilcIiwgXCJpZ1wiKSxcclxuICAgICAgICAgICAgICAgIGZ1bmVzY2FwZSA9IGZ1bmN0aW9uKF8sIGVzY2FwZWQsIGVzY2FwZWRXaGl0ZXNwYWNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhpZ2ggPSBcIjB4XCIgKyBlc2NhcGVkIC0gMHgxMDAwMDtcclxuICAgICAgICAgICAgICAgICAgICAvLyBOYU4gbWVhbnMgbm9uLWNvZGVwb2ludFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IEZpcmVmb3g8MjRcclxuICAgICAgICAgICAgICAgICAgICAvLyBXb3JrYXJvdW5kIGVycm9uZW91cyBudW1lcmljIGludGVycHJldGF0aW9uIG9mICtcIjB4XCJcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGlnaCAhPT0gaGlnaCB8fCBlc2NhcGVkV2hpdGVzcGFjZSA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVzY2FwZWQgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoaWdoIDwgMCA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJNUCBjb2RlcG9pbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZShoaWdoICsgMHgxMDAwMCkgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwbGVtZW50YWwgUGxhbmUgY29kZXBvaW50IChzdXJyb2dhdGUgcGFpcilcclxuICAgICAgICAgICAgICAgICAgICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZShoaWdoID4+IDEwIHwgMHhEODAwLCBoaWdoICYgMHgzRkYgfCAweERDMDApO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8vIE9wdGltaXplIGZvciBwdXNoLmFwcGx5KCBfLCBOb2RlTGlzdCApXHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBwdXNoLmFwcGx5KFxyXG4gICAgICAgICAgICAgICAgICAgIChhcnIgPSBzbGljZS5jYWxsKHByZWZlcnJlZERvYy5jaGlsZE5vZGVzKSksXHJcbiAgICAgICAgICAgICAgICAgICAgcHJlZmVycmVkRG9jLmNoaWxkTm9kZXNcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMFxyXG4gICAgICAgICAgICAgICAgLy8gRGV0ZWN0IHNpbGVudGx5IGZhaWxpbmcgcHVzaC5hcHBseVxyXG4gICAgICAgICAgICAgICAgYXJyW3ByZWZlcnJlZERvYy5jaGlsZE5vZGVzLmxlbmd0aF0ubm9kZVR5cGU7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIHB1c2ggPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXBwbHk6IGFyci5sZW5ndGggP1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTGV2ZXJhZ2Ugc2xpY2UgaWYgcG9zc2libGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24odGFyZ2V0LCBlbHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1c2hfbmF0aXZlLmFwcGx5KHRhcmdldCwgc2xpY2UuY2FsbChlbHMpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSA6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRTw5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSBhcHBlbmQgZGlyZWN0bHlcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24odGFyZ2V0LCBlbHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBqID0gdGFyZ2V0Lmxlbmd0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhbid0IHRydXN0IE5vZGVMaXN0Lmxlbmd0aFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCh0YXJnZXRbaisrXSA9IGVsc1tpKytdKSkge31cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5sZW5ndGggPSBqIC0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gU2l6emxlKHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2gsIGVsZW0sIG0sIG5vZGVUeXBlLFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFFTQSB2YXJzXHJcbiAgICAgICAgICAgICAgICAgICAgaSwgZ3JvdXBzLCBvbGQsIG5pZCwgbmV3Q29udGV4dCwgbmV3U2VsZWN0b3I7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKChjb250ZXh0ID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgOiBwcmVmZXJyZWREb2MpICE9PSBkb2N1bWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldERvY3VtZW50KGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGNvbnRleHQgPSBjb250ZXh0IHx8IGRvY3VtZW50O1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCFzZWxlY3RvciB8fCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoKG5vZGVUeXBlID0gY29udGV4dC5ub2RlVHlwZSkgIT09IDEgJiYgbm9kZVR5cGUgIT09IDkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGRvY3VtZW50SXNIVE1MICYmICFzZWVkKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgobWF0Y2ggPSBycXVpY2tFeHByLmV4ZWMoc2VsZWN0b3IpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTcGVlZC11cDogU2l6emxlKFwiI0lEXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgobSA9IG1hdGNoWzFdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGVUeXBlID09PSA5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQobSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgcGFyZW50Tm9kZSB0byBjYXRjaCB3aGVuIEJsYWNrYmVycnkgNC42IHJldHVybnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBub2RlcyB0aGF0IGFyZSBubyBsb25nZXIgaW4gdGhlIGRvY3VtZW50IChqUXVlcnkgIzY5NjMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW0gJiYgZWxlbS5wYXJlbnROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSB0aGUgY2FzZSB3aGVyZSBJRSwgT3BlcmEsIGFuZCBXZWJraXQgcmV0dXJuIGl0ZW1zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbS5pZCA9PT0gbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGVsZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbnRleHQgaXMgbm90IGEgZG9jdW1lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGV4dC5vd25lckRvY3VtZW50ICYmIChlbGVtID0gY29udGV4dC5vd25lckRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG0pKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250YWlucyhjb250ZXh0LCBlbGVtKSAmJiBlbGVtLmlkID09PSBtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChlbGVtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNwZWVkLXVwOiBTaXp6bGUoXCJUQUdcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtYXRjaFsyXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVzaC5hcHBseShyZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKHNlbGVjdG9yKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTcGVlZC11cDogU2l6emxlKFwiLkNMQVNTXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoKG0gPSBtYXRjaFszXSkgJiYgc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVzaC5hcHBseShyZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUobSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFFTQSBwYXRoXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1cHBvcnQucXNhICYmICghcmJ1Z2d5UVNBIHx8ICFyYnVnZ3lRU0EudGVzdChzZWxlY3RvcikpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5pZCA9IG9sZCA9IGV4cGFuZG87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NvbnRleHQgPSBjb250ZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdTZWxlY3RvciA9IG5vZGVUeXBlID09PSA5ICYmIHNlbGVjdG9yO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcVNBIHdvcmtzIHN0cmFuZ2VseSBvbiBFbGVtZW50LXJvb3RlZCBxdWVyaWVzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGNhbiB3b3JrIGFyb3VuZCB0aGlzIGJ5IHNwZWNpZnlpbmcgYW4gZXh0cmEgSUQgb24gdGhlIHJvb3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHdvcmtpbmcgdXAgZnJvbSB0aGVyZSAoVGhhbmtzIHRvIEFuZHJldyBEdXBvbnQgZm9yIHRoZSB0ZWNobmlxdWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElFIDggZG9lc24ndCB3b3JrIG9uIG9iamVjdCBlbGVtZW50c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZVR5cGUgPT09IDEgJiYgY29udGV4dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cHMgPSB0b2tlbml6ZShzZWxlY3Rvcik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChvbGQgPSBjb250ZXh0LmdldEF0dHJpYnV0ZShcImlkXCIpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5pZCA9IG9sZC5yZXBsYWNlKHJlc2NhcGUsIFwiXFxcXCQmXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnNldEF0dHJpYnV0ZShcImlkXCIsIG5pZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuaWQgPSBcIltpZD0nXCIgKyBuaWQgKyBcIiddIFwiO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBncm91cHMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3Vwc1tpXSA9IG5pZCArIHRvU2VsZWN0b3IoZ3JvdXBzW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NvbnRleHQgPSByc2libGluZy50ZXN0KHNlbGVjdG9yKSAmJiB0ZXN0Q29udGV4dChjb250ZXh0LnBhcmVudE5vZGUpIHx8IGNvbnRleHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdTZWxlY3RvciA9IGdyb3Vwcy5qb2luKFwiLFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1NlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1c2guYXBwbHkocmVzdWx0cyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKG5ld1NlbGVjdG9yKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChxc2FFcnJvcikge30gZmluYWxseSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5yZW1vdmVBdHRyaWJ1dGUoXCJpZFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQWxsIG90aGVyc1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdChzZWxlY3Rvci5yZXBsYWNlKHJ0cmltLCBcIiQxXCIpLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENyZWF0ZSBrZXktdmFsdWUgY2FjaGVzIG9mIGxpbWl0ZWQgc2l6ZVxyXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb24oc3RyaW5nLCBPYmplY3QpfSBSZXR1cm5zIHRoZSBPYmplY3QgZGF0YSBhZnRlciBzdG9yaW5nIGl0IG9uIGl0c2VsZiB3aXRoXHJcbiAgICAgICAgICAgICAqXHRwcm9wZXJ0eSBuYW1lIHRoZSAoc3BhY2Utc3VmZml4ZWQpIHN0cmluZyBhbmQgKGlmIHRoZSBjYWNoZSBpcyBsYXJnZXIgdGhhbiBFeHByLmNhY2hlTGVuZ3RoKVxyXG4gICAgICAgICAgICAgKlx0ZGVsZXRpbmcgdGhlIG9sZGVzdCBlbnRyeVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZnVuY3Rpb24gY3JlYXRlQ2FjaGUoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIga2V5cyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGNhY2hlKGtleSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBVc2UgKGtleSArIFwiIFwiKSB0byBhdm9pZCBjb2xsaXNpb24gd2l0aCBuYXRpdmUgcHJvdG90eXBlIHByb3BlcnRpZXMgKHNlZSBJc3N1ZSAjMTU3KVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXlzLnB1c2goa2V5ICsgXCIgXCIpID4gRXhwci5jYWNoZUxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IGtlZXAgdGhlIG1vc3QgcmVjZW50IGVudHJpZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGNhY2hlW2tleXMuc2hpZnQoKV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoY2FjaGVba2V5ICsgXCIgXCJdID0gdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogTWFyayBhIGZ1bmN0aW9uIGZvciBzcGVjaWFsIHVzZSBieSBTaXp6bGVcclxuICAgICAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIG1hcmtcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIG1hcmtGdW5jdGlvbihmbikge1xyXG4gICAgICAgICAgICAgICAgZm5bZXhwYW5kb10gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU3VwcG9ydCB0ZXN0aW5nIHVzaW5nIGFuIGVsZW1lbnRcclxuICAgICAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gUGFzc2VkIHRoZSBjcmVhdGVkIGRpdiBhbmQgZXhwZWN0cyBhIGJvb2xlYW4gcmVzdWx0XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBhc3NlcnQoZm4pIHtcclxuICAgICAgICAgICAgICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG5cclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEhZm4oZGl2KTtcclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBmcm9tIGl0cyBwYXJlbnQgYnkgZGVmYXVsdFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXYucGFyZW50Tm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXYucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkaXYpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyByZWxlYXNlIG1lbW9yeSBpbiBJRVxyXG4gICAgICAgICAgICAgICAgICAgIGRpdiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBZGRzIHRoZSBzYW1lIGhhbmRsZXIgZm9yIGFsbCBvZiB0aGUgc3BlY2lmaWVkIGF0dHJzXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRycyBQaXBlLXNlcGFyYXRlZCBsaXN0IG9mIGF0dHJpYnV0ZXNcclxuICAgICAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBUaGUgbWV0aG9kIHRoYXQgd2lsbCBiZSBhcHBsaWVkXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBhZGRIYW5kbGUoYXR0cnMsIGhhbmRsZXIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhcnIgPSBhdHRycy5zcGxpdChcInxcIiksXHJcbiAgICAgICAgICAgICAgICAgICAgaSA9IGF0dHJzLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgRXhwci5hdHRySGFuZGxlW2FycltpXV0gPSBoYW5kbGVyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ2hlY2tzIGRvY3VtZW50IG9yZGVyIG9mIHR3byBzaWJsaW5nc1xyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGFcclxuICAgICAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBiXHJcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IFJldHVybnMgbGVzcyB0aGFuIDAgaWYgYSBwcmVjZWRlcyBiLCBncmVhdGVyIHRoYW4gMCBpZiBhIGZvbGxvd3MgYlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZnVuY3Rpb24gc2libGluZ0NoZWNrKGEsIGIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjdXIgPSBiICYmIGEsXHJcbiAgICAgICAgICAgICAgICAgICAgZGlmZiA9IGN1ciAmJiBhLm5vZGVUeXBlID09PSAxICYmIGIubm9kZVR5cGUgPT09IDEgJiZcclxuICAgICAgICAgICAgICAgICAgICAofmIuc291cmNlSW5kZXggfHwgTUFYX05FR0FUSVZFKSAtXHJcbiAgICAgICAgICAgICAgICAgICAgKH5hLnNvdXJjZUluZGV4IHx8IE1BWF9ORUdBVElWRSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVXNlIElFIHNvdXJjZUluZGV4IGlmIGF2YWlsYWJsZSBvbiBib3RoIG5vZGVzXHJcbiAgICAgICAgICAgICAgICBpZiAoZGlmZikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkaWZmO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGIgZm9sbG93cyBhXHJcbiAgICAgICAgICAgICAgICBpZiAoY3VyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChjdXIgPSBjdXIubmV4dFNpYmxpbmcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXIgPT09IGIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYSA/IDEgOiAtMTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgaW5wdXQgdHlwZXNcclxuICAgICAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNyZWF0ZUlucHV0UHNldWRvKHR5cGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihlbGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBidXR0b25zXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBjcmVhdGVCdXR0b25Qc2V1ZG8odHlwZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGVsZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKG5hbWUgPT09IFwiaW5wdXRcIiB8fCBuYW1lID09PSBcImJ1dHRvblwiKSAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBwb3NpdGlvbmFsc1xyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZnVuY3Rpb24gY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmbikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbihhcmd1bWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50ID0gK2FyZ3VtZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oc2VlZCwgbWF0Y2hlcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoSW5kZXhlcyA9IGZuKFtdLCBzZWVkLmxlbmd0aCwgYXJndW1lbnQpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA9IG1hdGNoSW5kZXhlcy5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNYXRjaCBlbGVtZW50cyBmb3VuZCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4ZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlZWRbKGogPSBtYXRjaEluZGV4ZXNbaV0pXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlZWRbal0gPSAhKG1hdGNoZXNbal0gPSBzZWVkW2pdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDaGVja3MgYSBub2RlIGZvciB2YWxpZGl0eSBhcyBhIFNpenpsZSBjb250ZXh0XHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3Q9fSBjb250ZXh0XHJcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtFbGVtZW50fE9iamVjdHxCb29sZWFufSBUaGUgaW5wdXQgbm9kZSBpZiBhY2NlcHRhYmxlLCBvdGhlcndpc2UgYSBmYWxzeSB2YWx1ZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZnVuY3Rpb24gdGVzdENvbnRleHQoY29udGV4dCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQgJiYgdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IHN0cnVuZGVmaW5lZCAmJiBjb250ZXh0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBFeHBvc2Ugc3VwcG9ydCB2YXJzIGZvciBjb252ZW5pZW5jZVxyXG4gICAgICAgICAgICBzdXBwb3J0ID0gU2l6emxlLnN1cHBvcnQgPSB7fTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBEZXRlY3RzIFhNTCBub2Rlc1xyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBlbGVtIEFuIGVsZW1lbnQgb3IgYSBkb2N1bWVudFxyXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZmYgZWxlbSBpcyBhIG5vbi1IVE1MIFhNTCBub2RlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBpc1hNTCA9IFNpenpsZS5pc1hNTCA9IGZ1bmN0aW9uKGVsZW0pIHtcclxuICAgICAgICAgICAgICAgIC8vIGRvY3VtZW50RWxlbWVudCBpcyB2ZXJpZmllZCBmb3IgY2FzZXMgd2hlcmUgaXQgZG9lc24ndCB5ZXQgZXhpc3RcclxuICAgICAgICAgICAgICAgIC8vIChzdWNoIGFzIGxvYWRpbmcgaWZyYW1lcyBpbiBJRSAtICM0ODMzKVxyXG4gICAgICAgICAgICAgICAgdmFyIGRvY3VtZW50RWxlbWVudCA9IGVsZW0gJiYgKGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtKS5kb2N1bWVudEVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9jdW1lbnRFbGVtZW50ID8gZG9jdW1lbnRFbGVtZW50Lm5vZGVOYW1lICE9PSBcIkhUTUxcIiA6IGZhbHNlO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNldHMgZG9jdW1lbnQtcmVsYXRlZCB2YXJpYWJsZXMgb25jZSBiYXNlZCBvbiB0aGUgY3VycmVudCBkb2N1bWVudFxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBbZG9jXSBBbiBlbGVtZW50IG9yIGRvY3VtZW50IG9iamVjdCB0byB1c2UgdG8gc2V0IHRoZSBkb2N1bWVudFxyXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjdXJyZW50IGRvY3VtZW50XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBzZXREb2N1bWVudCA9IFNpenpsZS5zZXREb2N1bWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBoYXNDb21wYXJlLFxyXG4gICAgICAgICAgICAgICAgICAgIGRvYyA9IG5vZGUgPyBub2RlLm93bmVyRG9jdW1lbnQgfHwgbm9kZSA6IHByZWZlcnJlZERvYyxcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQgPSBkb2MuZGVmYXVsdFZpZXc7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSWYgbm8gZG9jdW1lbnQgYW5kIGRvY3VtZW50RWxlbWVudCBpcyBhdmFpbGFibGUsIHJldHVyblxyXG4gICAgICAgICAgICAgICAgaWYgKGRvYyA9PT0gZG9jdW1lbnQgfHwgZG9jLm5vZGVUeXBlICE9PSA5IHx8ICFkb2MuZG9jdW1lbnRFbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFNldCBvdXIgZG9jdW1lbnRcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50ID0gZG9jO1xyXG4gICAgICAgICAgICAgICAgZG9jRWxlbSA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU3VwcG9ydCB0ZXN0c1xyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnRJc0hUTUwgPSAhaXNYTUwoZG9jKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRT44XHJcbiAgICAgICAgICAgICAgICAvLyBJZiBpZnJhbWUgZG9jdW1lbnQgaXMgYXNzaWduZWQgdG8gXCJkb2N1bWVudFwiIHZhcmlhYmxlIGFuZCBpZiBpZnJhbWUgaGFzIGJlZW4gcmVsb2FkZWQsXHJcbiAgICAgICAgICAgICAgICAvLyBJRSB3aWxsIHRocm93IFwicGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIGFjY2Vzc2luZyBcImRvY3VtZW50XCIgdmFyaWFibGUsIHNlZSBqUXVlcnkgIzEzOTM2XHJcbiAgICAgICAgICAgICAgICAvLyBJRTYtOCBkbyBub3Qgc3VwcG9ydCB0aGUgZGVmYXVsdFZpZXcgcHJvcGVydHkgc28gcGFyZW50IHdpbGwgYmUgdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50ICYmIHBhcmVudCAhPT0gcGFyZW50LnRvcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIElFMTEgZG9lcyBub3QgaGF2ZSBhdHRhY2hFdmVudCwgc28gYWxsIG11c3Qgc3VmZmVyXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudC5hZGRFdmVudExpc3RlbmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudC5hZGRFdmVudExpc3RlbmVyKFwidW5sb2FkXCIsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0RG9jdW1lbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyZW50LmF0dGFjaEV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudC5hdHRhY2hFdmVudChcIm9udW5sb2FkXCIsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0RG9jdW1lbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qIEF0dHJpYnV0ZXNcclxuICAgICAgICAgICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRTw4XHJcbiAgICAgICAgICAgICAgICAvLyBWZXJpZnkgdGhhdCBnZXRBdHRyaWJ1dGUgcmVhbGx5IHJldHVybnMgYXR0cmlidXRlcyBhbmQgbm90IHByb3BlcnRpZXMgKGV4Y2VwdGluZyBJRTggYm9vbGVhbnMpXHJcbiAgICAgICAgICAgICAgICBzdXBwb3J0LmF0dHJpYnV0ZXMgPSBhc3NlcnQoZnVuY3Rpb24oZGl2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGl2LmNsYXNzTmFtZSA9IFwiaVwiO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhZGl2LmdldEF0dHJpYnV0ZShcImNsYXNzTmFtZVwiKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qIGdldEVsZW1lbnQocylCeSpcclxuICAgICAgICAgICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBnZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikgcmV0dXJucyBvbmx5IGVsZW1lbnRzXHJcbiAgICAgICAgICAgICAgICBzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID0gYXNzZXJ0KGZ1bmN0aW9uKGRpdikge1xyXG4gICAgICAgICAgICAgICAgICAgIGRpdi5hcHBlbmRDaGlsZChkb2MuY3JlYXRlQ29tbWVudChcIlwiKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFkaXYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGdldEVsZW1lbnRzQnlDbGFzc05hbWUgY2FuIGJlIHRydXN0ZWRcclxuICAgICAgICAgICAgICAgIHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSA9IHJuYXRpdmUudGVzdChkb2MuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSkgJiYgYXNzZXJ0KGZ1bmN0aW9uKGRpdikge1xyXG4gICAgICAgICAgICAgICAgICAgIGRpdi5pbm5lckhUTUwgPSBcIjxkaXYgY2xhc3M9J2EnPjwvZGl2PjxkaXYgY2xhc3M9J2EgaSc+PC9kaXY+XCI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IFNhZmFyaTw0XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2F0Y2ggY2xhc3Mgb3Zlci1jYWNoaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgZGl2LmZpcnN0Q2hpbGQuY2xhc3NOYW1lID0gXCJpXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogT3BlcmE8MTBcclxuICAgICAgICAgICAgICAgICAgICAvLyBDYXRjaCBnRUJDTiBmYWlsdXJlIHRvIGZpbmQgbm9uLWxlYWRpbmcgY2xhc3Nlc1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkaXYuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcImlcIikubGVuZ3RoID09PSAyO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUU8MTBcclxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGdldEVsZW1lbnRCeUlkIHJldHVybnMgZWxlbWVudHMgYnkgbmFtZVxyXG4gICAgICAgICAgICAgICAgLy8gVGhlIGJyb2tlbiBnZXRFbGVtZW50QnlJZCBtZXRob2RzIGRvbid0IHBpY2sgdXAgcHJvZ3JhbWF0aWNhbGx5LXNldCBuYW1lcyxcclxuICAgICAgICAgICAgICAgIC8vIHNvIHVzZSBhIHJvdW5kYWJvdXQgZ2V0RWxlbWVudHNCeU5hbWUgdGVzdFxyXG4gICAgICAgICAgICAgICAgc3VwcG9ydC5nZXRCeUlkID0gYXNzZXJ0KGZ1bmN0aW9uKGRpdikge1xyXG4gICAgICAgICAgICAgICAgICAgIGRvY0VsZW0uYXBwZW5kQ2hpbGQoZGl2KS5pZCA9IGV4cGFuZG87XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFkb2MuZ2V0RWxlbWVudHNCeU5hbWUgfHwgIWRvYy5nZXRFbGVtZW50c0J5TmFtZShleHBhbmRvKS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJRCBmaW5kIGFuZCBmaWx0ZXJcclxuICAgICAgICAgICAgICAgIGlmIChzdXBwb3J0LmdldEJ5SWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBFeHByLmZpbmRbXCJJRFwiXSA9IGZ1bmN0aW9uKGlkLCBjb250ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gc3RydW5kZWZpbmVkICYmIGRvY3VtZW50SXNIVE1MKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoaWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgcGFyZW50Tm9kZSB0byBjYXRjaCB3aGVuIEJsYWNrYmVycnkgNC42IHJldHVybnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vZGVzIHRoYXQgYXJlIG5vIGxvbmdlciBpbiB0aGUgZG9jdW1lbnQgIzY5NjNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtICYmIG0ucGFyZW50Tm9kZSA/IFttXSA6IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICBFeHByLmZpbHRlcltcIklEXCJdID0gZnVuY3Rpb24oaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UocnVuZXNjYXBlLCBmdW5lc2NhcGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oZWxlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKFwiaWRcIikgPT09IGF0dHJJZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRTYvN1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGdldEVsZW1lbnRCeUlkIGlzIG5vdCByZWxpYWJsZSBhcyBhIGZpbmQgc2hvcnRjdXRcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgRXhwci5maW5kW1wiSURcIl07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIEV4cHIuZmlsdGVyW1wiSURcIl0gPSBmdW5jdGlvbihpZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cklkID0gaWQucmVwbGFjZShydW5lc2NhcGUsIGZ1bmVzY2FwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihlbGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZU5vZGUgIT09IHN0cnVuZGVmaW5lZCAmJiBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlICYmIG5vZGUudmFsdWUgPT09IGF0dHJJZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFRhZ1xyXG4gICAgICAgICAgICAgICAgRXhwci5maW5kW1wiVEFHXCJdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5VGFnTmFtZSA/XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24odGFnLCBjb250ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gc3RydW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSh0YWcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSA6XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24odGFnLCBjb250ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbGVtLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wID0gW10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKHRhZyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGaWx0ZXIgb3V0IHBvc3NpYmxlIGNvbW1lbnRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YWcgPT09IFwiKlwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKGVsZW0gPSByZXN1bHRzW2krK10pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW0ubm9kZVR5cGUgPT09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wLnB1c2goZWxlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0bXA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDbGFzc1xyXG4gICAgICAgICAgICAgICAgRXhwci5maW5kW1wiQ0xBU1NcIl0gPSBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiYgZnVuY3Rpb24oY2xhc3NOYW1lLCBjb250ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgIT09IHN0cnVuZGVmaW5lZCAmJiBkb2N1bWVudElzSFRNTCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGNsYXNzTmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAvKiBRU0EvbWF0Y2hlc1NlbGVjdG9yXHJcbiAgICAgICAgICAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUVNBIGFuZCBtYXRjaGVzU2VsZWN0b3Igc3VwcG9ydFxyXG5cclxuICAgICAgICAgICAgICAgIC8vIG1hdGNoZXNTZWxlY3Rvcig6YWN0aXZlKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoSUU5L09wZXJhIDExLjUpXHJcbiAgICAgICAgICAgICAgICByYnVnZ3lNYXRjaGVzID0gW107XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gcVNhKDpmb2N1cykgcmVwb3J0cyBmYWxzZSB3aGVuIHRydWUgKENocm9tZSAyMSlcclxuICAgICAgICAgICAgICAgIC8vIFdlIGFsbG93IHRoaXMgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBJRTgvOSB0aGF0IHRocm93cyBhbiBlcnJvclxyXG4gICAgICAgICAgICAgICAgLy8gd2hlbmV2ZXIgYGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRgIGlzIGFjY2Vzc2VkIG9uIGFuIGlmcmFtZVxyXG4gICAgICAgICAgICAgICAgLy8gU28sIHdlIGFsbG93IDpmb2N1cyB0byBwYXNzIHRocm91Z2ggUVNBIGFsbCB0aGUgdGltZSB0byBhdm9pZCB0aGUgSUUgZXJyb3JcclxuICAgICAgICAgICAgICAgIC8vIFNlZSBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMzM3OFxyXG4gICAgICAgICAgICAgICAgcmJ1Z2d5UVNBID0gW107XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKChzdXBwb3J0LnFzYSA9IHJuYXRpdmUudGVzdChkb2MucXVlcnlTZWxlY3RvckFsbCkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQnVpbGQgUVNBIHJlZ2V4XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVnZXggc3RyYXRlZ3kgYWRvcHRlZCBmcm9tIERpZWdvIFBlcmluaVxyXG4gICAgICAgICAgICAgICAgICAgIGFzc2VydChmdW5jdGlvbihkaXYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2VsZWN0IGlzIHNldCB0byBlbXB0eSBzdHJpbmcgb24gcHVycG9zZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRvIHRlc3QgSUUncyB0cmVhdG1lbnQgb2Ygbm90IGV4cGxpY2l0bHlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2V0dGluZyBhIGJvb2xlYW4gY29udGVudCBhdHRyaWJ1dGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNpbmNlIGl0cyBwcmVzZW5jZSBzaG91bGQgYmUgZW5vdWdoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEyMzU5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpdi5pbm5lckhUTUwgPSBcIjxzZWxlY3QgbXNhbGxvd2NsaXA9Jyc+PG9wdGlvbiBzZWxlY3RlZD0nJz48L29wdGlvbj48L3NlbGVjdD5cIjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFOCwgT3BlcmEgMTEtMTIuMTZcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90aGluZyBzaG91bGQgYmUgc2VsZWN0ZWQgd2hlbiBlbXB0eSBzdHJpbmdzIGZvbGxvdyBePSBvciAkPSBvciAqPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgdGVzdCBhdHRyaWJ1dGUgbXVzdCBiZSB1bmtub3duIGluIE9wZXJhIGJ1dCBcInNhZmVcIiBmb3IgV2luUlRcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2hoNDY1Mzg4LmFzcHgjYXR0cmlidXRlX3NlY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiW21zYWxsb3djbGlwXj0nJ11cIikubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYnVnZ3lRU0EucHVzaChcIlsqXiRdPVwiICsgd2hpdGVzcGFjZSArIFwiKig/OicnfFxcXCJcXFwiKVwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUU4XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJvb2xlYW4gYXR0cmlidXRlcyBhbmQgXCJ2YWx1ZVwiIGFyZSBub3QgdHJlYXRlZCBjb3JyZWN0bHlcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkaXYucXVlcnlTZWxlY3RvckFsbChcIltzZWxlY3RlZF1cIikubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYnVnZ3lRU0EucHVzaChcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86dmFsdWV8XCIgKyBib29sZWFucyArIFwiKVwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2Via2l0L09wZXJhIC0gOmNoZWNrZWQgc2hvdWxkIHJldHVybiBzZWxlY3RlZCBvcHRpb24gZWxlbWVudHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMS9SRUMtY3NzMy1zZWxlY3RvcnMtMjAxMTA5MjkvI2NoZWNrZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkaXYucXVlcnlTZWxlY3RvckFsbChcIjpjaGVja2VkXCIpLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmJ1Z2d5UVNBLnB1c2goXCI6Y2hlY2tlZFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBhc3NlcnQoZnVuY3Rpb24oZGl2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IFdpbmRvd3MgOCBOYXRpdmUgQXBwc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgdHlwZSBhbmQgbmFtZSBhdHRyaWJ1dGVzIGFyZSByZXN0cmljdGVkIGR1cmluZyAuaW5uZXJIVE1MIGFzc2lnbm1lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlucHV0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcImhpZGRlblwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGl2LmFwcGVuZENoaWxkKGlucHV0KS5zZXRBdHRyaWJ1dGUoXCJuYW1lXCIsIFwiRFwiKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFOFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFbmZvcmNlIGNhc2Utc2Vuc2l0aXZpdHkgb2YgbmFtZSBhdHRyaWJ1dGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiW25hbWU9ZF1cIikubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYnVnZ3lRU0EucHVzaChcIm5hbWVcIiArIHdoaXRlc3BhY2UgKyBcIipbKl4kfCF+XT89XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGRiAzLjUgLSA6ZW5hYmxlZC86ZGlzYWJsZWQgYW5kIGhpZGRlbiBlbGVtZW50cyAoaGlkZGVuIGVsZW1lbnRzIGFyZSBzdGlsbCBlbmFibGVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiOmVuYWJsZWRcIikubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYnVnZ3lRU0EucHVzaChcIjplbmFibGVkXCIsIFwiOmRpc2FibGVkXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPcGVyYSAxMC0xMSBkb2VzIG5vdCB0aHJvdyBvbiBwb3N0LWNvbW1hIGludmFsaWQgcHNldWRvc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXYucXVlcnlTZWxlY3RvckFsbChcIiosOnhcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJidWdneVFTQS5wdXNoKFwiLC4qOlwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoKHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yID0gcm5hdGl2ZS50ZXN0KChtYXRjaGVzID0gZG9jRWxlbS5tYXRjaGVzIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY0VsZW0ud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY0VsZW0ubW96TWF0Y2hlc1NlbGVjdG9yIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY0VsZW0ub01hdGNoZXNTZWxlY3RvciB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkb2NFbGVtLm1zTWF0Y2hlc1NlbGVjdG9yKSkpKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGFzc2VydChmdW5jdGlvbihkaXYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIGl0J3MgcG9zc2libGUgdG8gZG8gbWF0Y2hlc1NlbGVjdG9yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9uIGEgZGlzY29ubmVjdGVkIG5vZGUgKElFIDkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggPSBtYXRjaGVzLmNhbGwoZGl2LCBcImRpdlwiKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIGZhaWwgd2l0aCBhbiBleGNlcHRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2Vja28gZG9lcyBub3QgZXJyb3IsIHJldHVybnMgZmFsc2UgaW5zdGVhZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVzLmNhbGwoZGl2LCBcIltzIT0nJ106eFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmJ1Z2d5TWF0Y2hlcy5wdXNoKFwiIT1cIiwgcHNldWRvcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmJ1Z2d5UVNBID0gcmJ1Z2d5UVNBLmxlbmd0aCAmJiBuZXcgUmVnRXhwKHJidWdneVFTQS5qb2luKFwifFwiKSk7XHJcbiAgICAgICAgICAgICAgICByYnVnZ3lNYXRjaGVzID0gcmJ1Z2d5TWF0Y2hlcy5sZW5ndGggJiYgbmV3IFJlZ0V4cChyYnVnZ3lNYXRjaGVzLmpvaW4oXCJ8XCIpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvKiBDb250YWluc1xyXG4gICAgICAgICAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG4gICAgICAgICAgICAgICAgaGFzQ29tcGFyZSA9IHJuYXRpdmUudGVzdChkb2NFbGVtLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBFbGVtZW50IGNvbnRhaW5zIGFub3RoZXJcclxuICAgICAgICAgICAgICAgIC8vIFB1cnBvc2VmdWxseSBkb2VzIG5vdCBpbXBsZW1lbnQgaW5jbHVzaXZlIGRlc2NlbmRlbnRcclxuICAgICAgICAgICAgICAgIC8vIEFzIGluLCBhbiBlbGVtZW50IGRvZXMgbm90IGNvbnRhaW4gaXRzZWxmXHJcbiAgICAgICAgICAgICAgICBjb250YWlucyA9IGhhc0NvbXBhcmUgfHwgcm5hdGl2ZS50ZXN0KGRvY0VsZW0uY29udGFpbnMpID9cclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbihhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhZG93biA9IGEubm9kZVR5cGUgPT09IDkgPyBhLmRvY3VtZW50RWxlbWVudCA6IGEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXAgPSBiICYmIGIucGFyZW50Tm9kZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEgPT09IGJ1cCB8fCAhIShidXAgJiYgYnVwLm5vZGVUeXBlID09PSAxICYmIChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkb3duLmNvbnRhaW5zID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkb3duLmNvbnRhaW5zKGJ1cCkgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAmJiBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGJ1cCkgJiAxNlxyXG4gICAgICAgICAgICAgICAgICAgICAgICApKTtcclxuICAgICAgICAgICAgICAgICAgICB9IDpcclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbihhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKGIgPSBiLnBhcmVudE5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGIgPT09IGEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIC8qIFNvcnRpbmdcclxuICAgICAgICAgICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBEb2N1bWVudCBvcmRlciBzb3J0aW5nXHJcbiAgICAgICAgICAgICAgICBzb3J0T3JkZXIgPSBoYXNDb21wYXJlID9cclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbihhLCBiKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGbGFnIGZvciBkdXBsaWNhdGUgcmVtb3ZhbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYSA9PT0gYikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzRHVwbGljYXRlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTb3J0IG9uIG1ldGhvZCBleGlzdGVuY2UgaWYgb25seSBvbmUgaW5wdXQgaGFzIGNvbXBhcmVEb2N1bWVudFBvc2l0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb21wYXJlID0gIWEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gLSAhYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBhcmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21wYXJlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgcG9zaXRpb24gaWYgYm90aCBpbnB1dHMgYmVsb25nIHRvIHRoZSBzYW1lIGRvY3VtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBhcmUgPSAoYS5vd25lckRvY3VtZW50IHx8IGEpID09PSAoYi5vd25lckRvY3VtZW50IHx8IGIpID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oYikgOlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSB3ZSBrbm93IHRoZXkgYXJlIGRpc2Nvbm5lY3RlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERpc2Nvbm5lY3RlZCBub2Rlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29tcGFyZSAmIDEgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICghc3VwcG9ydC5zb3J0RGV0YWNoZWQgJiYgYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihhKSA9PT0gY29tcGFyZSkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaG9vc2UgdGhlIGZpcnN0IGVsZW1lbnQgdGhhdCBpcyByZWxhdGVkIHRvIG91ciBwcmVmZXJyZWQgZG9jdW1lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhID09PSBkb2MgfHwgYS5vd25lckRvY3VtZW50ID09PSBwcmVmZXJyZWREb2MgJiYgY29udGFpbnMocHJlZmVycmVkRG9jLCBhKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiID09PSBkb2MgfHwgYi5vd25lckRvY3VtZW50ID09PSBwcmVmZXJyZWREb2MgJiYgY29udGFpbnMocHJlZmVycmVkRG9jLCBiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1haW50YWluIG9yaWdpbmFsIG9yZGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc29ydElucHV0ID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoaW5kZXhPZi5jYWxsKHNvcnRJbnB1dCwgYSkgLSBpbmRleE9mLmNhbGwoc29ydElucHV0LCBiKSkgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21wYXJlICYgNCA/IC0xIDogMTtcclxuICAgICAgICAgICAgICAgICAgICB9IDpcclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbihhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4aXQgZWFybHkgaWYgdGhlIG5vZGVzIGFyZSBpZGVudGljYWxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGEgPT09IGIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc0R1cGxpY2F0ZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXVwID0gYS5wYXJlbnROb2RlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVwID0gYi5wYXJlbnROb2RlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXAgPSBbYV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicCA9IFtiXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBhcmVudGxlc3Mgbm9kZXMgYXJlIGVpdGhlciBkb2N1bWVudHMgb3IgZGlzY29ubmVjdGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYXVwIHx8ICFidXApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhID09PSBkb2MgPyAtMSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYiA9PT0gZG9jID8gMSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXVwID8gLTEgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1cCA/IDEgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvcnRJbnB1dCA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGluZGV4T2YuY2FsbChzb3J0SW5wdXQsIGEpIC0gaW5kZXhPZi5jYWxsKHNvcnRJbnB1dCwgYikpIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBub2RlcyBhcmUgc2libGluZ3MsIHdlIGNhbiBkbyBhIHF1aWNrIGNoZWNrXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYXVwID09PSBidXApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzaWJsaW5nQ2hlY2soYSwgYik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSB3ZSBuZWVkIGZ1bGwgbGlzdHMgb2YgdGhlaXIgYW5jZXN0b3JzIGZvciBjb21wYXJpc29uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1ciA9IGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgoY3VyID0gY3VyLnBhcmVudE5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcC51bnNoaWZ0KGN1cik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VyID0gYjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChjdXIgPSBjdXIucGFyZW50Tm9kZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJwLnVuc2hpZnQoY3VyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2FsayBkb3duIHRoZSB0cmVlIGxvb2tpbmcgZm9yIGEgZGlzY3JlcGFuY3lcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGFwW2ldID09PSBicFtpXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaSA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEbyBhIHNpYmxpbmcgY2hlY2sgaWYgdGhlIG5vZGVzIGhhdmUgYSBjb21tb24gYW5jZXN0b3JcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpYmxpbmdDaGVjayhhcFtpXSwgYnBbaV0pIDpcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2Ugbm9kZXMgaW4gb3VyIGRvY3VtZW50IHNvcnQgZmlyc3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwW2ldID09PSBwcmVmZXJyZWREb2MgPyAtMSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicFtpXSA9PT0gcHJlZmVycmVkRG9jID8gMSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAwO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvYztcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIFNpenpsZS5tYXRjaGVzID0gZnVuY3Rpb24oZXhwciwgZWxlbWVudHMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBTaXp6bGUoZXhwciwgbnVsbCwgbnVsbCwgZWxlbWVudHMpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgU2l6emxlLm1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uKGVsZW0sIGV4cHIpIHtcclxuICAgICAgICAgICAgICAgIC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxyXG4gICAgICAgICAgICAgICAgaWYgKChlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSkgIT09IGRvY3VtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0RG9jdW1lbnQoZWxlbSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgYXR0cmlidXRlIHNlbGVjdG9ycyBhcmUgcXVvdGVkXHJcbiAgICAgICAgICAgICAgICBleHByID0gZXhwci5yZXBsYWNlKHJhdHRyaWJ1dGVRdW90ZXMsIFwiPSckMSddXCIpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChzdXBwb3J0Lm1hdGNoZXNTZWxlY3RvciAmJiBkb2N1bWVudElzSFRNTCAmJlxyXG4gICAgICAgICAgICAgICAgICAgICghcmJ1Z2d5TWF0Y2hlcyB8fCAhcmJ1Z2d5TWF0Y2hlcy50ZXN0KGV4cHIpKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICghcmJ1Z2d5UVNBIHx8ICFyYnVnZ3lRU0EudGVzdChleHByKSkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJldCA9IG1hdGNoZXMuY2FsbChlbGVtLCBleHByKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElFIDkncyBtYXRjaGVzU2VsZWN0b3IgcmV0dXJucyBmYWxzZSBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJldCB8fCBzdXBwb3J0LmRpc2Nvbm5lY3RlZE1hdGNoIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBcyB3ZWxsLCBkaXNjb25uZWN0ZWQgbm9kZXMgYXJlIHNhaWQgdG8gYmUgaW4gYSBkb2N1bWVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZnJhZ21lbnQgaW4gSUUgOVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5kb2N1bWVudCAmJiBlbGVtLmRvY3VtZW50Lm5vZGVUeXBlICE9PSAxMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFNpenpsZShleHByLCBkb2N1bWVudCwgbnVsbCwgW2VsZW1dKS5sZW5ndGggPiAwO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgU2l6emxlLmNvbnRhaW5zID0gZnVuY3Rpb24oY29udGV4dCwgZWxlbSkge1xyXG4gICAgICAgICAgICAgICAgLy8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXHJcbiAgICAgICAgICAgICAgICBpZiAoKGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0KSAhPT0gZG9jdW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXREb2N1bWVudChjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBjb250YWlucyhjb250ZXh0LCBlbGVtKTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIFNpenpsZS5hdHRyID0gZnVuY3Rpb24oZWxlbSwgbmFtZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXHJcbiAgICAgICAgICAgICAgICBpZiAoKGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtKSAhPT0gZG9jdW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXREb2N1bWVudChlbGVtKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgZm4gPSBFeHByLmF0dHJIYW5kbGVbbmFtZS50b0xvd2VyQ2FzZSgpXSxcclxuICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoalF1ZXJ5ICMxMzgwNylcclxuICAgICAgICAgICAgICAgICAgICB2YWwgPSBmbiAmJiBoYXNPd24uY2FsbChFeHByLmF0dHJIYW5kbGUsIG5hbWUudG9Mb3dlckNhc2UoKSkgP1xyXG4gICAgICAgICAgICAgICAgICAgIGZuKGVsZW0sIG5hbWUsICFkb2N1bWVudElzSFRNTCkgOlxyXG4gICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsICE9PSB1bmRlZmluZWQgP1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbCA6XHJcbiAgICAgICAgICAgICAgICAgICAgc3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFkb2N1bWVudElzSFRNTCA/XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbS5nZXRBdHRyaWJ1dGUobmFtZSkgOlxyXG4gICAgICAgICAgICAgICAgICAgICh2YWwgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUobmFtZSkpICYmIHZhbC5zcGVjaWZpZWQgP1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbC52YWx1ZSA6XHJcbiAgICAgICAgICAgICAgICAgICAgbnVsbDtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIFNpenpsZS5lcnJvciA9IGZ1bmN0aW9uKG1zZykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3ludGF4IGVycm9yLCB1bnJlY29nbml6ZWQgZXhwcmVzc2lvbjogXCIgKyBtc2cpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIERvY3VtZW50IHNvcnRpbmcgYW5kIHJlbW92aW5nIGR1cGxpY2F0ZXNcclxuICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheUxpa2V9IHJlc3VsdHNcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFNpenpsZS51bmlxdWVTb3J0ID0gZnVuY3Rpb24ocmVzdWx0cykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGVsZW0sXHJcbiAgICAgICAgICAgICAgICAgICAgZHVwbGljYXRlcyA9IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgIGogPSAwLFxyXG4gICAgICAgICAgICAgICAgICAgIGkgPSAwO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFVubGVzcyB3ZSAqa25vdyogd2UgY2FuIGRldGVjdCBkdXBsaWNhdGVzLCBhc3N1bWUgdGhlaXIgcHJlc2VuY2VcclxuICAgICAgICAgICAgICAgIGhhc0R1cGxpY2F0ZSA9ICFzdXBwb3J0LmRldGVjdER1cGxpY2F0ZXM7XHJcbiAgICAgICAgICAgICAgICBzb3J0SW5wdXQgPSAhc3VwcG9ydC5zb3J0U3RhYmxlICYmIHJlc3VsdHMuc2xpY2UoMCk7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRzLnNvcnQoc29ydE9yZGVyKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoaGFzRHVwbGljYXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChlbGVtID0gcmVzdWx0c1tpKytdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbSA9PT0gcmVzdWx0c1tpXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaiA9IGR1cGxpY2F0ZXMucHVzaChpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoai0tKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMuc3BsaWNlKGR1cGxpY2F0ZXNbal0sIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDbGVhciBpbnB1dCBhZnRlciBzb3J0aW5nIHRvIHJlbGVhc2Ugb2JqZWN0c1xyXG4gICAgICAgICAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvc2l6emxlL3B1bGwvMjI1XHJcbiAgICAgICAgICAgICAgICBzb3J0SW5wdXQgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFV0aWxpdHkgZnVuY3Rpb24gZm9yIHJldHJpZXZpbmcgdGhlIHRleHQgdmFsdWUgb2YgYW4gYXJyYXkgb2YgRE9NIG5vZGVzXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXl8RWxlbWVudH0gZWxlbVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZ2V0VGV4dCA9IFNpenpsZS5nZXRUZXh0ID0gZnVuY3Rpb24oZWxlbSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5vZGUsXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0ID0gXCJcIixcclxuICAgICAgICAgICAgICAgICAgICBpID0gMCxcclxuICAgICAgICAgICAgICAgICAgICBub2RlVHlwZSA9IGVsZW0ubm9kZVR5cGU7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCFub2RlVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIG5vIG5vZGVUeXBlLCB0aGlzIGlzIGV4cGVjdGVkIHRvIGJlIGFuIGFycmF5XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChub2RlID0gZWxlbVtpKytdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEbyBub3QgdHJhdmVyc2UgY29tbWVudCBub2Rlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXQgKz0gZ2V0VGV4dChub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5vZGVUeXBlID09PSAxIHx8IG5vZGVUeXBlID09PSA5IHx8IG5vZGVUeXBlID09PSAxMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFVzZSB0ZXh0Q29udGVudCBmb3IgZWxlbWVudHNcclxuICAgICAgICAgICAgICAgICAgICAvLyBpbm5lclRleHQgdXNhZ2UgcmVtb3ZlZCBmb3IgY29uc2lzdGVuY3kgb2YgbmV3IGxpbmVzIChqUXVlcnkgIzExMTUzKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZWxlbS50ZXh0Q29udGVudCA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS50ZXh0Q29udGVudDtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUcmF2ZXJzZSBpdHMgY2hpbGRyZW5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0ICs9IGdldFRleHQoZWxlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5vZGVUeXBlID09PSAzIHx8IG5vZGVUeXBlID09PSA0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0ubm9kZVZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gRG8gbm90IGluY2x1ZGUgY29tbWVudCBvciBwcm9jZXNzaW5nIGluc3RydWN0aW9uIG5vZGVzXHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIEV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzID0ge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENhbiBiZSBhZGp1c3RlZCBieSB0aGUgdXNlclxyXG4gICAgICAgICAgICAgICAgY2FjaGVMZW5ndGg6IDUwLFxyXG5cclxuICAgICAgICAgICAgICAgIGNyZWF0ZVBzZXVkbzogbWFya0Z1bmN0aW9uLFxyXG5cclxuICAgICAgICAgICAgICAgIG1hdGNoOiBtYXRjaEV4cHIsXHJcblxyXG4gICAgICAgICAgICAgICAgYXR0ckhhbmRsZToge30sXHJcblxyXG4gICAgICAgICAgICAgICAgZmluZDoge30sXHJcblxyXG4gICAgICAgICAgICAgICAgcmVsYXRpdmU6IHtcclxuICAgICAgICAgICAgICAgICAgICBcIj5cIjogeyBkaXI6IFwicGFyZW50Tm9kZVwiLCBmaXJzdDogdHJ1ZSB9LFxyXG4gICAgICAgICAgICAgICAgICAgIFwiIFwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIgfSxcclxuICAgICAgICAgICAgICAgICAgICBcIitcIjogeyBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIsIGZpcnN0OiB0cnVlIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgXCJ+XCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgcHJlRmlsdGVyOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJBVFRSXCI6IGZ1bmN0aW9uKG1hdGNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoWzFdID0gbWF0Y2hbMV0ucmVwbGFjZShydW5lc2NhcGUsIGZ1bmVzY2FwZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNb3ZlIHRoZSBnaXZlbiB2YWx1ZSB0byBtYXRjaFszXSB3aGV0aGVyIHF1b3RlZCBvciB1bnF1b3RlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFszXSA9IChtYXRjaFszXSB8fCBtYXRjaFs0XSB8fCBtYXRjaFs1XSB8fCBcIlwiKS5yZXBsYWNlKHJ1bmVzY2FwZSwgZnVuZXNjYXBlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaFsyXSA9PT0gXCJ+PVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFszXSA9IFwiIFwiICsgbWF0Y2hbM10gKyBcIiBcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoLnNsaWNlKDAsIDQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIFwiQ0hJTERcIjogZnVuY3Rpb24obWF0Y2gpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLyogbWF0Y2hlcyBmcm9tIG1hdGNoRXhwcltcIkNISUxEXCJdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFx0MSB0eXBlIChvbmx5fG50aHwuLi4pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFx0MiB3aGF0IChjaGlsZHxvZi10eXBlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcdDMgYXJndW1lbnQgKGV2ZW58b2RkfFxcZCp8XFxkKm4oWystXVxcZCspP3wuLi4pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFx0NCB4bi1jb21wb25lbnQgb2YgeG4reSBhcmd1bWVudCAoWystXT9cXGQqbnwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFx0NSBzaWduIG9mIHhuLWNvbXBvbmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcdDYgeCBvZiB4bi1jb21wb25lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgXHQ3IHNpZ24gb2YgeS1jb21wb25lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgXHQ4IHkgb2YgeS1jb21wb25lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hbMV0gPSBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoWzFdLnNsaWNlKDAsIDMpID09PSBcIm50aFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBudGgtKiByZXF1aXJlcyBhcmd1bWVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXRjaFszXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNpenpsZS5lcnJvcihtYXRjaFswXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbnVtZXJpYyB4IGFuZCB5IHBhcmFtZXRlcnMgZm9yIEV4cHIuZmlsdGVyLkNISUxEXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZW1lbWJlciB0aGF0IGZhbHNlL3RydWUgY2FzdCByZXNwZWN0aXZlbHkgdG8gMC8xXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFs0XSA9ICsobWF0Y2hbNF0gPyBtYXRjaFs1XSArIChtYXRjaFs2XSB8fCAxKSA6IDIgKiAobWF0Y2hbM10gPT09IFwiZXZlblwiIHx8IG1hdGNoWzNdID09PSBcIm9kZFwiKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFs1XSA9ICsoKG1hdGNoWzddICsgbWF0Y2hbOF0pIHx8IG1hdGNoWzNdID09PSBcIm9kZFwiKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvdGhlciB0eXBlcyBwcm9oaWJpdCBhcmd1bWVudHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtYXRjaFszXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgU2l6emxlLmVycm9yKG1hdGNoWzBdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIFwiUFNFVURPXCI6IGZ1bmN0aW9uKG1hdGNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBleGNlc3MsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bnF1b3RlZCA9ICFtYXRjaFs2XSAmJiBtYXRjaFsyXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaEV4cHJbXCJDSElMRFwiXS50ZXN0KG1hdGNoWzBdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFjY2VwdCBxdW90ZWQgYXJndW1lbnRzIGFzLWlzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaFszXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hbMl0gPSBtYXRjaFs0XSB8fCBtYXRjaFs1XSB8fCBcIlwiO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0cmlwIGV4Y2VzcyBjaGFyYWN0ZXJzIGZyb20gdW5xdW90ZWQgYXJndW1lbnRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodW5xdW90ZWQgJiYgcnBzZXVkby50ZXN0KHVucXVvdGVkKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IGV4Y2VzcyBmcm9tIHRva2VuaXplIChyZWN1cnNpdmVseSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChleGNlc3MgPSB0b2tlbml6ZSh1bnF1b3RlZCwgdHJ1ZSkpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhZHZhbmNlIHRvIHRoZSBuZXh0IGNsb3NpbmcgcGFyZW50aGVzaXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChleGNlc3MgPSB1bnF1b3RlZC5pbmRleE9mKFwiKVwiLCB1bnF1b3RlZC5sZW5ndGggLSBleGNlc3MpIC0gdW5xdW90ZWQubGVuZ3RoKSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV4Y2VzcyBpcyBhIG5lZ2F0aXZlIGluZGV4XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFswXSA9IG1hdGNoWzBdLnNsaWNlKDAsIGV4Y2Vzcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFsyXSA9IHVucXVvdGVkLnNsaWNlKDAsIGV4Y2Vzcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldHVybiBvbmx5IGNhcHR1cmVzIG5lZWRlZCBieSB0aGUgcHNldWRvIGZpbHRlciBtZXRob2QgKHR5cGUgYW5kIGFyZ3VtZW50KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2guc2xpY2UoMCwgMyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBmaWx0ZXI6IHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgXCJUQUdcIjogZnVuY3Rpb24obm9kZU5hbWVTZWxlY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZU5hbWUgPSBub2RlTmFtZVNlbGVjdG9yLnJlcGxhY2UocnVuZXNjYXBlLCBmdW5lc2NhcGUpLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlTmFtZVNlbGVjdG9yID09PSBcIipcIiA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbigpIHsgcmV0dXJuIHRydWU7IH0gOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oZWxlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbm9kZU5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIFwiQ0xBU1NcIjogZnVuY3Rpb24oY2xhc3NOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXR0ZXJuID0gY2xhc3NDYWNoZVtjbGFzc05hbWUgKyBcIiBcIl07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGF0dGVybiB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHBhdHRlcm4gPSBuZXcgUmVnRXhwKFwiKF58XCIgKyB3aGl0ZXNwYWNlICsgXCIpXCIgKyBjbGFzc05hbWUgKyBcIihcIiArIHdoaXRlc3BhY2UgKyBcInwkKVwiKSkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzQ2FjaGUoY2xhc3NOYW1lLCBmdW5jdGlvbihlbGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhdHRlcm4udGVzdCh0eXBlb2YgZWxlbS5jbGFzc05hbWUgPT09IFwic3RyaW5nXCIgJiYgZWxlbS5jbGFzc05hbWUgfHwgdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlICE9PSBzdHJ1bmRlZmluZWQgJiYgZWxlbS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSB8fCBcIlwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIFwiQVRUUlwiOiBmdW5jdGlvbihuYW1lLCBvcGVyYXRvciwgY2hlY2spIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGVsZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBTaXp6bGUuYXR0cihlbGVtLCBuYW1lKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3BlcmF0b3IgPT09IFwiIT1cIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb3BlcmF0b3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCJcIjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3BlcmF0b3IgPT09IFwiPVwiID8gcmVzdWx0ID09PSBjaGVjayA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3IgPT09IFwiIT1cIiA/IHJlc3VsdCAhPT0gY2hlY2sgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yID09PSBcIl49XCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZihjaGVjaykgPT09IDAgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yID09PSBcIio9XCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZihjaGVjaykgPiAtMSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3IgPT09IFwiJD1cIiA/IGNoZWNrICYmIHJlc3VsdC5zbGljZSgtY2hlY2subGVuZ3RoKSA9PT0gY2hlY2sgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yID09PSBcIn49XCIgPyAoXCIgXCIgKyByZXN1bHQgKyBcIiBcIikuaW5kZXhPZihjaGVjaykgPiAtMSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3IgPT09IFwifD1cIiA/IHJlc3VsdCA9PT0gY2hlY2sgfHwgcmVzdWx0LnNsaWNlKDAsIGNoZWNrLmxlbmd0aCArIDEpID09PSBjaGVjayArIFwiLVwiIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgICAgICBcIkNISUxEXCI6IGZ1bmN0aW9uKHR5cGUsIHdoYXQsIGFyZ3VtZW50LCBmaXJzdCwgbGFzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2ltcGxlID0gdHlwZS5zbGljZSgwLCAzKSAhPT0gXCJudGhcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcndhcmQgPSB0eXBlLnNsaWNlKC00KSAhPT0gXCJsYXN0XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZlR5cGUgPSB3aGF0ID09PSBcIm9mLXR5cGVcIjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmaXJzdCA9PT0gMSAmJiBsYXN0ID09PSAwID9cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaG9ydGN1dCBmb3IgOm50aC0qKG4pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbihlbGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEhZWxlbS5wYXJlbnROb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSA6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oZWxlbSwgY29udGV4dCwgeG1sKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhY2hlLCBvdXRlckNhY2hlLCBub2RlLCBkaWZmLCBub2RlSW5kZXgsIHN0YXJ0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXIgPSBzaW1wbGUgIT09IGZvcndhcmQgPyBcIm5leHRTaWJsaW5nXCIgOiBcInByZXZpb3VzU2libGluZ1wiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSBvZlR5cGUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VDYWNoZSA9ICF4bWwgJiYgIW9mVHlwZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudCkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gOihmaXJzdHxsYXN0fG9ubHkpLShjaGlsZHxvZi10eXBlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2ltcGxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZGlyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGVsZW07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChub2RlID0gbm9kZVtkaXJdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2ZUeXBlID8gbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lIDogbm9kZS5ub2RlVHlwZSA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldmVyc2UgZGlyZWN0aW9uIGZvciA6b25seS0qIChpZiB3ZSBoYXZlbid0IHlldCBkb25lIHNvKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gZGlyID0gdHlwZSA9PT0gXCJvbmx5XCIgJiYgIXN0YXJ0ICYmIFwibmV4dFNpYmxpbmdcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IFtmb3J3YXJkID8gcGFyZW50LmZpcnN0Q2hpbGQgOiBwYXJlbnQubGFzdENoaWxkXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vbi14bWwgOm50aC1jaGlsZCguLi4pIHN0b3JlcyBjYWNoZSBkYXRhIG9uIGBwYXJlbnRgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmb3J3YXJkICYmIHVzZUNhY2hlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTZWVrIGBlbGVtYCBmcm9tIGEgcHJldmlvdXNseS1jYWNoZWQgaW5kZXhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dGVyQ2FjaGUgPSBwYXJlbnRbZXhwYW5kb10gfHwgKHBhcmVudFtleHBhbmRvXSA9IHt9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlID0gb3V0ZXJDYWNoZVt0eXBlXSB8fCBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVJbmRleCA9IGNhY2hlWzBdID09PSBkaXJydW5zICYmIGNhY2hlWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlmZiA9IGNhY2hlWzBdID09PSBkaXJydW5zICYmIGNhY2hlWzJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGVJbmRleCAmJiBwYXJlbnQuY2hpbGROb2Rlc1tub2RlSW5kZXhdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgobm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVtkaXJdIHx8XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGYWxsYmFjayB0byBzZWVraW5nIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZGlmZiA9IG5vZGVJbmRleCA9IDApIHx8IHN0YXJ0LnBvcCgpKSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIGZvdW5kLCBjYWNoZSBpbmRleGVzIG9uIGBwYXJlbnRgIGFuZCBicmVha1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSAxICYmICsrZGlmZiAmJiBub2RlID09PSBlbGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dGVyQ2FjaGVbdHlwZV0gPSBbZGlycnVucywgbm9kZUluZGV4LCBkaWZmXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSBwcmV2aW91c2x5LWNhY2hlZCBlbGVtZW50IGluZGV4IGlmIGF2YWlsYWJsZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHVzZUNhY2hlICYmIChjYWNoZSA9IChlbGVtW2V4cGFuZG9dIHx8IChlbGVtW2V4cGFuZG9dID0ge30pKVt0eXBlXSkgJiYgY2FjaGVbMF0gPT09IGRpcnJ1bnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpZmYgPSBjYWNoZVsxXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB4bWwgOm50aC1jaGlsZCguLi4pIG9yIDpudGgtbGFzdC1jaGlsZCguLi4pIG9yIDpudGgoLWxhc3QpPy1vZi10eXBlKC4uLilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgc2FtZSBsb29wIGFzIGFib3ZlIHRvIHNlZWsgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbZGlyXSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZGlmZiA9IG5vZGVJbmRleCA9IDApIHx8IHN0YXJ0LnBvcCgpKSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKG9mVHlwZSA/IG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSA6IG5vZGUubm9kZVR5cGUgPT09IDEpICYmICsrZGlmZikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDYWNoZSB0aGUgaW5kZXggb2YgZWFjaCBlbmNvdW50ZXJlZCBlbGVtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1c2VDYWNoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG5vZGVbZXhwYW5kb10gfHwgKG5vZGVbZXhwYW5kb10gPSB7fSkpW3R5cGVdID0gW2RpcnJ1bnMsIGRpZmZdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSA9PT0gZWxlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluY29ycG9yYXRlIHRoZSBvZmZzZXQsIHRoZW4gY2hlY2sgYWdhaW5zdCBjeWNsZSBzaXplXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpZmYgLT0gbGFzdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpZmYgPT09IGZpcnN0IHx8IChkaWZmICUgZmlyc3QgPT09IDAgJiYgZGlmZiAvIGZpcnN0ID49IDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgXCJQU0VVRE9cIjogZnVuY3Rpb24ocHNldWRvLCBhcmd1bWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwc2V1ZG8tY2xhc3MgbmFtZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNwc2V1ZG8tY2xhc3Nlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQcmlvcml0aXplIGJ5IGNhc2Ugc2Vuc2l0aXZpdHkgaW4gY2FzZSBjdXN0b20gcHNldWRvcyBhcmUgYWRkZWQgd2l0aCB1cHBlcmNhc2UgbGV0dGVyc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZW1lbWJlciB0aGF0IHNldEZpbHRlcnMgaW5oZXJpdHMgZnJvbSBwc2V1ZG9zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcmdzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm4gPSBFeHByLnBzZXVkb3NbcHNldWRvXSB8fCBFeHByLnNldEZpbHRlcnNbcHNldWRvLnRvTG93ZXJDYXNlKCldIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTaXp6bGUuZXJyb3IoXCJ1bnN1cHBvcnRlZCBwc2V1ZG86IFwiICsgcHNldWRvKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSB1c2VyIG1heSB1c2UgY3JlYXRlUHNldWRvIHRvIGluZGljYXRlIHRoYXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXJndW1lbnRzIGFyZSBuZWVkZWQgdG8gY3JlYXRlIHRoZSBmaWx0ZXIgZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8ganVzdCBhcyBTaXp6bGUgZG9lc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm5bZXhwYW5kb10pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmbihhcmd1bWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJ1dCBtYWludGFpbiBzdXBwb3J0IGZvciBvbGQgc2lnbmF0dXJlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm4ubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncyA9IFtwc2V1ZG8sIHBzZXVkbywgXCJcIiwgYXJndW1lbnRdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEV4cHIuc2V0RmlsdGVycy5oYXNPd25Qcm9wZXJ0eShwc2V1ZG8udG9Mb3dlckNhc2UoKSkgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtGdW5jdGlvbihmdW5jdGlvbihzZWVkLCBtYXRjaGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpZHgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkID0gZm4oc2VlZCwgYXJndW1lbnQpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA9IG1hdGNoZWQubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZHggPSBpbmRleE9mLmNhbGwoc2VlZCwgbWF0Y2hlZFtpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWVkW2lkeF0gPSAhKG1hdGNoZXNbaWR4XSA9IG1hdGNoZWRbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGVsZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZuKGVsZW0sIDAsIGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmbjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIHBzZXVkb3M6IHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBQb3RlbnRpYWxseSBjb21wbGV4IHBzZXVkb3NcclxuICAgICAgICAgICAgICAgICAgICBcIm5vdFwiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oc2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJpbSB0aGUgc2VsZWN0b3IgcGFzc2VkIHRvIGNvbXBpbGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG8gYXZvaWQgdHJlYXRpbmcgbGVhZGluZyBhbmQgdHJhaWxpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3BhY2VzIGFzIGNvbWJpbmF0b3JzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbnB1dCA9IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cyA9IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlciA9IGNvbXBpbGUoc2VsZWN0b3IucmVwbGFjZShydHJpbSwgXCIkMVwiKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hlcltleHBhbmRvXSA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oc2VlZCwgbWF0Y2hlcywgY29udGV4dCwgeG1sKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVubWF0Y2hlZCA9IG1hdGNoZXIoc2VlZCwgbnVsbCwgeG1sLCBbXSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBzZWVkLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWF0Y2ggZWxlbWVudHMgdW5tYXRjaGVkIGJ5IGBtYXRjaGVyYFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChlbGVtID0gdW5tYXRjaGVkW2ldKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VlZFtpXSA9ICEobWF0Y2hlc1tpXSA9IGVsZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oZWxlbSwgY29udGV4dCwgeG1sKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRbMF0gPSBlbGVtO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXIoaW5wdXQsIG51bGwsIHhtbCwgcmVzdWx0cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFyZXN1bHRzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB9KSxcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgXCJoYXNcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKHNlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihlbGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gU2l6emxlKHNlbGVjdG9yLCBlbGVtKS5sZW5ndGggPiAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH0pLFxyXG5cclxuICAgICAgICAgICAgICAgICAgICBcImNvbnRhaW5zXCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbih0ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihlbGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGVsZW0udGV4dENvbnRlbnQgfHwgZWxlbS5pbm5lclRleHQgfHwgZ2V0VGV4dChlbGVtKSkuaW5kZXhPZih0ZXh0KSA+IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH0pLFxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBcIldoZXRoZXIgYW4gZWxlbWVudCBpcyByZXByZXNlbnRlZCBieSBhIDpsYW5nKCkgc2VsZWN0b3JcclxuICAgICAgICAgICAgICAgICAgICAvLyBpcyBiYXNlZCBzb2xlbHkgb24gdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGJlaW5nIGVxdWFsIHRvIHRoZSBpZGVudGlmaWVyIEMsXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gb3IgYmVnaW5uaW5nIHdpdGggdGhlIGlkZW50aWZpZXIgQyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBcIi1cIi5cclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbWF0Y2hpbmcgb2YgQyBhZ2FpbnN0IHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWUgaXMgcGVyZm9ybWVkIGNhc2UtaW5zZW5zaXRpdmVseS5cclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgaWRlbnRpZmllciBDIGRvZXMgbm90IGhhdmUgdG8gYmUgYSB2YWxpZCBsYW5ndWFnZSBuYW1lLlwiXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNsYW5nLXBzZXVkb1xyXG4gICAgICAgICAgICAgICAgICAgIFwibGFuZ1wiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24obGFuZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsYW5nIHZhbHVlIG11c3QgYmUgYSB2YWxpZCBpZGVudGlmaWVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmlkZW50aWZpZXIudGVzdChsYW5nIHx8IFwiXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTaXp6bGUuZXJyb3IoXCJ1bnN1cHBvcnRlZCBsYW5nOiBcIiArIGxhbmcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhbmcgPSBsYW5nLnJlcGxhY2UocnVuZXNjYXBlLCBmdW5lc2NhcGUpLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihlbGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbUxhbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChlbGVtTGFuZyA9IGRvY3VtZW50SXNIVE1MID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0ubGFuZyA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmdldEF0dHJpYnV0ZShcInhtbDpsYW5nXCIpIHx8IGVsZW0uZ2V0QXR0cmlidXRlKFwibGFuZ1wiKSkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1MYW5nID0gZWxlbUxhbmcudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1MYW5nID09PSBsYW5nIHx8IGVsZW1MYW5nLmluZGV4T2YobGFuZyArIFwiLVwiKSA9PT0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IHdoaWxlICgoZWxlbSA9IGVsZW0ucGFyZW50Tm9kZSkgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgfSksXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE1pc2NlbGxhbmVvdXNcclxuICAgICAgICAgICAgICAgICAgICBcInRhcmdldFwiOiBmdW5jdGlvbihlbGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoYXNoID0gd2luZG93LmxvY2F0aW9uICYmIHdpbmRvdy5sb2NhdGlvbi5oYXNoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFzaCAmJiBoYXNoLnNsaWNlKDEpID09PSBlbGVtLmlkO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIFwicm9vdFwiOiBmdW5jdGlvbihlbGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtID09PSBkb2NFbGVtO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIFwiZm9jdXNcIjogZnVuY3Rpb24oZWxlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbSA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiAoIWRvY3VtZW50Lmhhc0ZvY3VzIHx8IGRvY3VtZW50Lmhhc0ZvY3VzKCkpICYmICEhKGVsZW0udHlwZSB8fCBlbGVtLmhyZWYgfHwgfmVsZW0udGFiSW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEJvb2xlYW4gcHJvcGVydGllc1xyXG4gICAgICAgICAgICAgICAgICAgIFwiZW5hYmxlZFwiOiBmdW5jdGlvbihlbGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLmRpc2FibGVkID09PSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgICAgICBcImRpc2FibGVkXCI6IGZ1bmN0aW9uKGVsZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgXCJjaGVja2VkXCI6IGZ1bmN0aW9uKGVsZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW4gQ1NTMywgOmNoZWNrZWQgc2hvdWxkIHJldHVybiBib3RoIGNoZWNrZWQgYW5kIHNlbGVjdGVkIGVsZW1lbnRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmICEhZWxlbS5jaGVja2VkKSB8fCAobm9kZU5hbWUgPT09IFwib3B0aW9uXCIgJiYgISFlbGVtLnNlbGVjdGVkKTtcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgICAgICBcInNlbGVjdGVkXCI6IGZ1bmN0aW9uKGVsZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWNjZXNzaW5nIHRoaXMgcHJvcGVydHkgbWFrZXMgc2VsZWN0ZWQtYnktZGVmYXVsdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvcHRpb25zIGluIFNhZmFyaSB3b3JrIHByb3Blcmx5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtLnBhcmVudE5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0ucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5zZWxlY3RlZCA9PT0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBDb250ZW50c1xyXG4gICAgICAgICAgICAgICAgICAgIFwiZW1wdHlcIjogZnVuY3Rpb24oZWxlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2VtcHR5LXBzZXVkb1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyA6ZW1wdHkgaXMgbmVnYXRlZCBieSBlbGVtZW50ICgxKSBvciBjb250ZW50IG5vZGVzICh0ZXh0OiAzOyBjZGF0YTogNDsgZW50aXR5IHJlZjogNSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgYnV0IG5vdCBieSBvdGhlcnMgKGNvbW1lbnQ6IDg7IHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb246IDc7IGV0Yy4pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vZGVUeXBlIDwgNiB3b3JrcyBiZWNhdXNlIGF0dHJpYnV0ZXMgKDIpIGRvIG5vdCBhcHBlYXIgYXMgY2hpbGRyZW5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW0ubm9kZVR5cGUgPCA2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIFwicGFyZW50XCI6IGZ1bmN0aW9uKGVsZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFFeHByLnBzZXVkb3NbXCJlbXB0eVwiXShlbGVtKTtcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBFbGVtZW50L2lucHV0IHR5cGVzXHJcbiAgICAgICAgICAgICAgICAgICAgXCJoZWFkZXJcIjogZnVuY3Rpb24oZWxlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmhlYWRlci50ZXN0KGVsZW0ubm9kZU5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIFwiaW5wdXRcIjogZnVuY3Rpb24oZWxlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmlucHV0cy50ZXN0KGVsZW0ubm9kZU5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIFwiYnV0dG9uXCI6IGZ1bmN0aW9uKGVsZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuYW1lID09PSBcImlucHV0XCIgJiYgZWxlbS50eXBlID09PSBcImJ1dHRvblwiIHx8IG5hbWUgPT09IFwiYnV0dG9uXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCI6IGZ1bmN0aW9uKGVsZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIiAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS50eXBlID09PSBcInRleHRcIiAmJlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFPDhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5ldyBIVE1MNSBhdHRyaWJ1dGUgdmFsdWVzIChlLmcuLCBcInNlYXJjaFwiKSBhcHBlYXIgd2l0aCBlbGVtLnR5cGUgPT09IFwidGV4dFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKGF0dHIgPSBlbGVtLmdldEF0dHJpYnV0ZShcInR5cGVcIikpID09IG51bGwgfHwgYXR0ci50b0xvd2VyQ2FzZSgpID09PSBcInRleHRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUG9zaXRpb24taW4tY29sbGVjdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIFwiZmlyc3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFswXTtcclxuICAgICAgICAgICAgICAgICAgICB9KSxcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgXCJsYXN0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24obWF0Y2hJbmRleGVzLCBsZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtsZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgICAgICAgICB9KSxcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgXCJlcVwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2FyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnRdO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pLFxyXG5cclxuICAgICAgICAgICAgICAgICAgICBcImV2ZW5cIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbihtYXRjaEluZGV4ZXMsIGxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpICs9IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoSW5kZXhlcy5wdXNoKGkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaEluZGV4ZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgfSksXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIFwib2RkXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24obWF0Y2hJbmRleGVzLCBsZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSArPSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaEluZGV4ZXMucHVzaChpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hJbmRleGVzO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pLFxyXG5cclxuICAgICAgICAgICAgICAgICAgICBcImx0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24obWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICg7IC0taSA+PSAwOykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hJbmRleGVzLnB1c2goaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoSW5kZXhlcztcclxuICAgICAgICAgICAgICAgICAgICB9KSxcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgXCJndFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoOyArK2kgPCBsZW5ndGg7KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaEluZGV4ZXMucHVzaChpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hJbmRleGVzO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBFeHByLnBzZXVkb3NbXCJudGhcIl0gPSBFeHByLnBzZXVkb3NbXCJlcVwiXTtcclxuXHJcbiAgICAgICAgICAgIC8vIEFkZCBidXR0b24vaW5wdXQgdHlwZSBwc2V1ZG9zXHJcbiAgICAgICAgICAgIGZvciAoaSBpbiB7IHJhZGlvOiB0cnVlLCBjaGVja2JveDogdHJ1ZSwgZmlsZTogdHJ1ZSwgcGFzc3dvcmQ6IHRydWUsIGltYWdlOiB0cnVlIH0pIHtcclxuICAgICAgICAgICAgICAgIEV4cHIucHNldWRvc1tpXSA9IGNyZWF0ZUlucHV0UHNldWRvKGkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAoaSBpbiB7IHN1Ym1pdDogdHJ1ZSwgcmVzZXQ6IHRydWUgfSkge1xyXG4gICAgICAgICAgICAgICAgRXhwci5wc2V1ZG9zW2ldID0gY3JlYXRlQnV0dG9uUHNldWRvKGkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBFYXN5IEFQSSBmb3IgY3JlYXRpbmcgbmV3IHNldEZpbHRlcnNcclxuICAgICAgICAgICAgZnVuY3Rpb24gc2V0RmlsdGVycygpIHt9XHJcbiAgICAgICAgICAgIHNldEZpbHRlcnMucHJvdG90eXBlID0gRXhwci5maWx0ZXJzID0gRXhwci5wc2V1ZG9zO1xyXG4gICAgICAgICAgICBFeHByLnNldEZpbHRlcnMgPSBuZXcgc2V0RmlsdGVycygpO1xyXG5cclxuICAgICAgICAgICAgdG9rZW5pemUgPSBTaXp6bGUudG9rZW5pemUgPSBmdW5jdGlvbihzZWxlY3RvciwgcGFyc2VPbmx5KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2hlZCwgbWF0Y2gsIHRva2VucywgdHlwZSxcclxuICAgICAgICAgICAgICAgICAgICBzb0ZhciwgZ3JvdXBzLCBwcmVGaWx0ZXJzLFxyXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlZCA9IHRva2VuQ2FjaGVbc2VsZWN0b3IgKyBcIiBcIl07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZU9ubHkgPyAwIDogY2FjaGVkLnNsaWNlKDApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHNvRmFyID0gc2VsZWN0b3I7XHJcbiAgICAgICAgICAgICAgICBncm91cHMgPSBbXTtcclxuICAgICAgICAgICAgICAgIHByZUZpbHRlcnMgPSBFeHByLnByZUZpbHRlcjtcclxuXHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoc29GYXIpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29tbWEgYW5kIGZpcnN0IHJ1blxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghbWF0Y2hlZCB8fCAobWF0Y2ggPSByY29tbWEuZXhlYyhzb0ZhcikpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgY29uc3VtZSB0cmFpbGluZyBjb21tYXMgYXMgdmFsaWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvRmFyID0gc29GYXIuc2xpY2UobWF0Y2hbMF0ubGVuZ3RoKSB8fCBzb0ZhcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cHMucHVzaCgodG9rZW5zID0gW10pKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZWQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29tYmluYXRvcnNcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKG1hdGNoID0gcmNvbWJpbmF0b3JzLmV4ZWMoc29GYXIpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkID0gbWF0Y2guc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG1hdGNoZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDYXN0IGRlc2NlbmRhbnQgY29tYmluYXRvcnMgdG8gc3BhY2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IG1hdGNoWzBdLnJlcGxhY2UocnRyaW0sIFwiIFwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc29GYXIgPSBzb0Zhci5zbGljZShtYXRjaGVkLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBGaWx0ZXJzXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh0eXBlIGluIEV4cHIuZmlsdGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgobWF0Y2ggPSBtYXRjaEV4cHJbdHlwZV0uZXhlYyhzb0ZhcikpICYmICghcHJlRmlsdGVyc1t0eXBlXSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChtYXRjaCA9IHByZUZpbHRlcnNbdHlwZV0obWF0Y2gpKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBtYXRjaGVkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlczogbWF0Y2hcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc29GYXIgPSBzb0Zhci5zbGljZShtYXRjaGVkLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghbWF0Y2hlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBsZW5ndGggb2YgdGhlIGludmFsaWQgZXhjZXNzXHJcbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSdyZSBqdXN0IHBhcnNpbmdcclxuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgdGhyb3cgYW4gZXJyb3Igb3IgcmV0dXJuIHRva2Vuc1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlT25seSA/XHJcbiAgICAgICAgICAgICAgICAgICAgc29GYXIubGVuZ3RoIDpcclxuICAgICAgICAgICAgICAgICAgICBzb0ZhciA/XHJcbiAgICAgICAgICAgICAgICAgICAgU2l6emxlLmVycm9yKHNlbGVjdG9yKSA6XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FjaGUgdGhlIHRva2Vuc1xyXG4gICAgICAgICAgICAgICAgICAgIHRva2VuQ2FjaGUoc2VsZWN0b3IsIGdyb3Vwcykuc2xpY2UoMCk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiB0b1NlbGVjdG9yKHRva2Vucykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGkgPSAwLFxyXG4gICAgICAgICAgICAgICAgICAgIGxlbiA9IHRva2Vucy5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3IgPSBcIlwiO1xyXG4gICAgICAgICAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yICs9IHRva2Vuc1tpXS52YWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxlY3RvcjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gYWRkQ29tYmluYXRvcihtYXRjaGVyLCBjb21iaW5hdG9yLCBiYXNlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGlyID0gY29tYmluYXRvci5kaXIsXHJcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tOb25FbGVtZW50cyA9IGJhc2UgJiYgZGlyID09PSBcInBhcmVudE5vZGVcIixcclxuICAgICAgICAgICAgICAgICAgICBkb25lTmFtZSA9IGRvbmUrKztcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tYmluYXRvci5maXJzdCA/XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgYWdhaW5zdCBjbG9zZXN0IGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oZWxlbSwgY29udGV4dCwgeG1sKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgoZWxlbSA9IGVsZW1bZGlyXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hlcihlbGVtLCBjb250ZXh0LCB4bWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSA6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGFnYWluc3QgYWxsIGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50c1xyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGVsZW0sIGNvbnRleHQsIHhtbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2xkQ2FjaGUsIG91dGVyQ2FjaGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdDYWNoZSA9IFtkaXJydW5zLCBkb25lTmFtZV07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBjYW4ndCBzZXQgYXJiaXRyYXJ5IGRhdGEgb24gWE1MIG5vZGVzLCBzbyB0aGV5IGRvbid0IGJlbmVmaXQgZnJvbSBkaXIgY2FjaGluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoeG1sKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKGVsZW0gPSBlbGVtW2Rpcl0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hlcihlbGVtLCBjb250ZXh0LCB4bWwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgoZWxlbSA9IGVsZW1bZGlyXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dGVyQ2FjaGUgPSBlbGVtW2V4cGFuZG9dIHx8IChlbGVtW2V4cGFuZG9dID0ge30pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKG9sZENhY2hlID0gb3V0ZXJDYWNoZVtkaXJdKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkQ2FjaGVbMF0gPT09IGRpcnJ1bnMgJiYgb2xkQ2FjaGVbMV0gPT09IGRvbmVOYW1lKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXNzaWduIHRvIG5ld0NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAobmV3Q2FjaGVbMl0gPSBvbGRDYWNoZVsyXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXVzZSBuZXdjYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRlckNhY2hlW2Rpcl0gPSBuZXdDYWNoZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBIG1hdGNoIG1lYW5zIHdlJ3JlIGRvbmU7IGEgZmFpbCBtZWFucyB3ZSBoYXZlIHRvIGtlZXAgY2hlY2tpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgobmV3Q2FjaGVbMl0gPSBtYXRjaGVyKGVsZW0sIGNvbnRleHQsIHhtbCkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBlbGVtZW50TWF0Y2hlcihtYXRjaGVycykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXJzLmxlbmd0aCA+IDEgP1xyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGVsZW0sIGNvbnRleHQsIHhtbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IG1hdGNoZXJzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXRjaGVyc1tpXShlbGVtLCBjb250ZXh0LCB4bWwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gOlxyXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZXJzWzBdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBtdWx0aXBsZUNvbnRleHRzKHNlbGVjdG9yLCBjb250ZXh0cywgcmVzdWx0cykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGkgPSAwLFxyXG4gICAgICAgICAgICAgICAgICAgIGxlbiA9IGNvbnRleHRzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBTaXp6bGUoc2VsZWN0b3IsIGNvbnRleHRzW2ldLCByZXN1bHRzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBjb25kZW5zZSh1bm1hdGNoZWQsIG1hcCwgZmlsdGVyLCBjb250ZXh0LCB4bWwpIHtcclxuICAgICAgICAgICAgICAgIHZhciBlbGVtLFxyXG4gICAgICAgICAgICAgICAgICAgIG5ld1VubWF0Y2hlZCA9IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgIGkgPSAwLFxyXG4gICAgICAgICAgICAgICAgICAgIGxlbiA9IHVubWF0Y2hlZC5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICAgICAgbWFwcGVkID0gbWFwICE9IG51bGw7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgoZWxlbSA9IHVubWF0Y2hlZFtpXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWx0ZXIgfHwgZmlsdGVyKGVsZW0sIGNvbnRleHQsIHhtbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1VubWF0Y2hlZC5wdXNoKGVsZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hcHBlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcC5wdXNoKGkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXdVbm1hdGNoZWQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHNldE1hdGNoZXIocHJlRmlsdGVyLCBzZWxlY3RvciwgbWF0Y2hlciwgcG9zdEZpbHRlciwgcG9zdEZpbmRlciwgcG9zdFNlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocG9zdEZpbHRlciAmJiAhcG9zdEZpbHRlcltleHBhbmRvXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBvc3RGaWx0ZXIgPSBzZXRNYXRjaGVyKHBvc3RGaWx0ZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHBvc3RGaW5kZXIgJiYgIXBvc3RGaW5kZXJbZXhwYW5kb10pIHtcclxuICAgICAgICAgICAgICAgICAgICBwb3N0RmluZGVyID0gc2V0TWF0Y2hlcihwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbihzZWVkLCByZXN1bHRzLCBjb250ZXh0LCB4bWwpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcCwgaSwgZWxlbSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlTWFwID0gW10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc3RNYXAgPSBbXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZXhpc3RpbmcgPSByZXN1bHRzLmxlbmd0aCxcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCBpbml0aWFsIGVsZW1lbnRzIGZyb20gc2VlZCBvciBjb250ZXh0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1zID0gc2VlZCB8fCBtdWx0aXBsZUNvbnRleHRzKHNlbGVjdG9yIHx8IFwiKlwiLCBjb250ZXh0Lm5vZGVUeXBlID8gW2NvbnRleHRdIDogY29udGV4dCwgW10pLFxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJlZmlsdGVyIHRvIGdldCBtYXRjaGVyIGlucHV0LCBwcmVzZXJ2aW5nIGEgbWFwIGZvciBzZWVkLXJlc3VsdHMgc3luY2hyb25pemF0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXJJbiA9IHByZUZpbHRlciAmJiAoc2VlZCB8fCAhc2VsZWN0b3IpID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZGVuc2UoZWxlbXMsIHByZU1hcCwgcHJlRmlsdGVyLCBjb250ZXh0LCB4bWwpIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbXMsXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVyT3V0ID0gbWF0Y2hlciA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYSBwb3N0RmluZGVyLCBvciBmaWx0ZXJlZCBzZWVkLCBvciBub24tc2VlZCBwb3N0RmlsdGVyIG9yIHByZWV4aXN0aW5nIHJlc3VsdHMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc3RGaW5kZXIgfHwgKHNlZWQgPyBwcmVGaWx0ZXIgOiBwcmVleGlzdGluZyB8fCBwb3N0RmlsdGVyKSA/XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAuLi5pbnRlcm1lZGlhdGUgcHJvY2Vzc2luZyBpcyBuZWNlc3NhcnlcclxuICAgICAgICAgICAgICAgICAgICAgICAgW10gOlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gLi4ub3RoZXJ3aXNlIHVzZSByZXN1bHRzIGRpcmVjdGx5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVySW47XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpbmQgcHJpbWFyeSBtYXRjaGVzXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcihtYXRjaGVySW4sIG1hdGNoZXJPdXQsIGNvbnRleHQsIHhtbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBwb3N0RmlsdGVyXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvc3RGaWx0ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcCA9IGNvbmRlbnNlKG1hdGNoZXJPdXQsIHBvc3RNYXApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3N0RmlsdGVyKHRlbXAsIFtdLCBjb250ZXh0LCB4bWwpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVW4tbWF0Y2ggZmFpbGluZyBlbGVtZW50cyBieSBtb3ZpbmcgdGhlbSBiYWNrIHRvIG1hdGNoZXJJblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gdGVtcC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoZWxlbSA9IHRlbXBbaV0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlck91dFtwb3N0TWFwW2ldXSA9ICEobWF0Y2hlckluW3Bvc3RNYXBbaV1dID0gZWxlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb3N0RmluZGVyIHx8IHByZUZpbHRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvc3RGaW5kZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIGZpbmFsIG1hdGNoZXJPdXQgYnkgY29uZGVuc2luZyB0aGlzIGludGVybWVkaWF0ZSBpbnRvIHBvc3RGaW5kZXIgY29udGV4dHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChlbGVtID0gbWF0Y2hlck91dFtpXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlc3RvcmUgbWF0Y2hlckluIHNpbmNlIGVsZW0gaXMgbm90IHlldCBhIGZpbmFsIG1hdGNoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wLnB1c2goKG1hdGNoZXJJbltpXSA9IGVsZW0pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3N0RmluZGVyKG51bGwsIChtYXRjaGVyT3V0ID0gW10pLCB0ZW1wLCB4bWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1vdmUgbWF0Y2hlZCBlbGVtZW50cyBmcm9tIHNlZWQgdG8gcmVzdWx0cyB0byBrZWVwIHRoZW0gc3luY2hyb25pemVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gbWF0Y2hlck91dC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChlbGVtID0gbWF0Y2hlck91dFtpXSkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHRlbXAgPSBwb3N0RmluZGVyID8gaW5kZXhPZi5jYWxsKHNlZWQsIGVsZW0pIDogcHJlTWFwW2ldKSA+IC0xKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWVkW3RlbXBdID0gIShyZXN1bHRzW3RlbXBdID0gZWxlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgZWxlbWVudHMgdG8gcmVzdWx0cywgdGhyb3VnaCBwb3N0RmluZGVyIGlmIGRlZmluZWRcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVyT3V0ID0gY29uZGVuc2UoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVyT3V0ID09PSByZXN1bHRzID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXJPdXQuc3BsaWNlKHByZWV4aXN0aW5nLCBtYXRjaGVyT3V0Lmxlbmd0aCkgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlck91dFxyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocG9zdEZpbmRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zdEZpbmRlcihudWxsLCByZXN1bHRzLCBtYXRjaGVyT3V0LCB4bWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVzaC5hcHBseShyZXN1bHRzLCBtYXRjaGVyT3V0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBtYXRjaGVyRnJvbVRva2Vucyh0b2tlbnMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjaGVja0NvbnRleHQsIG1hdGNoZXIsIGosXHJcbiAgICAgICAgICAgICAgICAgICAgbGVuID0gdG9rZW5zLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgICAgICBsZWFkaW5nUmVsYXRpdmUgPSBFeHByLnJlbGF0aXZlW3Rva2Vuc1swXS50eXBlXSxcclxuICAgICAgICAgICAgICAgICAgICBpbXBsaWNpdFJlbGF0aXZlID0gbGVhZGluZ1JlbGF0aXZlIHx8IEV4cHIucmVsYXRpdmVbXCIgXCJdLFxyXG4gICAgICAgICAgICAgICAgICAgIGkgPSBsZWFkaW5nUmVsYXRpdmUgPyAxIDogMCxcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGZvdW5kYXRpb25hbCBtYXRjaGVyIGVuc3VyZXMgdGhhdCBlbGVtZW50cyBhcmUgcmVhY2hhYmxlIGZyb20gdG9wLWxldmVsIGNvbnRleHQocylcclxuICAgICAgICAgICAgICAgICAgICBtYXRjaENvbnRleHQgPSBhZGRDb21iaW5hdG9yKGZ1bmN0aW9uKGVsZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0gPT09IGNoZWNrQ29udGV4dDtcclxuICAgICAgICAgICAgICAgICAgICB9LCBpbXBsaWNpdFJlbGF0aXZlLCB0cnVlKSxcclxuICAgICAgICAgICAgICAgICAgICBtYXRjaEFueUNvbnRleHQgPSBhZGRDb21iaW5hdG9yKGZ1bmN0aW9uKGVsZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4T2YuY2FsbChjaGVja0NvbnRleHQsIGVsZW0pID4gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgaW1wbGljaXRSZWxhdGl2ZSwgdHJ1ZSksXHJcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcnMgPSBbZnVuY3Rpb24oZWxlbSwgY29udGV4dCwgeG1sKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoIWxlYWRpbmdSZWxhdGl2ZSAmJiAoeG1sIHx8IGNvbnRleHQgIT09IG91dGVybW9zdENvbnRleHQpKSB8fCAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoY2hlY2tDb250ZXh0ID0gY29udGV4dCkubm9kZVR5cGUgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hDb250ZXh0KGVsZW0sIGNvbnRleHQsIHhtbCkgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hBbnlDb250ZXh0KGVsZW0sIGNvbnRleHQsIHhtbCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1dO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKG1hdGNoZXIgPSBFeHByLnJlbGF0aXZlW3Rva2Vuc1tpXS50eXBlXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcnMgPSBbYWRkQ29tYmluYXRvcihlbGVtZW50TWF0Y2hlcihtYXRjaGVycyksIG1hdGNoZXIpXTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVyID0gRXhwci5maWx0ZXJbdG9rZW5zW2ldLnR5cGVdLmFwcGx5KG51bGwsIHRva2Vuc1tpXS5tYXRjaGVzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldHVybiBzcGVjaWFsIHVwb24gc2VlaW5nIGEgcG9zaXRpb25hbCBtYXRjaGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVyW2V4cGFuZG9dKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGaW5kIHRoZSBuZXh0IHJlbGF0aXZlIG9wZXJhdG9yIChpZiBhbnkpIGZvciBwcm9wZXIgaGFuZGxpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGogPSArK2k7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKDsgaiA8IGxlbjsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEV4cHIucmVsYXRpdmVbdG9rZW5zW2pdLnR5cGVdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXRNYXRjaGVyKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPiAxICYmIGVsZW1lbnRNYXRjaGVyKG1hdGNoZXJzKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID4gMSAmJiB0b1NlbGVjdG9yKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcHJlY2VkaW5nIHRva2VuIHdhcyBhIGRlc2NlbmRhbnQgY29tYmluYXRvciwgaW5zZXJ0IGFuIGltcGxpY2l0IGFueS1lbGVtZW50IGAqYFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnMuc2xpY2UoMCwgaSAtIDEpLmNvbmNhdCh7IHZhbHVlOiB0b2tlbnNbaSAtIDJdLnR5cGUgPT09IFwiIFwiID8gXCIqXCIgOiBcIlwiIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKS5yZXBsYWNlKHJ0cmltLCBcIiQxXCIpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA8IGogJiYgbWF0Y2hlckZyb21Ub2tlbnModG9rZW5zLnNsaWNlKGksIGopKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqIDwgbGVuICYmIG1hdGNoZXJGcm9tVG9rZW5zKCh0b2tlbnMgPSB0b2tlbnMuc2xpY2UoaikpKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqIDwgbGVuICYmIHRvU2VsZWN0b3IodG9rZW5zKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVycy5wdXNoKG1hdGNoZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudE1hdGNoZXIobWF0Y2hlcnMpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoZWxlbWVudE1hdGNoZXJzLCBzZXRNYXRjaGVycykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGJ5U2V0ID0gc2V0TWF0Y2hlcnMubGVuZ3RoID4gMCxcclxuICAgICAgICAgICAgICAgICAgICBieUVsZW1lbnQgPSBlbGVtZW50TWF0Y2hlcnMubGVuZ3RoID4gMCxcclxuICAgICAgICAgICAgICAgICAgICBzdXBlck1hdGNoZXIgPSBmdW5jdGlvbihzZWVkLCBjb250ZXh0LCB4bWwsIHJlc3VsdHMsIG91dGVybW9zdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbSwgaiwgbWF0Y2hlcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWRDb3VudCA9IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gXCIwXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bm1hdGNoZWQgPSBzZWVkICYmIFtdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0TWF0Y2hlZCA9IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dEJhY2t1cCA9IG91dGVybW9zdENvbnRleHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBtdXN0IGFsd2F5cyBoYXZlIGVpdGhlciBzZWVkIGVsZW1lbnRzIG9yIG91dGVybW9zdCBjb250ZXh0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtcyA9IHNlZWQgfHwgYnlFbGVtZW50ICYmIEV4cHIuZmluZFtcIlRBR1wiXShcIipcIiwgb3V0ZXJtb3N0KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSBpbnRlZ2VyIGRpcnJ1bnMgaWZmIHRoaXMgaXMgdGhlIG91dGVybW9zdCBtYXRjaGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXJydW5zVW5pcXVlID0gKGRpcnJ1bnMgKz0gY29udGV4dEJhY2t1cCA9PSBudWxsID8gMSA6IE1hdGgucmFuZG9tKCkgfHwgMC4xKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbiA9IGVsZW1zLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdXRlcm1vc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0ICE9PSBkb2N1bWVudCAmJiBjb250ZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgZWxlbWVudHMgcGFzc2luZyBlbGVtZW50TWF0Y2hlcnMgZGlyZWN0bHkgdG8gcmVzdWx0c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBLZWVwIGBpYCBhIHN0cmluZyBpZiB0aGVyZSBhcmUgbm8gZWxlbWVudHMgc28gYG1hdGNoZWRDb3VudGAgd2lsbCBiZSBcIjAwXCIgYmVsb3dcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUU8OSwgU2FmYXJpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRvbGVyYXRlIE5vZGVMaXN0IHByb3BlcnRpZXMgKElFOiBcImxlbmd0aFwiOyBTYWZhcmk6IDxudW1iZXI+KSBtYXRjaGluZyBlbGVtZW50cyBieSBpZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKDsgaSAhPT0gbGVuICYmIChlbGVtID0gZWxlbXNbaV0pICE9IG51bGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJ5RWxlbWVudCAmJiBlbGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaiA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChtYXRjaGVyID0gZWxlbWVudE1hdGNoZXJzW2orK10pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVyKGVsZW0sIGNvbnRleHQsIHhtbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChlbGVtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdXRlcm1vc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyYWNrIHVubWF0Y2hlZCBlbGVtZW50cyBmb3Igc2V0IGZpbHRlcnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChieVNldCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZXkgd2lsbCBoYXZlIGdvbmUgdGhyb3VnaCBhbGwgcG9zc2libGUgbWF0Y2hlcnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGVsZW0gPSAhbWF0Y2hlciAmJiBlbGVtKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkQ291bnQtLTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExlbmd0aGVuIHRoZSBhcnJheSBmb3IgZXZlcnkgZWxlbWVudCwgbWF0Y2hlZCBvciBub3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bm1hdGNoZWQucHVzaChlbGVtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFwcGx5IHNldCBmaWx0ZXJzIHRvIHVubWF0Y2hlZCBlbGVtZW50c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkQ291bnQgKz0gaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJ5U2V0ICYmIGkgIT09IG1hdGNoZWRDb3VudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaiA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKG1hdGNoZXIgPSBzZXRNYXRjaGVyc1tqKytdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXIodW5tYXRjaGVkLCBzZXRNYXRjaGVkLCBjb250ZXh0LCB4bWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVpbnRlZ3JhdGUgZWxlbWVudCBtYXRjaGVzIHRvIGVsaW1pbmF0ZSB0aGUgbmVlZCBmb3Igc29ydGluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVkQ291bnQgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHVubWF0Y2hlZFtpXSB8fCBzZXRNYXRjaGVkW2ldKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldE1hdGNoZWRbaV0gPSBwb3AuY2FsbChyZXN1bHRzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGlzY2FyZCBpbmRleCBwbGFjZWhvbGRlciB2YWx1ZXMgdG8gZ2V0IG9ubHkgYWN0dWFsIG1hdGNoZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRNYXRjaGVkID0gY29uZGVuc2Uoc2V0TWF0Y2hlZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIG1hdGNoZXMgdG8gcmVzdWx0c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVzaC5hcHBseShyZXN1bHRzLCBzZXRNYXRjaGVkKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTZWVkbGVzcyBzZXQgbWF0Y2hlcyBzdWNjZWVkaW5nIG11bHRpcGxlIHN1Y2Nlc3NmdWwgbWF0Y2hlcnMgc3RpcHVsYXRlIHNvcnRpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdXRlcm1vc3QgJiYgIXNlZWQgJiYgc2V0TWF0Y2hlZC5sZW5ndGggPiAwICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG1hdGNoZWRDb3VudCArIHNldE1hdGNoZXJzLmxlbmd0aCkgPiAxKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNpenpsZS51bmlxdWVTb3J0KHJlc3VsdHMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPdmVycmlkZSBtYW5pcHVsYXRpb24gb2YgZ2xvYmFscyBieSBuZXN0ZWQgbWF0Y2hlcnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG91dGVybW9zdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dEJhY2t1cDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVubWF0Y2hlZDtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBieVNldCA/XHJcbiAgICAgICAgICAgICAgICAgICAgbWFya0Z1bmN0aW9uKHN1cGVyTWF0Y2hlcikgOlxyXG4gICAgICAgICAgICAgICAgICAgIHN1cGVyTWF0Y2hlcjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29tcGlsZSA9IFNpenpsZS5jb21waWxlID0gZnVuY3Rpb24oc2VsZWN0b3IsIG1hdGNoIC8qIEludGVybmFsIFVzZSBPbmx5ICovICkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGksXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0TWF0Y2hlcnMgPSBbXSxcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50TWF0Y2hlcnMgPSBbXSxcclxuICAgICAgICAgICAgICAgICAgICBjYWNoZWQgPSBjb21waWxlckNhY2hlW3NlbGVjdG9yICsgXCIgXCJdO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICghY2FjaGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gR2VuZXJhdGUgYSBmdW5jdGlvbiBvZiByZWN1cnNpdmUgZnVuY3Rpb25zIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2hlY2sgZWFjaCBlbGVtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXRjaCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IHRva2VuaXplKHNlbGVjdG9yKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaSA9IG1hdGNoLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlZCA9IG1hdGNoZXJGcm9tVG9rZW5zKG1hdGNoW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhY2hlZFtleHBhbmRvXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0TWF0Y2hlcnMucHVzaChjYWNoZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudE1hdGNoZXJzLnB1c2goY2FjaGVkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FjaGUgdGhlIGNvbXBpbGVkIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVkID0gY29tcGlsZXJDYWNoZShzZWxlY3RvciwgbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU2F2ZSBzZWxlY3RvciBhbmQgdG9rZW5pemF0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVkLnNlbGVjdG9yID0gc2VsZWN0b3I7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEEgbG93LWxldmVsIHNlbGVjdGlvbiBmdW5jdGlvbiB0aGF0IHdvcmtzIHdpdGggU2l6emxlJ3MgY29tcGlsZWRcclxuICAgICAgICAgICAgICogIHNlbGVjdG9yIGZ1bmN0aW9uc1xyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gc2VsZWN0b3IgQSBzZWxlY3RvciBvciBhIHByZS1jb21waWxlZFxyXG4gICAgICAgICAgICAgKiAgc2VsZWN0b3IgZnVuY3Rpb24gYnVpbHQgd2l0aCBTaXp6bGUuY29tcGlsZVxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRleHRcclxuICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdHNdXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IFtzZWVkXSBBIHNldCBvZiBlbGVtZW50cyB0byBtYXRjaCBhZ2FpbnN0XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBzZWxlY3QgPSBTaXp6bGUuc2VsZWN0ID0gZnVuY3Rpb24oc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpLCB0b2tlbnMsIHRva2VuLCB0eXBlLCBmaW5kLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBpbGVkID0gdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgc2VsZWN0b3IsXHJcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSAhc2VlZCAmJiB0b2tlbml6ZSgoc2VsZWN0b3IgPSBjb21waWxlZC5zZWxlY3RvciB8fCBzZWxlY3RvcikpO1xyXG5cclxuICAgICAgICAgICAgICAgIHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFRyeSB0byBtaW5pbWl6ZSBvcGVyYXRpb25zIGlmIHRoZXJlIGlzIG5vIHNlZWQgYW5kIG9ubHkgb25lIGdyb3VwXHJcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2gubGVuZ3RoID09PSAxKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRha2UgYSBzaG9ydGN1dCBhbmQgc2V0IHRoZSBjb250ZXh0IGlmIHRoZSByb290IHNlbGVjdG9yIGlzIGFuIElEXHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zID0gbWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSgwKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW5zLmxlbmd0aCA+IDIgJiYgKHRva2VuID0gdG9rZW5zWzBdKS50eXBlID09PSBcIklEXCIgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3VwcG9ydC5nZXRCeUlkICYmIGNvbnRleHQubm9kZVR5cGUgPT09IDkgJiYgZG9jdW1lbnRJc0hUTUwgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgRXhwci5yZWxhdGl2ZVt0b2tlbnNbMV0udHlwZV0pIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQgPSAoRXhwci5maW5kW1wiSURcIl0odG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKHJ1bmVzY2FwZSwgZnVuZXNjYXBlKSwgY29udGV4dCkgfHwgW10pWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbnRleHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFByZWNvbXBpbGVkIG1hdGNoZXJzIHdpbGwgc3RpbGwgdmVyaWZ5IGFuY2VzdHJ5LCBzbyBzdGVwIHVwIGEgbGV2ZWxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb21waWxlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dCA9IGNvbnRleHQucGFyZW50Tm9kZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3IgPSBzZWxlY3Rvci5zbGljZSh0b2tlbnMuc2hpZnQoKS52YWx1ZS5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRmV0Y2ggYSBzZWVkIHNldCBmb3IgcmlnaHQtdG8tbGVmdCBtYXRjaGluZ1xyXG4gICAgICAgICAgICAgICAgICAgIGkgPSBtYXRjaEV4cHJbXCJuZWVkc0NvbnRleHRcIl0udGVzdChzZWxlY3RvcikgPyAwIDogdG9rZW5zLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWJvcnQgaWYgd2UgaGl0IGEgY29tYmluYXRvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoRXhwci5yZWxhdGl2ZVsodHlwZSA9IHRva2VuLnR5cGUpXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChmaW5kID0gRXhwci5maW5kW3R5cGVdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2VhcmNoLCBleHBhbmRpbmcgY29udGV4dCBmb3IgbGVhZGluZyBzaWJsaW5nIGNvbWJpbmF0b3JzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHNlZWQgPSBmaW5kKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbi5tYXRjaGVzWzBdLnJlcGxhY2UocnVuZXNjYXBlLCBmdW5lc2NhcGUpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByc2libGluZy50ZXN0KHRva2Vuc1swXS50eXBlKSAmJiB0ZXN0Q29udGV4dChjb250ZXh0LnBhcmVudE5vZGUpIHx8IGNvbnRleHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApKSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBzZWVkIGlzIGVtcHR5IG9yIG5vIHRva2VucyByZW1haW4sIHdlIGNhbiByZXR1cm4gZWFybHlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yID0gc2VlZC5sZW5ndGggJiYgdG9TZWxlY3Rvcih0b2tlbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVzaC5hcHBseShyZXN1bHRzLCBzZWVkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDb21waWxlIGFuZCBleGVjdXRlIGEgZmlsdGVyaW5nIGZ1bmN0aW9uIGlmIG9uZSBpcyBub3QgcHJvdmlkZWRcclxuICAgICAgICAgICAgICAgIC8vIFByb3ZpZGUgYG1hdGNoYCB0byBhdm9pZCByZXRva2VuaXphdGlvbiBpZiB3ZSBtb2RpZmllZCB0aGUgc2VsZWN0b3IgYWJvdmVcclxuICAgICAgICAgICAgICAgIChjb21waWxlZCB8fCBjb21waWxlKHNlbGVjdG9yLCBtYXRjaCkpKFxyXG4gICAgICAgICAgICAgICAgICAgIHNlZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dCwgIWRvY3VtZW50SXNIVE1MLFxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMsXHJcbiAgICAgICAgICAgICAgICAgICAgcnNpYmxpbmcudGVzdChzZWxlY3RvcikgJiYgdGVzdENvbnRleHQoY29udGV4dC5wYXJlbnROb2RlKSB8fCBjb250ZXh0XHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvLyBPbmUtdGltZSBhc3NpZ25tZW50c1xyXG5cclxuICAgICAgICAgICAgLy8gU29ydCBzdGFiaWxpdHlcclxuICAgICAgICAgICAgc3VwcG9ydC5zb3J0U3RhYmxlID0gZXhwYW5kby5zcGxpdChcIlwiKS5zb3J0KHNvcnRPcmRlcikuam9pbihcIlwiKSA9PT0gZXhwYW5kbztcclxuXHJcbiAgICAgICAgICAgIC8vIFN1cHBvcnQ6IENocm9tZTwxNFxyXG4gICAgICAgICAgICAvLyBBbHdheXMgYXNzdW1lIGR1cGxpY2F0ZXMgaWYgdGhleSBhcmVuJ3QgcGFzc2VkIHRvIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgIHN1cHBvcnQuZGV0ZWN0RHVwbGljYXRlcyA9ICEhaGFzRHVwbGljYXRlO1xyXG5cclxuICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZSBhZ2FpbnN0IHRoZSBkZWZhdWx0IGRvY3VtZW50XHJcbiAgICAgICAgICAgIHNldERvY3VtZW50KCk7XHJcblxyXG4gICAgICAgICAgICAvLyBTdXBwb3J0OiBXZWJraXQ8NTM3LjMyIC0gU2FmYXJpIDYuMC4zL0Nocm9tZSAyNSAoZml4ZWQgaW4gQ2hyb21lIDI3KVxyXG4gICAgICAgICAgICAvLyBEZXRhY2hlZCBub2RlcyBjb25mb3VuZGluZ2x5IGZvbGxvdyAqZWFjaCBvdGhlcipcclxuICAgICAgICAgICAgc3VwcG9ydC5zb3J0RGV0YWNoZWQgPSBhc3NlcnQoZnVuY3Rpb24oZGl2MSkge1xyXG4gICAgICAgICAgICAgICAgLy8gU2hvdWxkIHJldHVybiAxLCBidXQgcmV0dXJucyA0IChmb2xsb3dpbmcpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGl2MS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKSAmIDE7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgLy8gU3VwcG9ydDogSUU8OFxyXG4gICAgICAgICAgICAvLyBQcmV2ZW50IGF0dHJpYnV0ZS9wcm9wZXJ0eSBcImludGVycG9sYXRpb25cIlxyXG4gICAgICAgICAgICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1MzY0MjklMjhWUy44NSUyOS5hc3B4XHJcbiAgICAgICAgICAgIGlmICghYXNzZXJ0KGZ1bmN0aW9uKGRpdikge1xyXG4gICAgICAgICAgICAgICAgICAgIGRpdi5pbm5lckhUTUwgPSBcIjxhIGhyZWY9JyMnPjwvYT5cIjtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGl2LmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSA9PT0gXCIjXCI7XHJcbiAgICAgICAgICAgICAgICB9KSkge1xyXG4gICAgICAgICAgICAgICAgYWRkSGFuZGxlKFwidHlwZXxocmVmfGhlaWdodHx3aWR0aFwiLCBmdW5jdGlvbihlbGVtLCBuYW1lLCBpc1hNTCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNYTUwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKG5hbWUsIG5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJ0eXBlXCIgPyAxIDogMik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFPDlcclxuICAgICAgICAgICAgLy8gVXNlIGRlZmF1bHRWYWx1ZSBpbiBwbGFjZSBvZiBnZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKVxyXG4gICAgICAgICAgICBpZiAoIXN1cHBvcnQuYXR0cmlidXRlcyB8fCAhYXNzZXJ0KGZ1bmN0aW9uKGRpdikge1xyXG4gICAgICAgICAgICAgICAgICAgIGRpdi5pbm5lckhUTUwgPSBcIjxpbnB1dC8+XCI7XHJcbiAgICAgICAgICAgICAgICAgICAgZGl2LmZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKFwidmFsdWVcIiwgXCJcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpdi5maXJzdENoaWxkLmdldEF0dHJpYnV0ZShcInZhbHVlXCIpID09PSBcIlwiO1xyXG4gICAgICAgICAgICAgICAgfSkpIHtcclxuICAgICAgICAgICAgICAgIGFkZEhhbmRsZShcInZhbHVlXCIsIGZ1bmN0aW9uKGVsZW0sIG5hbWUsIGlzWE1MKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1hNTCAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5kZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFPDlcclxuICAgICAgICAgICAgLy8gVXNlIGdldEF0dHJpYnV0ZU5vZGUgdG8gZmV0Y2ggYm9vbGVhbnMgd2hlbiBnZXRBdHRyaWJ1dGUgbGllc1xyXG4gICAgICAgICAgICBpZiAoIWFzc2VydChmdW5jdGlvbihkaXYpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGl2LmdldEF0dHJpYnV0ZShcImRpc2FibGVkXCIpID09IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9KSkge1xyXG4gICAgICAgICAgICAgICAgYWRkSGFuZGxlKGJvb2xlYW5zLCBmdW5jdGlvbihlbGVtLCBuYW1lLCBpc1hNTCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWw7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1hNTCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbVtuYW1lXSA9PT0gdHJ1ZSA/IG5hbWUudG9Mb3dlckNhc2UoKSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAodmFsID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKG5hbWUpKSAmJiB2YWwuc3BlY2lmaWVkID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbC52YWx1ZSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gU2l6emxlO1xyXG5cclxuICAgICAgICB9KSh3aW5kb3cpO1xyXG5cclxuXHJcblxyXG4gICAgalF1ZXJ5LmZpbmQgPSBTaXp6bGU7XHJcbiAgICBqUXVlcnkuZXhwciA9IFNpenpsZS5zZWxlY3RvcnM7XHJcbiAgICBqUXVlcnkuZXhwcltcIjpcIl0gPSBqUXVlcnkuZXhwci5wc2V1ZG9zO1xyXG4gICAgalF1ZXJ5LnVuaXF1ZSA9IFNpenpsZS51bmlxdWVTb3J0O1xyXG4gICAgalF1ZXJ5LnRleHQgPSBTaXp6bGUuZ2V0VGV4dDtcclxuICAgIGpRdWVyeS5pc1hNTERvYyA9IFNpenpsZS5pc1hNTDtcclxuICAgIGpRdWVyeS5jb250YWlucyA9IFNpenpsZS5jb250YWlucztcclxuXHJcblxyXG5cclxuICAgIHZhciBybmVlZHNDb250ZXh0ID0galF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0O1xyXG5cclxuICAgIHZhciByc2luZ2xlVGFnID0gKC9ePChcXHcrKVxccypcXC8/Pig/OjxcXC9cXDE+fCkkLyk7XHJcblxyXG5cclxuXHJcbiAgICB2YXIgcmlzU2ltcGxlID0gL14uW146I1xcW1xcLixdKiQvO1xyXG5cclxuICAgIC8vIEltcGxlbWVudCB0aGUgaWRlbnRpY2FsIGZ1bmN0aW9uYWxpdHkgZm9yIGZpbHRlciBhbmQgbm90XHJcbiAgICBmdW5jdGlvbiB3aW5ub3coZWxlbWVudHMsIHF1YWxpZmllciwgbm90KSB7XHJcbiAgICAgICAgaWYgKGpRdWVyeS5pc0Z1bmN0aW9uKHF1YWxpZmllcikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5ncmVwKGVsZW1lbnRzLCBmdW5jdGlvbihlbGVtLCBpKSB7XHJcbiAgICAgICAgICAgICAgICAvKiBqc2hpbnQgLVcwMTggKi9cclxuICAgICAgICAgICAgICAgIHJldHVybiAhIXF1YWxpZmllci5jYWxsKGVsZW0sIGksIGVsZW0pICE9PSBub3Q7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChxdWFsaWZpZXIubm9kZVR5cGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5ncmVwKGVsZW1lbnRzLCBmdW5jdGlvbihlbGVtKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKGVsZW0gPT09IHF1YWxpZmllcikgIT09IG5vdDtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBxdWFsaWZpZXIgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgaWYgKHJpc1NpbXBsZS50ZXN0KHF1YWxpZmllcikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBqUXVlcnkuZmlsdGVyKHF1YWxpZmllciwgZWxlbWVudHMsIG5vdCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHF1YWxpZmllciA9IGpRdWVyeS5maWx0ZXIocXVhbGlmaWVyLCBlbGVtZW50cyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4galF1ZXJ5LmdyZXAoZWxlbWVudHMsIGZ1bmN0aW9uKGVsZW0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIChpbmRleE9mLmNhbGwocXVhbGlmaWVyLCBlbGVtKSA+PSAwKSAhPT0gbm90O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGpRdWVyeS5maWx0ZXIgPSBmdW5jdGlvbihleHByLCBlbGVtcywgbm90KSB7XHJcbiAgICAgICAgdmFyIGVsZW0gPSBlbGVtc1swXTtcclxuXHJcbiAgICAgICAgaWYgKG5vdCkge1xyXG4gICAgICAgICAgICBleHByID0gXCI6bm90KFwiICsgZXhwciArIFwiKVwiO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGVsZW1zLmxlbmd0aCA9PT0gMSAmJiBlbGVtLm5vZGVUeXBlID09PSAxID9cclxuICAgICAgICAgICAgalF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKGVsZW0sIGV4cHIpID8gW2VsZW1dIDogW10gOlxyXG4gICAgICAgICAgICBqUXVlcnkuZmluZC5tYXRjaGVzKGV4cHIsIGpRdWVyeS5ncmVwKGVsZW1zLCBmdW5jdGlvbihlbGVtKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5ub2RlVHlwZSA9PT0gMTtcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBqUXVlcnkuZm4uZXh0ZW5kKHtcclxuICAgICAgICBmaW5kOiBmdW5jdGlvbihzZWxlY3Rvcikge1xyXG4gICAgICAgICAgICB2YXIgaSxcclxuICAgICAgICAgICAgICAgIGxlbiA9IHRoaXMubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgcmV0ID0gW10sXHJcbiAgICAgICAgICAgICAgICBzZWxmID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayhqUXVlcnkoc2VsZWN0b3IpLmZpbHRlcihmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpRdWVyeS5jb250YWlucyhzZWxmW2ldLCB0aGlzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgalF1ZXJ5LmZpbmQoc2VsZWN0b3IsIHNlbGZbaV0sIHJldCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIE5lZWRlZCBiZWNhdXNlICQoIHNlbGVjdG9yLCBjb250ZXh0ICkgYmVjb21lcyAkKCBjb250ZXh0ICkuZmluZCggc2VsZWN0b3IgKVxyXG4gICAgICAgICAgICByZXQgPSB0aGlzLnB1c2hTdGFjayhsZW4gPiAxID8galF1ZXJ5LnVuaXF1ZShyZXQpIDogcmV0KTtcclxuICAgICAgICAgICAgcmV0LnNlbGVjdG9yID0gdGhpcy5zZWxlY3RvciA/IHRoaXMuc2VsZWN0b3IgKyBcIiBcIiArIHNlbGVjdG9yIDogc2VsZWN0b3I7XHJcbiAgICAgICAgICAgIHJldHVybiByZXQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBmaWx0ZXI6IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayh3aW5ub3codGhpcywgc2VsZWN0b3IgfHwgW10sIGZhbHNlKSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBub3Q6IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayh3aW5ub3codGhpcywgc2VsZWN0b3IgfHwgW10sIHRydWUpKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGlzOiBmdW5jdGlvbihzZWxlY3Rvcikge1xyXG4gICAgICAgICAgICByZXR1cm4gISF3aW5ub3coXHJcbiAgICAgICAgICAgICAgICB0aGlzLFxyXG5cclxuICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgYSBwb3NpdGlvbmFsL3JlbGF0aXZlIHNlbGVjdG9yLCBjaGVjayBtZW1iZXJzaGlwIGluIHRoZSByZXR1cm5lZCBzZXRcclxuICAgICAgICAgICAgICAgIC8vIHNvICQoXCJwOmZpcnN0XCIpLmlzKFwicDpsYXN0XCIpIHdvbid0IHJldHVybiB0cnVlIGZvciBhIGRvYyB3aXRoIHR3byBcInBcIi5cclxuICAgICAgICAgICAgICAgIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiAmJiBybmVlZHNDb250ZXh0LnRlc3Qoc2VsZWN0b3IpID9cclxuICAgICAgICAgICAgICAgIGpRdWVyeShzZWxlY3RvcikgOlxyXG4gICAgICAgICAgICAgICAgc2VsZWN0b3IgfHwgW10sXHJcbiAgICAgICAgICAgICAgICBmYWxzZVxyXG4gICAgICAgICAgICApLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcblxyXG4gICAgLy8gSW5pdGlhbGl6ZSBhIGpRdWVyeSBvYmplY3RcclxuXHJcblxyXG4gICAgLy8gQSBjZW50cmFsIHJlZmVyZW5jZSB0byB0aGUgcm9vdCBqUXVlcnkoZG9jdW1lbnQpXHJcbiAgICB2YXIgcm9vdGpRdWVyeSxcclxuXHJcbiAgICAgICAgLy8gQSBzaW1wbGUgd2F5IHRvIGNoZWNrIGZvciBIVE1MIHN0cmluZ3NcclxuICAgICAgICAvLyBQcmlvcml0aXplICNpZCBvdmVyIDx0YWc+IHRvIGF2b2lkIFhTUyB2aWEgbG9jYXRpb24uaGFzaCAoIzk1MjEpXHJcbiAgICAgICAgLy8gU3RyaWN0IEhUTUwgcmVjb2duaXRpb24gKCMxMTI5MDogbXVzdCBzdGFydCB3aXRoIDwpXHJcbiAgICAgICAgcnF1aWNrRXhwciA9IC9eKD86XFxzKig8W1xcd1xcV10rPilbXj5dKnwjKFtcXHctXSopKSQvLFxyXG5cclxuICAgICAgICBpbml0ID0galF1ZXJ5LmZuLmluaXQgPSBmdW5jdGlvbihzZWxlY3RvciwgY29udGV4dCkge1xyXG4gICAgICAgICAgICB2YXIgbWF0Y2gsIGVsZW07XHJcblxyXG4gICAgICAgICAgICAvLyBIQU5ETEU6ICQoXCJcIiksICQobnVsbCksICQodW5kZWZpbmVkKSwgJChmYWxzZSlcclxuICAgICAgICAgICAgaWYgKCFzZWxlY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEhhbmRsZSBIVE1MIHN0cmluZ3NcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdG9yWzBdID09PSBcIjxcIiAmJiBzZWxlY3RvcltzZWxlY3Rvci5sZW5ndGggLSAxXSA9PT0gXCI+XCIgJiYgc2VsZWN0b3IubGVuZ3RoID49IDMpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBBc3N1bWUgdGhhdCBzdHJpbmdzIHRoYXQgc3RhcnQgYW5kIGVuZCB3aXRoIDw+IGFyZSBIVE1MIGFuZCBza2lwIHRoZSByZWdleCBjaGVja1xyXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoID0gW251bGwsIHNlbGVjdG9yLCBudWxsXTtcclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoID0gcnF1aWNrRXhwci5leGVjKHNlbGVjdG9yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBNYXRjaCBodG1sIG9yIG1ha2Ugc3VyZSBubyBjb250ZXh0IGlzIHNwZWNpZmllZCBmb3IgI2lkXHJcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2ggJiYgKG1hdGNoWzFdIHx8ICFjb250ZXh0KSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBIQU5ETEU6ICQoaHRtbCkgLT4gJChhcnJheSlcclxuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hbMV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dCA9IGNvbnRleHQgaW5zdGFuY2VvZiBqUXVlcnkgPyBjb250ZXh0WzBdIDogY29udGV4dDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNjcmlwdHMgaXMgdHJ1ZSBmb3IgYmFjay1jb21wYXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW50ZW50aW9uYWxseSBsZXQgdGhlIGVycm9yIGJlIHRocm93biBpZiBwYXJzZUhUTUwgaXMgbm90IHByZXNlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5Lm1lcmdlKHRoaXMsIGpRdWVyeS5wYXJzZUhUTUwoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFsxXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQgJiYgY29udGV4dC5ub2RlVHlwZSA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogZG9jdW1lbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSEFORExFOiAkKGh0bWwsIHByb3BzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocnNpbmdsZVRhZy50ZXN0KG1hdGNoWzFdKSAmJiBqUXVlcnkuaXNQbGFpbk9iamVjdChjb250ZXh0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChtYXRjaCBpbiBjb250ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJvcGVydGllcyBvZiBjb250ZXh0IGFyZSBjYWxsZWQgYXMgbWV0aG9kcyBpZiBwb3NzaWJsZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqUXVlcnkuaXNGdW5jdGlvbih0aGlzW21hdGNoXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1ttYXRjaF0oY29udGV4dFttYXRjaF0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLi4uYW5kIG90aGVyd2lzZSBzZXQgYXMgYXR0cmlidXRlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cihtYXRjaCwgY29udGV4dFttYXRjaF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBIQU5ETEU6ICQoI2lkKVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChtYXRjaFsyXSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBwYXJlbnROb2RlIHRvIGNhdGNoIHdoZW4gQmxhY2tiZXJyeSA0LjYgcmV0dXJuc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBub2RlcyB0aGF0IGFyZSBubyBsb25nZXIgaW4gdGhlIGRvY3VtZW50ICM2OTYzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtICYmIGVsZW0ucGFyZW50Tm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW5qZWN0IHRoZSBlbGVtZW50IGRpcmVjdGx5IGludG8gdGhlIGpRdWVyeSBvYmplY3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbMF0gPSBlbGVtO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQgPSBkb2N1bWVudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEhBTkRMRTogJChleHByLCAkKC4uLikpXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFjb250ZXh0IHx8IGNvbnRleHQuanF1ZXJ5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChjb250ZXh0IHx8IHJvb3RqUXVlcnkpLmZpbmQoc2VsZWN0b3IpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBIQU5ETEU6ICQoZXhwciwgY29udGV4dClcclxuICAgICAgICAgICAgICAgICAgICAvLyAod2hpY2ggaXMganVzdCBlcXVpdmFsZW50IHRvOiAkKGNvbnRleHQpLmZpbmQoZXhwcilcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IoY29udGV4dCkuZmluZChzZWxlY3Rvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSEFORExFOiAkKERPTUVsZW1lbnQpXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2VsZWN0b3Iubm9kZVR5cGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dCA9IHRoaXNbMF0gPSBzZWxlY3RvcjtcclxuICAgICAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gMTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEhBTkRMRTogJChmdW5jdGlvbilcclxuICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0IGZvciBkb2N1bWVudCByZWFkeVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGpRdWVyeS5pc0Z1bmN0aW9uKHNlbGVjdG9yKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiByb290alF1ZXJ5LnJlYWR5ICE9PSBcInVuZGVmaW5lZFwiID9cclxuICAgICAgICAgICAgICAgICAgICByb290alF1ZXJ5LnJlYWR5KHNlbGVjdG9yKSA6XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRXhlY3V0ZSBpbW1lZGlhdGVseSBpZiByZWFkeSBpcyBub3QgcHJlc2VudFxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yKGpRdWVyeSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChzZWxlY3Rvci5zZWxlY3RvciAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3Iuc2VsZWN0b3I7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQgPSBzZWxlY3Rvci5jb250ZXh0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5Lm1ha2VBcnJheShzZWxlY3RvciwgdGhpcyk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAvLyBHaXZlIHRoZSBpbml0IGZ1bmN0aW9uIHRoZSBqUXVlcnkgcHJvdG90eXBlIGZvciBsYXRlciBpbnN0YW50aWF0aW9uXHJcbiAgICBpbml0LnByb3RvdHlwZSA9IGpRdWVyeS5mbjtcclxuXHJcbiAgICAvLyBJbml0aWFsaXplIGNlbnRyYWwgcmVmZXJlbmNlXHJcbiAgICByb290alF1ZXJ5ID0galF1ZXJ5KGRvY3VtZW50KTtcclxuXHJcblxyXG4gICAgdmFyIHJwYXJlbnRzcHJldiA9IC9eKD86cGFyZW50c3xwcmV2KD86VW50aWx8QWxsKSkvLFxyXG4gICAgICAgIC8vIG1ldGhvZHMgZ3VhcmFudGVlZCB0byBwcm9kdWNlIGEgdW5pcXVlIHNldCB3aGVuIHN0YXJ0aW5nIGZyb20gYSB1bmlxdWUgc2V0XHJcbiAgICAgICAgZ3VhcmFudGVlZFVuaXF1ZSA9IHtcclxuICAgICAgICAgICAgY2hpbGRyZW46IHRydWUsXHJcbiAgICAgICAgICAgIGNvbnRlbnRzOiB0cnVlLFxyXG4gICAgICAgICAgICBuZXh0OiB0cnVlLFxyXG4gICAgICAgICAgICBwcmV2OiB0cnVlXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICBqUXVlcnkuZXh0ZW5kKHtcclxuICAgICAgICBkaXI6IGZ1bmN0aW9uKGVsZW0sIGRpciwgdW50aWwpIHtcclxuICAgICAgICAgICAgdmFyIG1hdGNoZWQgPSBbXSxcclxuICAgICAgICAgICAgICAgIHRydW5jYXRlID0gdW50aWwgIT09IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgICAgIHdoaWxlICgoZWxlbSA9IGVsZW1bZGlyXSkgJiYgZWxlbS5ub2RlVHlwZSAhPT0gOSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVsZW0ubm9kZVR5cGUgPT09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHJ1bmNhdGUgJiYgalF1ZXJ5KGVsZW0pLmlzKHVudGlsKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZC5wdXNoKGVsZW0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBtYXRjaGVkO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNpYmxpbmc6IGZ1bmN0aW9uKG4sIGVsZW0pIHtcclxuICAgICAgICAgICAgdmFyIG1hdGNoZWQgPSBbXTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoOyBuOyBuID0gbi5uZXh0U2libGluZykge1xyXG4gICAgICAgICAgICAgICAgaWYgKG4ubm9kZVR5cGUgPT09IDEgJiYgbiAhPT0gZWxlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZWQucHVzaChuKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgalF1ZXJ5LmZuLmV4dGVuZCh7XHJcbiAgICAgICAgaGFzOiBmdW5jdGlvbih0YXJnZXQpIHtcclxuICAgICAgICAgICAgdmFyIHRhcmdldHMgPSBqUXVlcnkodGFyZ2V0LCB0aGlzKSxcclxuICAgICAgICAgICAgICAgIGwgPSB0YXJnZXRzLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlcihmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGpRdWVyeS5jb250YWlucyh0aGlzLCB0YXJnZXRzW2ldKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGNsb3Nlc3Q6IGZ1bmN0aW9uKHNlbGVjdG9ycywgY29udGV4dCkge1xyXG4gICAgICAgICAgICB2YXIgY3VyLFxyXG4gICAgICAgICAgICAgICAgaSA9IDAsXHJcbiAgICAgICAgICAgICAgICBsID0gdGhpcy5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICBtYXRjaGVkID0gW10sXHJcbiAgICAgICAgICAgICAgICBwb3MgPSBybmVlZHNDb250ZXh0LnRlc3Qoc2VsZWN0b3JzKSB8fCB0eXBlb2Ygc2VsZWN0b3JzICE9PSBcInN0cmluZ1wiID9cclxuICAgICAgICAgICAgICAgIGpRdWVyeShzZWxlY3RvcnMsIGNvbnRleHQgfHwgdGhpcy5jb250ZXh0KSA6XHJcbiAgICAgICAgICAgICAgICAwO1xyXG5cclxuICAgICAgICAgICAgZm9yICg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGZvciAoY3VyID0gdGhpc1tpXTsgY3VyICYmIGN1ciAhPT0gY29udGV4dDsgY3VyID0gY3VyLnBhcmVudE5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBBbHdheXMgc2tpcCBkb2N1bWVudCBmcmFnbWVudHNcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VyLm5vZGVUeXBlIDwgMTEgJiYgKHBvcyA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MuaW5kZXgoY3VyKSA+IC0xIDpcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBwYXNzIG5vbi1lbGVtZW50cyB0byBTaXp6bGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1ci5ub2RlVHlwZSA9PT0gMSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKGN1ciwgc2VsZWN0b3JzKSkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWQucHVzaChjdXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayhtYXRjaGVkLmxlbmd0aCA+IDEgPyBqUXVlcnkudW5pcXVlKG1hdGNoZWQpIDogbWF0Y2hlZCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBwb3NpdGlvbiBvZiBhbiBlbGVtZW50IHdpdGhpblxyXG4gICAgICAgIC8vIHRoZSBtYXRjaGVkIHNldCBvZiBlbGVtZW50c1xyXG4gICAgICAgIGluZGV4OiBmdW5jdGlvbihlbGVtKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBObyBhcmd1bWVudCwgcmV0dXJuIGluZGV4IGluIHBhcmVudFxyXG4gICAgICAgICAgICBpZiAoIWVsZW0pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAodGhpc1swXSAmJiB0aGlzWzBdLnBhcmVudE5vZGUpID8gdGhpcy5maXJzdCgpLnByZXZBbGwoKS5sZW5ndGggOiAtMTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gaW5kZXggaW4gc2VsZWN0b3JcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBlbGVtID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXhPZi5jYWxsKGpRdWVyeShlbGVtKSwgdGhpc1swXSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIExvY2F0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIGRlc2lyZWQgZWxlbWVudFxyXG4gICAgICAgICAgICByZXR1cm4gaW5kZXhPZi5jYWxsKHRoaXMsXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSWYgaXQgcmVjZWl2ZXMgYSBqUXVlcnkgb2JqZWN0LCB0aGUgZmlyc3QgZWxlbWVudCBpcyB1c2VkXHJcbiAgICAgICAgICAgICAgICBlbGVtLmpxdWVyeSA/IGVsZW1bMF0gOiBlbGVtXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgYWRkOiBmdW5jdGlvbihzZWxlY3RvciwgY29udGV4dCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2soXHJcbiAgICAgICAgICAgICAgICBqUXVlcnkudW5pcXVlKFxyXG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5tZXJnZSh0aGlzLmdldCgpLCBqUXVlcnkoc2VsZWN0b3IsIGNvbnRleHQpKVxyXG4gICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGFkZEJhY2s6IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChzZWxlY3RvciA9PSBudWxsID9cclxuICAgICAgICAgICAgICAgIHRoaXMucHJldk9iamVjdCA6IHRoaXMucHJldk9iamVjdC5maWx0ZXIoc2VsZWN0b3IpXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgZnVuY3Rpb24gc2libGluZyhjdXIsIGRpcikge1xyXG4gICAgICAgIHdoaWxlICgoY3VyID0gY3VyW2Rpcl0pICYmIGN1ci5ub2RlVHlwZSAhPT0gMSkge31cclxuICAgICAgICByZXR1cm4gY3VyO1xyXG4gICAgfVxyXG5cclxuICAgIGpRdWVyeS5lYWNoKHtcclxuICAgICAgICBwYXJlbnQ6IGZ1bmN0aW9uKGVsZW0pIHtcclxuICAgICAgICAgICAgdmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcclxuICAgICAgICAgICAgcmV0dXJuIHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgIT09IDExID8gcGFyZW50IDogbnVsbDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHBhcmVudHM6IGZ1bmN0aW9uKGVsZW0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5kaXIoZWxlbSwgXCJwYXJlbnROb2RlXCIpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcGFyZW50c1VudGlsOiBmdW5jdGlvbihlbGVtLCBpLCB1bnRpbCkge1xyXG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5LmRpcihlbGVtLCBcInBhcmVudE5vZGVcIiwgdW50aWwpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24oZWxlbSkge1xyXG4gICAgICAgICAgICByZXR1cm4gc2libGluZyhlbGVtLCBcIm5leHRTaWJsaW5nXCIpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcHJldjogZnVuY3Rpb24oZWxlbSkge1xyXG4gICAgICAgICAgICByZXR1cm4gc2libGluZyhlbGVtLCBcInByZXZpb3VzU2libGluZ1wiKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG5leHRBbGw6IGZ1bmN0aW9uKGVsZW0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5kaXIoZWxlbSwgXCJuZXh0U2libGluZ1wiKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHByZXZBbGw6IGZ1bmN0aW9uKGVsZW0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5kaXIoZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBuZXh0VW50aWw6IGZ1bmN0aW9uKGVsZW0sIGksIHVudGlsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkuZGlyKGVsZW0sIFwibmV4dFNpYmxpbmdcIiwgdW50aWwpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcHJldlVudGlsOiBmdW5jdGlvbihlbGVtLCBpLCB1bnRpbCkge1xyXG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5LmRpcihlbGVtLCBcInByZXZpb3VzU2libGluZ1wiLCB1bnRpbCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzaWJsaW5nczogZnVuY3Rpb24oZWxlbSkge1xyXG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5LnNpYmxpbmcoKGVsZW0ucGFyZW50Tm9kZSB8fCB7fSkuZmlyc3RDaGlsZCwgZWxlbSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjaGlsZHJlbjogZnVuY3Rpb24oZWxlbSkge1xyXG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5LnNpYmxpbmcoZWxlbS5maXJzdENoaWxkKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNvbnRlbnRzOiBmdW5jdGlvbihlbGVtKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBlbGVtLmNvbnRlbnREb2N1bWVudCB8fCBqUXVlcnkubWVyZ2UoW10sIGVsZW0uY2hpbGROb2Rlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgZnVuY3Rpb24obmFtZSwgZm4pIHtcclxuICAgICAgICBqUXVlcnkuZm5bbmFtZV0gPSBmdW5jdGlvbih1bnRpbCwgc2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgdmFyIG1hdGNoZWQgPSBqUXVlcnkubWFwKHRoaXMsIGZuLCB1bnRpbCk7XHJcblxyXG4gICAgICAgICAgICBpZiAobmFtZS5zbGljZSgtNSkgIT09IFwiVW50aWxcIikge1xyXG4gICAgICAgICAgICAgICAgc2VsZWN0b3IgPSB1bnRpbDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHNlbGVjdG9yICYmIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgbWF0Y2hlZCA9IGpRdWVyeS5maWx0ZXIoc2VsZWN0b3IsIG1hdGNoZWQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgZHVwbGljYXRlc1xyXG4gICAgICAgICAgICAgICAgaWYgKCFndWFyYW50ZWVkVW5pcXVlW25hbWVdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LnVuaXF1ZShtYXRjaGVkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSZXZlcnNlIG9yZGVyIGZvciBwYXJlbnRzKiBhbmQgcHJldi1kZXJpdmF0aXZlc1xyXG4gICAgICAgICAgICAgICAgaWYgKHJwYXJlbnRzcHJldi50ZXN0KG5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZC5yZXZlcnNlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayhtYXRjaGVkKTtcclxuICAgICAgICB9O1xyXG4gICAgfSk7XHJcbiAgICB2YXIgcm5vdHdoaXRlID0gKC9cXFMrL2cpO1xyXG5cclxuXHJcblxyXG4gICAgLy8gU3RyaW5nIHRvIE9iamVjdCBvcHRpb25zIGZvcm1hdCBjYWNoZVxyXG4gICAgdmFyIG9wdGlvbnNDYWNoZSA9IHt9O1xyXG5cclxuICAgIC8vIENvbnZlcnQgU3RyaW5nLWZvcm1hdHRlZCBvcHRpb25zIGludG8gT2JqZWN0LWZvcm1hdHRlZCBvbmVzIGFuZCBzdG9yZSBpbiBjYWNoZVxyXG4gICAgZnVuY3Rpb24gY3JlYXRlT3B0aW9ucyhvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIG9iamVjdCA9IG9wdGlvbnNDYWNoZVtvcHRpb25zXSA9IHt9O1xyXG4gICAgICAgIGpRdWVyeS5lYWNoKG9wdGlvbnMubWF0Y2gocm5vdHdoaXRlKSB8fCBbXSwgZnVuY3Rpb24oXywgZmxhZykge1xyXG4gICAgICAgICAgICBvYmplY3RbZmxhZ10gPSB0cnVlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBvYmplY3Q7XHJcbiAgICB9XHJcblxyXG4gICAgLypcclxuICAgICAqIENyZWF0ZSBhIGNhbGxiYWNrIGxpc3QgdXNpbmcgdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzOlxyXG4gICAgICpcclxuICAgICAqXHRvcHRpb25zOiBhbiBvcHRpb25hbCBsaXN0IG9mIHNwYWNlLXNlcGFyYXRlZCBvcHRpb25zIHRoYXQgd2lsbCBjaGFuZ2UgaG93XHJcbiAgICAgKlx0XHRcdHRoZSBjYWxsYmFjayBsaXN0IGJlaGF2ZXMgb3IgYSBtb3JlIHRyYWRpdGlvbmFsIG9wdGlvbiBvYmplY3RcclxuICAgICAqXHJcbiAgICAgKiBCeSBkZWZhdWx0IGEgY2FsbGJhY2sgbGlzdCB3aWxsIGFjdCBsaWtlIGFuIGV2ZW50IGNhbGxiYWNrIGxpc3QgYW5kIGNhbiBiZVxyXG4gICAgICogXCJmaXJlZFwiIG11bHRpcGxlIHRpbWVzLlxyXG4gICAgICpcclxuICAgICAqIFBvc3NpYmxlIG9wdGlvbnM6XHJcbiAgICAgKlxyXG4gICAgICpcdG9uY2U6XHRcdFx0d2lsbCBlbnN1cmUgdGhlIGNhbGxiYWNrIGxpc3QgY2FuIG9ubHkgYmUgZmlyZWQgb25jZSAobGlrZSBhIERlZmVycmVkKVxyXG4gICAgICpcclxuICAgICAqXHRtZW1vcnk6XHRcdFx0d2lsbCBrZWVwIHRyYWNrIG9mIHByZXZpb3VzIHZhbHVlcyBhbmQgd2lsbCBjYWxsIGFueSBjYWxsYmFjayBhZGRlZFxyXG4gICAgICpcdFx0XHRcdFx0YWZ0ZXIgdGhlIGxpc3QgaGFzIGJlZW4gZmlyZWQgcmlnaHQgYXdheSB3aXRoIHRoZSBsYXRlc3QgXCJtZW1vcml6ZWRcIlxyXG4gICAgICpcdFx0XHRcdFx0dmFsdWVzIChsaWtlIGEgRGVmZXJyZWQpXHJcbiAgICAgKlxyXG4gICAgICpcdHVuaXF1ZTpcdFx0XHR3aWxsIGVuc3VyZSBhIGNhbGxiYWNrIGNhbiBvbmx5IGJlIGFkZGVkIG9uY2UgKG5vIGR1cGxpY2F0ZSBpbiB0aGUgbGlzdClcclxuICAgICAqXHJcbiAgICAgKlx0c3RvcE9uRmFsc2U6XHRpbnRlcnJ1cHQgY2FsbGluZ3Mgd2hlbiBhIGNhbGxiYWNrIHJldHVybnMgZmFsc2VcclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIGpRdWVyeS5DYWxsYmFja3MgPSBmdW5jdGlvbihvcHRpb25zKSB7XHJcblxyXG4gICAgICAgIC8vIENvbnZlcnQgb3B0aW9ucyBmcm9tIFN0cmluZy1mb3JtYXR0ZWQgdG8gT2JqZWN0LWZvcm1hdHRlZCBpZiBuZWVkZWRcclxuICAgICAgICAvLyAod2UgY2hlY2sgaW4gY2FjaGUgZmlyc3QpXHJcbiAgICAgICAgb3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiID9cclxuICAgICAgICAgICAgKG9wdGlvbnNDYWNoZVtvcHRpb25zXSB8fCBjcmVhdGVPcHRpb25zKG9wdGlvbnMpKSA6XHJcbiAgICAgICAgICAgIGpRdWVyeS5leHRlbmQoe30sIG9wdGlvbnMpO1xyXG5cclxuICAgICAgICB2YXIgLy8gTGFzdCBmaXJlIHZhbHVlIChmb3Igbm9uLWZvcmdldHRhYmxlIGxpc3RzKVxyXG4gICAgICAgICAgICBtZW1vcnksXHJcbiAgICAgICAgICAgIC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IHdhcyBhbHJlYWR5IGZpcmVkXHJcbiAgICAgICAgICAgIGZpcmVkLFxyXG4gICAgICAgICAgICAvLyBGbGFnIHRvIGtub3cgaWYgbGlzdCBpcyBjdXJyZW50bHkgZmlyaW5nXHJcbiAgICAgICAgICAgIGZpcmluZyxcclxuICAgICAgICAgICAgLy8gRmlyc3QgY2FsbGJhY2sgdG8gZmlyZSAodXNlZCBpbnRlcm5hbGx5IGJ5IGFkZCBhbmQgZmlyZVdpdGgpXHJcbiAgICAgICAgICAgIGZpcmluZ1N0YXJ0LFxyXG4gICAgICAgICAgICAvLyBFbmQgb2YgdGhlIGxvb3Agd2hlbiBmaXJpbmdcclxuICAgICAgICAgICAgZmlyaW5nTGVuZ3RoLFxyXG4gICAgICAgICAgICAvLyBJbmRleCBvZiBjdXJyZW50bHkgZmlyaW5nIGNhbGxiYWNrIChtb2RpZmllZCBieSByZW1vdmUgaWYgbmVlZGVkKVxyXG4gICAgICAgICAgICBmaXJpbmdJbmRleCxcclxuICAgICAgICAgICAgLy8gQWN0dWFsIGNhbGxiYWNrIGxpc3RcclxuICAgICAgICAgICAgbGlzdCA9IFtdLFxyXG4gICAgICAgICAgICAvLyBTdGFjayBvZiBmaXJlIGNhbGxzIGZvciByZXBlYXRhYmxlIGxpc3RzXHJcbiAgICAgICAgICAgIHN0YWNrID0gIW9wdGlvbnMub25jZSAmJiBbXSxcclxuICAgICAgICAgICAgLy8gRmlyZSBjYWxsYmFja3NcclxuICAgICAgICAgICAgZmlyZSA9IGZ1bmN0aW9uKGRhdGEpIHtcclxuICAgICAgICAgICAgICAgIG1lbW9yeSA9IG9wdGlvbnMubWVtb3J5ICYmIGRhdGE7XHJcbiAgICAgICAgICAgICAgICBmaXJlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBmaXJpbmdJbmRleCA9IGZpcmluZ1N0YXJ0IHx8IDA7XHJcbiAgICAgICAgICAgICAgICBmaXJpbmdTdGFydCA9IDA7XHJcbiAgICAgICAgICAgICAgICBmaXJpbmdMZW5ndGggPSBsaXN0Lmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGZpcmluZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBmb3IgKDsgbGlzdCAmJiBmaXJpbmdJbmRleCA8IGZpcmluZ0xlbmd0aDsgZmlyaW5nSW5kZXgrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsaXN0W2ZpcmluZ0luZGV4XS5hcHBseShkYXRhWzBdLCBkYXRhWzFdKSA9PT0gZmFsc2UgJiYgb3B0aW9ucy5zdG9wT25GYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZW1vcnkgPSBmYWxzZTsgLy8gVG8gcHJldmVudCBmdXJ0aGVyIGNhbGxzIHVzaW5nIGFkZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmaXJpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGlmIChsaXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcmUoc3RhY2suc2hpZnQoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1lbW9yeSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5kaXNhYmxlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvLyBBY3R1YWwgQ2FsbGJhY2tzIG9iamVjdFxyXG4gICAgICAgICAgICBzZWxmID0ge1xyXG4gICAgICAgICAgICAgICAgLy8gQWRkIGEgY2FsbGJhY2sgb3IgYSBjb2xsZWN0aW9uIG9mIGNhbGxiYWNrcyB0byB0aGUgbGlzdFxyXG4gICAgICAgICAgICAgICAgYWRkOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobGlzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGaXJzdCwgd2Ugc2F2ZSB0aGUgY3VycmVudCBsZW5ndGhcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gbGlzdC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChmdW5jdGlvbiBhZGQoYXJncykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmVhY2goYXJncywgZnVuY3Rpb24oXywgYXJnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBqUXVlcnkudHlwZShhcmcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLnVuaXF1ZSB8fCAhc2VsZi5oYXMoYXJnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdC5wdXNoKGFyZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFyZyAmJiBhcmcubGVuZ3RoICYmIHR5cGUgIT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW5zcGVjdCByZWN1cnNpdmVseVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGQoYXJnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSkoYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG8gd2UgbmVlZCB0byBhZGQgdGhlIGNhbGxiYWNrcyB0byB0aGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY3VycmVudCBmaXJpbmcgYmF0Y2g/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaXJpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcmluZ0xlbmd0aCA9IGxpc3QubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2l0aCBtZW1vcnksIGlmIHdlJ3JlIG5vdCBmaXJpbmcgdGhlblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2Ugc2hvdWxkIGNhbGwgcmlnaHQgYXdheVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1lbW9yeSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyaW5nU3RhcnQgPSBzdGFydDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcmUobWVtb3J5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgYSBjYWxsYmFjayBmcm9tIHRoZSBsaXN0XHJcbiAgICAgICAgICAgICAgICByZW1vdmU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsaXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5lYWNoKGFyZ3VtZW50cywgZnVuY3Rpb24oXywgYXJnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKGluZGV4ID0galF1ZXJ5LmluQXJyYXkoYXJnLCBsaXN0LCBpbmRleCkpID4gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0LnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIGZpcmluZyBpbmRleGVzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpcmluZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPD0gZmlyaW5nTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJpbmdMZW5ndGgtLTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPD0gZmlyaW5nSW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcmluZ0luZGV4LS07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBhIGdpdmVuIGNhbGxiYWNrIGlzIGluIHRoZSBsaXN0LlxyXG4gICAgICAgICAgICAgICAgLy8gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIHJldHVybiB3aGV0aGVyIG9yIG5vdCBsaXN0IGhhcyBjYWxsYmFja3MgYXR0YWNoZWQuXHJcbiAgICAgICAgICAgICAgICBoYXM6IGZ1bmN0aW9uKGZuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZuID8galF1ZXJ5LmluQXJyYXkoZm4sIGxpc3QpID4gLTEgOiAhIShsaXN0ICYmIGxpc3QubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgYWxsIGNhbGxiYWNrcyBmcm9tIHRoZSBsaXN0XHJcbiAgICAgICAgICAgICAgICBlbXB0eTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGlzdCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGZpcmluZ0xlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgLy8gSGF2ZSB0aGUgbGlzdCBkbyBub3RoaW5nIGFueW1vcmVcclxuICAgICAgICAgICAgICAgIGRpc2FibGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxpc3QgPSBzdGFjayA9IG1lbW9yeSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAvLyBJcyBpdCBkaXNhYmxlZD9cclxuICAgICAgICAgICAgICAgIGRpc2FibGVkOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWxpc3Q7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgLy8gTG9jayB0aGUgbGlzdCBpbiBpdHMgY3VycmVudCBzdGF0ZVxyXG4gICAgICAgICAgICAgICAgbG9jazogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtZW1vcnkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5kaXNhYmxlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIC8vIElzIGl0IGxvY2tlZD9cclxuICAgICAgICAgICAgICAgIGxvY2tlZDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFzdGFjaztcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAvLyBDYWxsIGFsbCBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gY29udGV4dCBhbmQgYXJndW1lbnRzXHJcbiAgICAgICAgICAgICAgICBmaXJlV2l0aDogZnVuY3Rpb24oY29udGV4dCwgYXJncykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsaXN0ICYmICghZmlyZWQgfHwgc3RhY2spKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmdzIHx8IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gW2NvbnRleHQsIGFyZ3Muc2xpY2UgPyBhcmdzLnNsaWNlKCkgOiBhcmdzXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpcmluZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaChhcmdzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcmUoYXJncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgLy8gQ2FsbCBhbGwgdGhlIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBhcmd1bWVudHNcclxuICAgICAgICAgICAgICAgIGZpcmU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZmlyZVdpdGgodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAvLyBUbyBrbm93IGlmIHRoZSBjYWxsYmFja3MgaGF2ZSBhbHJlYWR5IGJlZW4gY2FsbGVkIGF0IGxlYXN0IG9uY2VcclxuICAgICAgICAgICAgICAgIGZpcmVkOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gISFmaXJlZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHNlbGY7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICBqUXVlcnkuZXh0ZW5kKHtcclxuXHJcbiAgICAgICAgRGVmZXJyZWQ6IGZ1bmN0aW9uKGZ1bmMpIHtcclxuICAgICAgICAgICAgdmFyIHR1cGxlcyA9IFtcclxuICAgICAgICAgICAgICAgICAgICAvLyBhY3Rpb24sIGFkZCBsaXN0ZW5lciwgbGlzdGVuZXIgbGlzdCwgZmluYWwgc3RhdGVcclxuICAgICAgICAgICAgICAgICAgICBbXCJyZXNvbHZlXCIsIFwiZG9uZVwiLCBqUXVlcnkuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIiksIFwicmVzb2x2ZWRcIl0sXHJcbiAgICAgICAgICAgICAgICAgICAgW1wicmVqZWN0XCIsIFwiZmFpbFwiLCBqUXVlcnkuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIiksIFwicmVqZWN0ZWRcIl0sXHJcbiAgICAgICAgICAgICAgICAgICAgW1wibm90aWZ5XCIsIFwicHJvZ3Jlc3NcIiwgalF1ZXJ5LkNhbGxiYWNrcyhcIm1lbW9yeVwiKV1cclxuICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IFwicGVuZGluZ1wiLFxyXG4gICAgICAgICAgICAgICAgcHJvbWlzZSA9IHtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGFsd2F5czogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLmRvbmUoYXJndW1lbnRzKS5mYWlsKGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgdGhlbjogZnVuY3Rpb24oIC8qIGZuRG9uZSwgZm5GYWlsLCBmblByb2dyZXNzICovICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZm5zID0gYXJndW1lbnRzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4galF1ZXJ5LkRlZmVycmVkKGZ1bmN0aW9uKG5ld0RlZmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZWFjaCh0dXBsZXMsIGZ1bmN0aW9uKGksIHR1cGxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZuID0galF1ZXJ5LmlzRnVuY3Rpb24oZm5zW2ldKSAmJiBmbnNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGVmZXJyZWRbIGRvbmUgfCBmYWlsIHwgcHJvZ3Jlc3MgXSBmb3IgZm9yd2FyZGluZyBhY3Rpb25zIHRvIG5ld0RlZmVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWRbdHVwbGVbMV1dKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmV0dXJuZWQgPSBmbiAmJiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmV0dXJuZWQgJiYgalF1ZXJ5LmlzRnVuY3Rpb24ocmV0dXJuZWQucHJvbWlzZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybmVkLnByb21pc2UoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5kb25lKG5ld0RlZmVyLnJlc29sdmUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZhaWwobmV3RGVmZXIucmVqZWN0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5wcm9ncmVzcyhuZXdEZWZlci5ub3RpZnkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3RGVmZXJbdHVwbGVbMF0gKyBcIldpdGhcIl0odGhpcyA9PT0gcHJvbWlzZSA/IG5ld0RlZmVyLnByb21pc2UoKSA6IHRoaXMsIGZuID8gW3JldHVybmVkXSA6IGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm5zID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSkucHJvbWlzZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IGEgcHJvbWlzZSBmb3IgdGhpcyBkZWZlcnJlZFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIG9iaiBpcyBwcm92aWRlZCwgdGhlIHByb21pc2UgYXNwZWN0IGlzIGFkZGVkIHRvIHRoZSBvYmplY3RcclxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlOiBmdW5jdGlvbihvYmopIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iaiAhPSBudWxsID8galF1ZXJ5LmV4dGVuZChvYmosIHByb21pc2UpIDogcHJvbWlzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZGVmZXJyZWQgPSB7fTtcclxuXHJcbiAgICAgICAgICAgIC8vIEtlZXAgcGlwZSBmb3IgYmFjay1jb21wYXRcclxuICAgICAgICAgICAgcHJvbWlzZS5waXBlID0gcHJvbWlzZS50aGVuO1xyXG5cclxuICAgICAgICAgICAgLy8gQWRkIGxpc3Qtc3BlY2lmaWMgbWV0aG9kc1xyXG4gICAgICAgICAgICBqUXVlcnkuZWFjaCh0dXBsZXMsIGZ1bmN0aW9uKGksIHR1cGxlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGlzdCA9IHR1cGxlWzJdLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlU3RyaW5nID0gdHVwbGVbM107XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gcHJvbWlzZVsgZG9uZSB8IGZhaWwgfCBwcm9ncmVzcyBdID0gbGlzdC5hZGRcclxuICAgICAgICAgICAgICAgIHByb21pc2VbdHVwbGVbMV1dID0gbGlzdC5hZGQ7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIHN0YXRlXHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGVTdHJpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICBsaXN0LmFkZChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RhdGUgPSBbIHJlc29sdmVkIHwgcmVqZWN0ZWQgXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IHN0YXRlU3RyaW5nO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gWyByZWplY3RfbGlzdCB8IHJlc29sdmVfbGlzdCBdLmRpc2FibGU7IHByb2dyZXNzX2xpc3QubG9ja1xyXG4gICAgICAgICAgICAgICAgICAgIH0sIHR1cGxlc1tpIF4gMV1bMl0uZGlzYWJsZSwgdHVwbGVzWzJdWzJdLmxvY2spO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIGRlZmVycmVkWyByZXNvbHZlIHwgcmVqZWN0IHwgbm90aWZ5IF1cclxuICAgICAgICAgICAgICAgIGRlZmVycmVkW3R1cGxlWzBdXSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkW3R1cGxlWzBdICsgXCJXaXRoXCJdKHRoaXMgPT09IGRlZmVycmVkID8gcHJvbWlzZSA6IHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgZGVmZXJyZWRbdHVwbGVbMF0gKyBcIldpdGhcIl0gPSBsaXN0LmZpcmVXaXRoO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIC8vIE1ha2UgdGhlIGRlZmVycmVkIGEgcHJvbWlzZVxyXG4gICAgICAgICAgICBwcm9taXNlLnByb21pc2UoZGVmZXJyZWQpO1xyXG5cclxuICAgICAgICAgICAgLy8gQ2FsbCBnaXZlbiBmdW5jIGlmIGFueVxyXG4gICAgICAgICAgICBpZiAoZnVuYykge1xyXG4gICAgICAgICAgICAgICAgZnVuYy5jYWxsKGRlZmVycmVkLCBkZWZlcnJlZCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEFsbCBkb25lIVxyXG4gICAgICAgICAgICByZXR1cm4gZGVmZXJyZWQ7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy8gRGVmZXJyZWQgaGVscGVyXHJcbiAgICAgICAgd2hlbjogZnVuY3Rpb24oc3Vib3JkaW5hdGUgLyogLCAuLi4sIHN1Ym9yZGluYXRlTiAqLyApIHtcclxuICAgICAgICAgICAgdmFyIGkgPSAwLFxyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZVZhbHVlcyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzKSxcclxuICAgICAgICAgICAgICAgIGxlbmd0aCA9IHJlc29sdmVWYWx1ZXMubGVuZ3RoLFxyXG5cclxuICAgICAgICAgICAgICAgIC8vIHRoZSBjb3VudCBvZiB1bmNvbXBsZXRlZCBzdWJvcmRpbmF0ZXNcclxuICAgICAgICAgICAgICAgIHJlbWFpbmluZyA9IGxlbmd0aCAhPT0gMSB8fCAoc3Vib3JkaW5hdGUgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oc3Vib3JkaW5hdGUucHJvbWlzZSkpID8gbGVuZ3RoIDogMCxcclxuXHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgbWFzdGVyIERlZmVycmVkLiBJZiByZXNvbHZlVmFsdWVzIGNvbnNpc3Qgb2Ygb25seSBhIHNpbmdsZSBEZWZlcnJlZCwganVzdCB1c2UgdGhhdC5cclxuICAgICAgICAgICAgICAgIGRlZmVycmVkID0gcmVtYWluaW5nID09PSAxID8gc3Vib3JkaW5hdGUgOiBqUXVlcnkuRGVmZXJyZWQoKSxcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgZnVuY3Rpb24gZm9yIGJvdGggcmVzb2x2ZSBhbmQgcHJvZ3Jlc3MgdmFsdWVzXHJcbiAgICAgICAgICAgICAgICB1cGRhdGVGdW5jID0gZnVuY3Rpb24oaSwgY29udGV4dHMsIHZhbHVlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0c1tpXSA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlc1tpXSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gc2xpY2UuY2FsbChhcmd1bWVudHMpIDogdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZXMgPT09IHByb2dyZXNzVmFsdWVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5ub3RpZnlXaXRoKGNvbnRleHRzLCB2YWx1ZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCEoLS1yZW1haW5pbmcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlV2l0aChjb250ZXh0cywgdmFsdWVzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIHByb2dyZXNzVmFsdWVzLCBwcm9ncmVzc0NvbnRleHRzLCByZXNvbHZlQ29udGV4dHM7XHJcblxyXG4gICAgICAgICAgICAvLyBhZGQgbGlzdGVuZXJzIHRvIERlZmVycmVkIHN1Ym9yZGluYXRlczsgdHJlYXQgb3RoZXJzIGFzIHJlc29sdmVkXHJcbiAgICAgICAgICAgIGlmIChsZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICBwcm9ncmVzc1ZhbHVlcyA9IG5ldyBBcnJheShsZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3NDb250ZXh0cyA9IG5ldyBBcnJheShsZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZUNvbnRleHRzID0gbmV3IEFycmF5KGxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc29sdmVWYWx1ZXNbaV0gJiYgalF1ZXJ5LmlzRnVuY3Rpb24ocmVzb2x2ZVZhbHVlc1tpXS5wcm9taXNlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlVmFsdWVzW2ldLnByb21pc2UoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmRvbmUodXBkYXRlRnVuYyhpLCByZXNvbHZlQ29udGV4dHMsIHJlc29sdmVWYWx1ZXMpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZhaWwoZGVmZXJyZWQucmVqZWN0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnByb2dyZXNzKHVwZGF0ZUZ1bmMoaSwgcHJvZ3Jlc3NDb250ZXh0cywgcHJvZ3Jlc3NWYWx1ZXMpKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAtLXJlbWFpbmluZztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGlmIHdlJ3JlIG5vdCB3YWl0aW5nIG9uIGFueXRoaW5nLCByZXNvbHZlIHRoZSBtYXN0ZXJcclxuICAgICAgICAgICAgaWYgKCFyZW1haW5pbmcpIHtcclxuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmVXaXRoKHJlc29sdmVDb250ZXh0cywgcmVzb2x2ZVZhbHVlcyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG5cclxuICAgIC8vIFRoZSBkZWZlcnJlZCB1c2VkIG9uIERPTSByZWFkeVxyXG4gICAgdmFyIHJlYWR5TGlzdDtcclxuXHJcbiAgICBqUXVlcnkuZm4ucmVhZHkgPSBmdW5jdGlvbihmbikge1xyXG4gICAgICAgIC8vIEFkZCB0aGUgY2FsbGJhY2tcclxuICAgICAgICBqUXVlcnkucmVhZHkucHJvbWlzZSgpLmRvbmUoZm4pO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcblxyXG4gICAgalF1ZXJ5LmV4dGVuZCh7XHJcbiAgICAgICAgLy8gSXMgdGhlIERPTSByZWFkeSB0byBiZSB1c2VkPyBTZXQgdG8gdHJ1ZSBvbmNlIGl0IG9jY3Vycy5cclxuICAgICAgICBpc1JlYWR5OiBmYWxzZSxcclxuXHJcbiAgICAgICAgLy8gQSBjb3VudGVyIHRvIHRyYWNrIGhvdyBtYW55IGl0ZW1zIHRvIHdhaXQgZm9yIGJlZm9yZVxyXG4gICAgICAgIC8vIHRoZSByZWFkeSBldmVudCBmaXJlcy4gU2VlICM2NzgxXHJcbiAgICAgICAgcmVhZHlXYWl0OiAxLFxyXG5cclxuICAgICAgICAvLyBIb2xkIChvciByZWxlYXNlKSB0aGUgcmVhZHkgZXZlbnRcclxuICAgICAgICBob2xkUmVhZHk6IGZ1bmN0aW9uKGhvbGQpIHtcclxuICAgICAgICAgICAgaWYgKGhvbGQpIHtcclxuICAgICAgICAgICAgICAgIGpRdWVyeS5yZWFkeVdhaXQrKztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGpRdWVyeS5yZWFkeSh0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8vIEhhbmRsZSB3aGVuIHRoZSBET00gaXMgcmVhZHlcclxuICAgICAgICByZWFkeTogZnVuY3Rpb24od2FpdCkge1xyXG5cclxuICAgICAgICAgICAgLy8gQWJvcnQgaWYgdGhlcmUgYXJlIHBlbmRpbmcgaG9sZHMgb3Igd2UncmUgYWxyZWFkeSByZWFkeVxyXG4gICAgICAgICAgICBpZiAod2FpdCA9PT0gdHJ1ZSA/IC0talF1ZXJ5LnJlYWR5V2FpdCA6IGpRdWVyeS5pc1JlYWR5KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFJlbWVtYmVyIHRoYXQgdGhlIERPTSBpcyByZWFkeVxyXG4gICAgICAgICAgICBqUXVlcnkuaXNSZWFkeSA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAvLyBJZiBhIG5vcm1hbCBET00gUmVhZHkgZXZlbnQgZmlyZWQsIGRlY3JlbWVudCwgYW5kIHdhaXQgaWYgbmVlZCBiZVxyXG4gICAgICAgICAgICBpZiAod2FpdCAhPT0gdHJ1ZSAmJiAtLWpRdWVyeS5yZWFkeVdhaXQgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBmdW5jdGlvbnMgYm91bmQsIHRvIGV4ZWN1dGVcclxuICAgICAgICAgICAgcmVhZHlMaXN0LnJlc29sdmVXaXRoKGRvY3VtZW50LCBbalF1ZXJ5XSk7XHJcblxyXG4gICAgICAgICAgICAvLyBUcmlnZ2VyIGFueSBib3VuZCByZWFkeSBldmVudHNcclxuICAgICAgICAgICAgaWYgKGpRdWVyeS5mbi50cmlnZ2VySGFuZGxlcikge1xyXG4gICAgICAgICAgICAgICAgalF1ZXJ5KGRvY3VtZW50KS50cmlnZ2VySGFuZGxlcihcInJlYWR5XCIpO1xyXG4gICAgICAgICAgICAgICAgalF1ZXJ5KGRvY3VtZW50KS5vZmYoXCJyZWFkeVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHJlYWR5IGV2ZW50IGhhbmRsZXIgYW5kIHNlbGYgY2xlYW51cCBtZXRob2RcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gY29tcGxldGVkKCkge1xyXG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsIGNvbXBsZXRlZCwgZmFsc2UpO1xyXG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibG9hZFwiLCBjb21wbGV0ZWQsIGZhbHNlKTtcclxuICAgICAgICBqUXVlcnkucmVhZHkoKTtcclxuICAgIH1cclxuXHJcbiAgICBqUXVlcnkucmVhZHkucHJvbWlzZSA9IGZ1bmN0aW9uKG9iaikge1xyXG4gICAgICAgIGlmICghcmVhZHlMaXN0KSB7XHJcblxyXG4gICAgICAgICAgICByZWFkeUxpc3QgPSBqUXVlcnkuRGVmZXJyZWQoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIENhdGNoIGNhc2VzIHdoZXJlICQoZG9jdW1lbnQpLnJlYWR5KCkgaXMgY2FsbGVkIGFmdGVyIHRoZSBicm93c2VyIGV2ZW50IGhhcyBhbHJlYWR5IG9jY3VycmVkLlxyXG4gICAgICAgICAgICAvLyB3ZSBvbmNlIHRyaWVkIHRvIHVzZSByZWFkeVN0YXRlIFwiaW50ZXJhY3RpdmVcIiBoZXJlLCBidXQgaXQgY2F1c2VkIGlzc3VlcyBsaWtlIHRoZSBvbmVcclxuICAgICAgICAgICAgLy8gZGlzY292ZXJlZCBieSBDaHJpc1MgaGVyZTogaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTIyODIjY29tbWVudDoxNVxyXG4gICAgICAgICAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgaXQgYXN5bmNocm9ub3VzbHkgdG8gYWxsb3cgc2NyaXB0cyB0aGUgb3Bwb3J0dW5pdHkgdG8gZGVsYXkgcmVhZHlcclxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoalF1ZXJ5LnJlYWR5KTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVXNlIHRoZSBoYW5keSBldmVudCBjYWxsYmFja1xyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkLCBmYWxzZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQSBmYWxsYmFjayB0byB3aW5kb3cub25sb2FkLCB0aGF0IHdpbGwgYWx3YXlzIHdvcmtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBjb21wbGV0ZWQsIGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVhZHlMaXN0LnByb21pc2Uob2JqKTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gS2ljayBvZmYgdGhlIERPTSByZWFkeSBjaGVjayBldmVuIGlmIHRoZSB1c2VyIGRvZXMgbm90XHJcbiAgICBqUXVlcnkucmVhZHkucHJvbWlzZSgpO1xyXG5cclxuXHJcblxyXG5cclxuICAgIC8vIE11bHRpZnVuY3Rpb25hbCBtZXRob2QgdG8gZ2V0IGFuZCBzZXQgdmFsdWVzIG9mIGEgY29sbGVjdGlvblxyXG4gICAgLy8gVGhlIHZhbHVlL3MgY2FuIG9wdGlvbmFsbHkgYmUgZXhlY3V0ZWQgaWYgaXQncyBhIGZ1bmN0aW9uXHJcbiAgICB2YXIgYWNjZXNzID0galF1ZXJ5LmFjY2VzcyA9IGZ1bmN0aW9uKGVsZW1zLCBmbiwga2V5LCB2YWx1ZSwgY2hhaW5hYmxlLCBlbXB0eUdldCwgcmF3KSB7XHJcbiAgICAgICAgdmFyIGkgPSAwLFxyXG4gICAgICAgICAgICBsZW4gPSBlbGVtcy5sZW5ndGgsXHJcbiAgICAgICAgICAgIGJ1bGsgPSBrZXkgPT0gbnVsbDtcclxuXHJcbiAgICAgICAgLy8gU2V0cyBtYW55IHZhbHVlc1xyXG4gICAgICAgIGlmIChqUXVlcnkudHlwZShrZXkpID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgICAgIGNoYWluYWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgIGZvciAoaSBpbiBrZXkpIHtcclxuICAgICAgICAgICAgICAgIGpRdWVyeS5hY2Nlc3MoZWxlbXMsIGZuLCBpLCBrZXlbaV0sIHRydWUsIGVtcHR5R2V0LCByYXcpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBTZXRzIG9uZSB2YWx1ZVxyXG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBjaGFpbmFibGUgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFqUXVlcnkuaXNGdW5jdGlvbih2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHJhdyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChidWxrKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBCdWxrIG9wZXJhdGlvbnMgcnVuIGFnYWluc3QgdGhlIGVudGlyZSBzZXRcclxuICAgICAgICAgICAgICAgIGlmIChyYXcpIHtcclxuICAgICAgICAgICAgICAgICAgICBmbi5jYWxsKGVsZW1zLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm4gPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyAuLi5leGNlcHQgd2hlbiBleGVjdXRpbmcgZnVuY3Rpb24gdmFsdWVzXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGJ1bGsgPSBmbjtcclxuICAgICAgICAgICAgICAgICAgICBmbiA9IGZ1bmN0aW9uKGVsZW0sIGtleSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1bGsuY2FsbChqUXVlcnkoZWxlbSksIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoZm4pIHtcclxuICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBmbihlbGVtc1tpXSwga2V5LCByYXcgPyB2YWx1ZSA6IHZhbHVlLmNhbGwoZWxlbXNbaV0sIGksIGZuKGVsZW1zW2ldLCBrZXkpKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBjaGFpbmFibGUgP1xyXG4gICAgICAgICAgICBlbGVtcyA6XHJcblxyXG4gICAgICAgICAgICAvLyBHZXRzXHJcbiAgICAgICAgICAgIGJ1bGsgP1xyXG4gICAgICAgICAgICBmbi5jYWxsKGVsZW1zKSA6XHJcbiAgICAgICAgICAgIGxlbiA/IGZuKGVsZW1zWzBdLCBrZXkpIDogZW1wdHlHZXQ7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIERldGVybWluZXMgd2hldGhlciBhbiBvYmplY3QgY2FuIGhhdmUgZGF0YVxyXG4gICAgICovXHJcbiAgICBqUXVlcnkuYWNjZXB0RGF0YSA9IGZ1bmN0aW9uKG93bmVyKSB7XHJcbiAgICAgICAgLy8gQWNjZXB0cyBvbmx5OlxyXG4gICAgICAgIC8vICAtIE5vZGVcclxuICAgICAgICAvLyAgICAtIE5vZGUuRUxFTUVOVF9OT0RFXHJcbiAgICAgICAgLy8gICAgLSBOb2RlLkRPQ1VNRU5UX05PREVcclxuICAgICAgICAvLyAgLSBPYmplY3RcclxuICAgICAgICAvLyAgICAtIEFueVxyXG4gICAgICAgIC8qIGpzaGludCAtVzAxOCAqL1xyXG4gICAgICAgIHJldHVybiBvd25lci5ub2RlVHlwZSA9PT0gMSB8fCBvd25lci5ub2RlVHlwZSA9PT0gOSB8fCAhKCtvd25lci5ub2RlVHlwZSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICBmdW5jdGlvbiBEYXRhKCkge1xyXG4gICAgICAgIC8vIFN1cHBvcnQ6IEFuZHJvaWQgPCA0LFxyXG4gICAgICAgIC8vIE9sZCBXZWJLaXQgZG9lcyBub3QgaGF2ZSBPYmplY3QucHJldmVudEV4dGVuc2lvbnMvZnJlZXplIG1ldGhvZCxcclxuICAgICAgICAvLyByZXR1cm4gbmV3IGVtcHR5IG9iamVjdCBpbnN0ZWFkIHdpdGggbm8gW1tzZXRdXSBhY2Nlc3NvclxyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLmNhY2hlID0ge30sIDAsIHtcclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7fTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLmV4cGFuZG8gPSBqUXVlcnkuZXhwYW5kbyArIE1hdGgucmFuZG9tKCk7XHJcbiAgICB9XHJcblxyXG4gICAgRGF0YS51aWQgPSAxO1xyXG4gICAgRGF0YS5hY2NlcHRzID0galF1ZXJ5LmFjY2VwdERhdGE7XHJcblxyXG4gICAgRGF0YS5wcm90b3R5cGUgPSB7XHJcbiAgICAgICAga2V5OiBmdW5jdGlvbihvd25lcikge1xyXG4gICAgICAgICAgICAvLyBXZSBjYW4gYWNjZXB0IGRhdGEgZm9yIG5vbi1lbGVtZW50IG5vZGVzIGluIG1vZGVybiBicm93c2VycyxcclxuICAgICAgICAgICAgLy8gYnV0IHdlIHNob3VsZCBub3QsIHNlZSAjODMzNS5cclxuICAgICAgICAgICAgLy8gQWx3YXlzIHJldHVybiB0aGUga2V5IGZvciBhIGZyb3plbiBvYmplY3QuXHJcbiAgICAgICAgICAgIGlmICghRGF0YS5hY2NlcHRzKG93bmVyKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBkZXNjcmlwdG9yID0ge30sXHJcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgb3duZXIgb2JqZWN0IGFscmVhZHkgaGFzIGEgY2FjaGUga2V5XHJcbiAgICAgICAgICAgICAgICB1bmxvY2sgPSBvd25lclt0aGlzLmV4cGFuZG9dO1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgbm90LCBjcmVhdGUgb25lXHJcbiAgICAgICAgICAgIGlmICghdW5sb2NrKSB7XHJcbiAgICAgICAgICAgICAgICB1bmxvY2sgPSBEYXRhLnVpZCsrO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFNlY3VyZSBpdCBpbiBhIG5vbi1lbnVtZXJhYmxlLCBub24td3JpdGFibGUgcHJvcGVydHlcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRvclt0aGlzLmV4cGFuZG9dID0geyB2YWx1ZTogdW5sb2NrIH07XHJcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMob3duZXIsIGRlc2NyaXB0b3IpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBBbmRyb2lkIDwgNFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZhbGxiYWNrIHRvIGEgbGVzcyBzZWN1cmUgZGVmaW5pdGlvblxyXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0b3JbdGhpcy5leHBhbmRvXSA9IHVubG9jaztcclxuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZXh0ZW5kKG93bmVyLCBkZXNjcmlwdG9yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRW5zdXJlIHRoZSBjYWNoZSBvYmplY3RcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmNhY2hlW3VubG9ja10pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVbdW5sb2NrXSA9IHt9O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdW5sb2NrO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbihvd25lciwgZGF0YSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgdmFyIHByb3AsXHJcbiAgICAgICAgICAgICAgICAvLyBUaGVyZSBtYXkgYmUgYW4gdW5sb2NrIGFzc2lnbmVkIHRvIHRoaXMgbm9kZSxcclxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIG5vIGVudHJ5IGZvciB0aGlzIFwib3duZXJcIiwgY3JlYXRlIG9uZSBpbmxpbmVcclxuICAgICAgICAgICAgICAgIC8vIGFuZCBzZXQgdGhlIHVubG9jayBhcyB0aG91Z2ggYW4gb3duZXIgZW50cnkgaGFkIGFsd2F5cyBleGlzdGVkXHJcbiAgICAgICAgICAgICAgICB1bmxvY2sgPSB0aGlzLmtleShvd25lciksXHJcbiAgICAgICAgICAgICAgICBjYWNoZSA9IHRoaXMuY2FjaGVbdW5sb2NrXTtcclxuXHJcbiAgICAgICAgICAgIC8vIEhhbmRsZTogWyBvd25lciwga2V5LCB2YWx1ZSBdIGFyZ3NcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgICAgICBjYWNoZVtkYXRhXSA9IHZhbHVlO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEhhbmRsZTogWyBvd25lciwgeyBwcm9wZXJ0aWVzIH0gXSBhcmdzXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBGcmVzaCBhc3NpZ25tZW50cyBieSBvYmplY3QgYXJlIHNoYWxsb3cgY29waWVkXHJcbiAgICAgICAgICAgICAgICBpZiAoalF1ZXJ5LmlzRW1wdHlPYmplY3QoY2FjaGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmV4dGVuZCh0aGlzLmNhY2hlW3VubG9ja10sIGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgY29weSB0aGUgcHJvcGVydGllcyBvbmUtYnktb25lIHRvIHRoZSBjYWNoZSBvYmplY3RcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChwcm9wIGluIGRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVbcHJvcF0gPSBkYXRhW3Byb3BdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY2FjaGU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKG93bmVyLCBrZXkpIHtcclxuICAgICAgICAgICAgLy8gRWl0aGVyIGEgdmFsaWQgY2FjaGUgaXMgZm91bmQsIG9yIHdpbGwgYmUgY3JlYXRlZC5cclxuICAgICAgICAgICAgLy8gTmV3IGNhY2hlcyB3aWxsIGJlIGNyZWF0ZWQgYW5kIHRoZSB1bmxvY2sgcmV0dXJuZWQsXHJcbiAgICAgICAgICAgIC8vIGFsbG93aW5nIGRpcmVjdCBhY2Nlc3MgdG8gdGhlIG5ld2x5IGNyZWF0ZWRcclxuICAgICAgICAgICAgLy8gZW1wdHkgZGF0YSBvYmplY3QuIEEgdmFsaWQgb3duZXIgb2JqZWN0IG11c3QgYmUgcHJvdmlkZWQuXHJcbiAgICAgICAgICAgIHZhciBjYWNoZSA9IHRoaXMuY2FjaGVbdGhpcy5rZXkob3duZXIpXTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBrZXkgPT09IHVuZGVmaW5lZCA/XHJcbiAgICAgICAgICAgICAgICBjYWNoZSA6IGNhY2hlW2tleV07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBhY2Nlc3M6IGZ1bmN0aW9uKG93bmVyLCBrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhciBzdG9yZWQ7XHJcbiAgICAgICAgICAgIC8vIEluIGNhc2VzIHdoZXJlIGVpdGhlcjpcclxuICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgLy8gICAxLiBObyBrZXkgd2FzIHNwZWNpZmllZFxyXG4gICAgICAgICAgICAvLyAgIDIuIEEgc3RyaW5nIGtleSB3YXMgc3BlY2lmaWVkLCBidXQgbm8gdmFsdWUgcHJvdmlkZWRcclxuICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgLy8gVGFrZSB0aGUgXCJyZWFkXCIgcGF0aCBhbmQgYWxsb3cgdGhlIGdldCBtZXRob2QgdG8gZGV0ZXJtaW5lXHJcbiAgICAgICAgICAgIC8vIHdoaWNoIHZhbHVlIHRvIHJldHVybiwgcmVzcGVjdGl2ZWx5IGVpdGhlcjpcclxuICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgLy8gICAxLiBUaGUgZW50aXJlIGNhY2hlIG9iamVjdFxyXG4gICAgICAgICAgICAvLyAgIDIuIFRoZSBkYXRhIHN0b3JlZCBhdCB0aGUga2V5XHJcbiAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCB8fFxyXG4gICAgICAgICAgICAgICAgKChrZXkgJiYgdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIikgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICBzdG9yZWQgPSB0aGlzLmdldChvd25lciwga2V5KTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RvcmVkICE9PSB1bmRlZmluZWQgP1xyXG4gICAgICAgICAgICAgICAgICAgIHN0b3JlZCA6IHRoaXMuZ2V0KG93bmVyLCBqUXVlcnkuY2FtZWxDYXNlKGtleSkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBbKl1XaGVuIHRoZSBrZXkgaXMgbm90IGEgc3RyaW5nLCBvciBib3RoIGEga2V5IGFuZCB2YWx1ZVxyXG4gICAgICAgICAgICAvLyBhcmUgc3BlY2lmaWVkLCBzZXQgb3IgZXh0ZW5kIChleGlzdGluZyBvYmplY3RzKSB3aXRoIGVpdGhlcjpcclxuICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgLy8gICAxLiBBbiBvYmplY3Qgb2YgcHJvcGVydGllc1xyXG4gICAgICAgICAgICAvLyAgIDIuIEEga2V5IGFuZCB2YWx1ZVxyXG4gICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICB0aGlzLnNldChvd25lciwga2V5LCB2YWx1ZSk7XHJcblxyXG4gICAgICAgICAgICAvLyBTaW5jZSB0aGUgXCJzZXRcIiBwYXRoIGNhbiBoYXZlIHR3byBwb3NzaWJsZSBlbnRyeSBwb2ludHNcclxuICAgICAgICAgICAgLy8gcmV0dXJuIHRoZSBleHBlY3RlZCBkYXRhIGJhc2VkIG9uIHdoaWNoIHBhdGggd2FzIHRha2VuWypdXHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiBrZXk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uKG93bmVyLCBrZXkpIHtcclxuICAgICAgICAgICAgdmFyIGksIG5hbWUsIGNhbWVsLFxyXG4gICAgICAgICAgICAgICAgdW5sb2NrID0gdGhpcy5rZXkob3duZXIpLFxyXG4gICAgICAgICAgICAgICAgY2FjaGUgPSB0aGlzLmNhY2hlW3VubG9ja107XHJcblxyXG4gICAgICAgICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVbdW5sb2NrXSA9IHt9O1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQgYXJyYXkgb3Igc3BhY2Ugc2VwYXJhdGVkIHN0cmluZyBvZiBrZXlzXHJcbiAgICAgICAgICAgICAgICBpZiAoalF1ZXJ5LmlzQXJyYXkoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIFwibmFtZVwiIGlzIGFuIGFycmF5IG9mIGtleXMuLi5cclxuICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIGRhdGEgaXMgaW5pdGlhbGx5IGNyZWF0ZWQsIHZpYSAoXCJrZXlcIiwgXCJ2YWxcIikgc2lnbmF0dXJlLFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGtleXMgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gY2FtZWxDYXNlLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNpbmNlIHRoZXJlIGlzIG5vIHdheSB0byB0ZWxsIF9ob3dfIGEga2V5IHdhcyBhZGRlZCwgcmVtb3ZlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYm90aCBwbGFpbiBrZXkgYW5kIGNhbWVsQ2FzZSBrZXkuICMxMjc4NlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgd2lsbCBvbmx5IHBlbmFsaXplIHRoZSBhcnJheSBhcmd1bWVudCBwYXRoLlxyXG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBrZXkuY29uY2F0KGtleS5tYXAoalF1ZXJ5LmNhbWVsQ2FzZSkpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjYW1lbCA9IGpRdWVyeS5jYW1lbENhc2Uoa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUcnkgdGhlIHN0cmluZyBhcyBhIGtleSBiZWZvcmUgYW55IG1hbmlwdWxhdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgaW4gY2FjaGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IFtrZXksIGNhbWVsXTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBhIGtleSB3aXRoIHRoZSBzcGFjZXMgZXhpc3RzLCB1c2UgaXQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgY3JlYXRlIGFuIGFycmF5IGJ5IG1hdGNoaW5nIG5vbi13aGl0ZXNwYWNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSBjYW1lbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IG5hbWUgaW4gY2FjaGUgPyBbbmFtZV0gOiAobmFtZS5tYXRjaChybm90d2hpdGUpIHx8IFtdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaSA9IG5hbWUubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjYWNoZVtuYW1lW2ldXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaGFzRGF0YTogZnVuY3Rpb24ob3duZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuICFqUXVlcnkuaXNFbXB0eU9iamVjdChcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVbb3duZXJbdGhpcy5leHBhbmRvXV0gfHwge31cclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRpc2NhcmQ6IGZ1bmN0aW9uKG93bmVyKSB7XHJcbiAgICAgICAgICAgIGlmIChvd25lclt0aGlzLmV4cGFuZG9dKSB7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5jYWNoZVtvd25lclt0aGlzLmV4cGFuZG9dXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB2YXIgZGF0YV9wcml2ID0gbmV3IERhdGEoKTtcclxuXHJcbiAgICB2YXIgZGF0YV91c2VyID0gbmV3IERhdGEoKTtcclxuXHJcblxyXG5cclxuICAgIC8qXHJcbiAgICBcdEltcGxlbWVudGF0aW9uIFN1bW1hcnlcclxuXHJcbiAgICBcdDEuIEVuZm9yY2UgQVBJIHN1cmZhY2UgYW5kIHNlbWFudGljIGNvbXBhdGliaWxpdHkgd2l0aCAxLjkueCBicmFuY2hcclxuICAgIFx0Mi4gSW1wcm92ZSB0aGUgbW9kdWxlJ3MgbWFpbnRhaW5hYmlsaXR5IGJ5IHJlZHVjaW5nIHRoZSBzdG9yYWdlXHJcbiAgICBcdFx0cGF0aHMgdG8gYSBzaW5nbGUgbWVjaGFuaXNtLlxyXG4gICAgXHQzLiBVc2UgdGhlIHNhbWUgc2luZ2xlIG1lY2hhbmlzbSB0byBzdXBwb3J0IFwicHJpdmF0ZVwiIGFuZCBcInVzZXJcIiBkYXRhLlxyXG4gICAgXHQ0LiBfTmV2ZXJfIGV4cG9zZSBcInByaXZhdGVcIiBkYXRhIHRvIHVzZXIgY29kZSAoVE9ETzogRHJvcCBfZGF0YSwgX3JlbW92ZURhdGEpXHJcbiAgICBcdDUuIEF2b2lkIGV4cG9zaW5nIGltcGxlbWVudGF0aW9uIGRldGFpbHMgb24gdXNlciBvYmplY3RzIChlZy4gZXhwYW5kbyBwcm9wZXJ0aWVzKVxyXG4gICAgXHQ2LiBQcm92aWRlIGEgY2xlYXIgcGF0aCBmb3IgaW1wbGVtZW50YXRpb24gdXBncmFkZSB0byBXZWFrTWFwIGluIDIwMTRcclxuICAgICovXHJcbiAgICB2YXIgcmJyYWNlID0gL14oPzpcXHtbXFx3XFxXXSpcXH18XFxbW1xcd1xcV10qXFxdKSQvLFxyXG4gICAgICAgIHJtdWx0aURhc2ggPSAvKFtBLVpdKS9nO1xyXG5cclxuICAgIGZ1bmN0aW9uIGRhdGFBdHRyKGVsZW0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIHZhciBuYW1lO1xyXG5cclxuICAgICAgICAvLyBJZiBub3RoaW5nIHdhcyBmb3VuZCBpbnRlcm5hbGx5LCB0cnkgdG8gZmV0Y2ggYW55XHJcbiAgICAgICAgLy8gZGF0YSBmcm9tIHRoZSBIVE1MNSBkYXRhLSogYXR0cmlidXRlXHJcbiAgICAgICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxKSB7XHJcbiAgICAgICAgICAgIG5hbWUgPSBcImRhdGEtXCIgKyBrZXkucmVwbGFjZShybXVsdGlEYXNoLCBcIi0kMVwiKS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICBkYXRhID0gZWxlbS5nZXRBdHRyaWJ1dGUobmFtZSk7XHJcblxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGRhdGEgPT09IFwidHJ1ZVwiID8gdHJ1ZSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPT09IFwiZmFsc2VcIiA/IGZhbHNlIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9PT0gXCJudWxsXCIgPyBudWxsIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25seSBjb252ZXJ0IHRvIGEgbnVtYmVyIGlmIGl0IGRvZXNuJ3QgY2hhbmdlIHRoZSBzdHJpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgK2RhdGEgKyBcIlwiID09PSBkYXRhID8gK2RhdGEgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByYnJhY2UudGVzdChkYXRhKSA/IGpRdWVyeS5wYXJzZUpTT04oZGF0YSkgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhO1xyXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgd2Ugc2V0IHRoZSBkYXRhIHNvIGl0IGlzbid0IGNoYW5nZWQgbGF0ZXJcclxuICAgICAgICAgICAgICAgIGRhdGFfdXNlci5zZXQoZWxlbSwga2V5LCBkYXRhKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRhdGEgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICB9XHJcblxyXG4gICAgalF1ZXJ5LmV4dGVuZCh7XHJcbiAgICAgICAgaGFzRGF0YTogZnVuY3Rpb24oZWxlbSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZGF0YV91c2VyLmhhc0RhdGEoZWxlbSkgfHwgZGF0YV9wcml2Lmhhc0RhdGEoZWxlbSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZGF0YTogZnVuY3Rpb24oZWxlbSwgbmFtZSwgZGF0YSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZGF0YV91c2VyLmFjY2VzcyhlbGVtLCBuYW1lLCBkYXRhKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICByZW1vdmVEYXRhOiBmdW5jdGlvbihlbGVtLCBuYW1lKSB7XHJcbiAgICAgICAgICAgIGRhdGFfdXNlci5yZW1vdmUoZWxlbSwgbmFtZSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy8gVE9ETzogTm93IHRoYXQgYWxsIGNhbGxzIHRvIF9kYXRhIGFuZCBfcmVtb3ZlRGF0YSBoYXZlIGJlZW4gcmVwbGFjZWRcclxuICAgICAgICAvLyB3aXRoIGRpcmVjdCBjYWxscyB0byBkYXRhX3ByaXYgbWV0aG9kcywgdGhlc2UgY2FuIGJlIGRlcHJlY2F0ZWQuXHJcbiAgICAgICAgX2RhdGE6IGZ1bmN0aW9uKGVsZW0sIG5hbWUsIGRhdGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRhdGFfcHJpdi5hY2Nlc3MoZWxlbSwgbmFtZSwgZGF0YSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX3JlbW92ZURhdGE6IGZ1bmN0aW9uKGVsZW0sIG5hbWUpIHtcclxuICAgICAgICAgICAgZGF0YV9wcml2LnJlbW92ZShlbGVtLCBuYW1lKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBqUXVlcnkuZm4uZXh0ZW5kKHtcclxuICAgICAgICBkYXRhOiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhciBpLCBuYW1lLCBkYXRhLFxyXG4gICAgICAgICAgICAgICAgZWxlbSA9IHRoaXNbMF0sXHJcbiAgICAgICAgICAgICAgICBhdHRycyA9IGVsZW0gJiYgZWxlbS5hdHRyaWJ1dGVzO1xyXG5cclxuICAgICAgICAgICAgLy8gR2V0cyBhbGwgdmFsdWVzXHJcbiAgICAgICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGRhdGFfdXNlci5nZXQoZWxlbSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtLm5vZGVUeXBlID09PSAxICYmICFkYXRhX3ByaXYuZ2V0KGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBhdHRycy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBJRTExK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGF0dHJzIGVsZW1lbnRzIGNhbiBiZSBudWxsICgjMTQ4OTQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXR0cnNbaV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gYXR0cnNbaV0ubmFtZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmFtZS5pbmRleE9mKFwiZGF0YS1cIikgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IGpRdWVyeS5jYW1lbENhc2UobmFtZS5zbGljZSg1KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFBdHRyKGVsZW0sIG5hbWUsIGRhdGFbbmFtZV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhX3ByaXYuc2V0KGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gU2V0cyBtdWx0aXBsZSB2YWx1ZXNcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YV91c2VyLnNldCh0aGlzLCBrZXkpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBhY2Nlc3ModGhpcywgZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkYXRhLFxyXG4gICAgICAgICAgICAgICAgICAgIGNhbWVsS2V5ID0galF1ZXJ5LmNhbWVsQ2FzZShrZXkpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFRoZSBjYWxsaW5nIGpRdWVyeSBvYmplY3QgKGVsZW1lbnQgbWF0Y2hlcykgaXMgbm90IGVtcHR5XHJcbiAgICAgICAgICAgICAgICAvLyAoYW5kIHRoZXJlZm9yZSBoYXMgYW4gZWxlbWVudCBhcHBlYXJzIGF0IHRoaXNbIDAgXSkgYW5kIHRoZVxyXG4gICAgICAgICAgICAgICAgLy8gYHZhbHVlYCBwYXJhbWV0ZXIgd2FzIG5vdCB1bmRlZmluZWQuIEFuIGVtcHR5IGpRdWVyeSBvYmplY3RcclxuICAgICAgICAgICAgICAgIC8vIHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgIGZvciBlbGVtID0gdGhpc1sgMCBdIHdoaWNoIHdpbGxcclxuICAgICAgICAgICAgICAgIC8vIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhbiBhdHRlbXB0IHRvIHJlYWQgYSBkYXRhIGNhY2hlIGlzIG1hZGUuXHJcbiAgICAgICAgICAgICAgICBpZiAoZWxlbSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQXR0ZW1wdCB0byBnZXQgZGF0YSBmcm9tIHRoZSBjYWNoZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHdpdGggdGhlIGtleSBhcy1pc1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhX3VzZXIuZ2V0KGVsZW0sIGtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEF0dGVtcHQgdG8gZ2V0IGRhdGEgZnJvbSB0aGUgY2FjaGVcclxuICAgICAgICAgICAgICAgICAgICAvLyB3aXRoIHRoZSBrZXkgY2FtZWxpemVkXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGRhdGFfdXNlci5nZXQoZWxlbSwgY2FtZWxLZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBBdHRlbXB0IHRvIFwiZGlzY292ZXJcIiB0aGUgZGF0YSBpblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEhUTUw1IGN1c3RvbSBkYXRhLSogYXR0cnNcclxuICAgICAgICAgICAgICAgICAgICBkYXRhID0gZGF0YUF0dHIoZWxlbSwgY2FtZWxLZXksIHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIHRyaWVkIHJlYWxseSBoYXJkLCBidXQgdGhlIGRhdGEgZG9lc24ndCBleGlzdC5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU2V0IHRoZSBkYXRhLi4uXHJcbiAgICAgICAgICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRmlyc3QsIGF0dGVtcHQgdG8gc3RvcmUgYSBjb3B5IG9yIHJlZmVyZW5jZSBvZiBhbnlcclxuICAgICAgICAgICAgICAgICAgICAvLyBkYXRhIHRoYXQgbWlnaHQndmUgYmVlbiBzdG9yZSB3aXRoIGEgY2FtZWxDYXNlZCBrZXkuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBkYXRhX3VzZXIuZ2V0KHRoaXMsIGNhbWVsS2V5KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIEhUTUw1IGRhdGEtKiBhdHRyaWJ1dGUgaW50ZXJvcCwgd2UgaGF2ZSB0b1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHN0b3JlIHByb3BlcnR5IG5hbWVzIHdpdGggZGFzaGVzIGluIGEgY2FtZWxDYXNlIGZvcm0uXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBtaWdodCBub3QgYXBwbHkgdG8gYWxsIHByb3BlcnRpZXMuLi4qXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YV91c2VyLnNldCh0aGlzLCBjYW1lbEtleSwgdmFsdWUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyAqLi4uIEluIHRoZSBjYXNlIG9mIHByb3BlcnRpZXMgdGhhdCBtaWdodCBfYWN0dWFsbHlfXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaGF2ZSBkYXNoZXMsIHdlIG5lZWQgdG8gYWxzbyBzdG9yZSBhIGNvcHkgb2YgdGhhdFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHVuY2hhbmdlZCBwcm9wZXJ0eS5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5LmluZGV4T2YoXCItXCIpICE9PSAtMSAmJiBkYXRhICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YV91c2VyLnNldCh0aGlzLCBrZXksIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxLCBudWxsLCB0cnVlKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICByZW1vdmVEYXRhOiBmdW5jdGlvbihrZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIGRhdGFfdXNlci5yZW1vdmUodGhpcywga2V5KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG5cclxuICAgIGpRdWVyeS5leHRlbmQoe1xyXG4gICAgICAgIHF1ZXVlOiBmdW5jdGlvbihlbGVtLCB0eXBlLCBkYXRhKSB7XHJcbiAgICAgICAgICAgIHZhciBxdWV1ZTtcclxuXHJcbiAgICAgICAgICAgIGlmIChlbGVtKSB7XHJcbiAgICAgICAgICAgICAgICB0eXBlID0gKHR5cGUgfHwgXCJmeFwiKSArIFwicXVldWVcIjtcclxuICAgICAgICAgICAgICAgIHF1ZXVlID0gZGF0YV9wcml2LmdldChlbGVtLCB0eXBlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTcGVlZCB1cCBkZXF1ZXVlIGJ5IGdldHRpbmcgb3V0IHF1aWNrbHkgaWYgdGhpcyBpcyBqdXN0IGEgbG9va3VwXHJcbiAgICAgICAgICAgICAgICBpZiAoZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghcXVldWUgfHwgalF1ZXJ5LmlzQXJyYXkoZGF0YSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcXVldWUgPSBkYXRhX3ByaXYuYWNjZXNzKGVsZW0sIHR5cGUsIGpRdWVyeS5tYWtlQXJyYXkoZGF0YSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2goZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHF1ZXVlIHx8IFtdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZGVxdWV1ZTogZnVuY3Rpb24oZWxlbSwgdHlwZSkge1xyXG4gICAgICAgICAgICB0eXBlID0gdHlwZSB8fCBcImZ4XCI7XHJcblxyXG4gICAgICAgICAgICB2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoZWxlbSwgdHlwZSksXHJcbiAgICAgICAgICAgICAgICBzdGFydExlbmd0aCA9IHF1ZXVlLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgIGZuID0gcXVldWUuc2hpZnQoKSxcclxuICAgICAgICAgICAgICAgIGhvb2tzID0galF1ZXJ5Ll9xdWV1ZUhvb2tzKGVsZW0sIHR5cGUpLFxyXG4gICAgICAgICAgICAgICAgbmV4dCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5kZXF1ZXVlKGVsZW0sIHR5cGUpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIHRoZSBmeCBxdWV1ZSBpcyBkZXF1ZXVlZCwgYWx3YXlzIHJlbW92ZSB0aGUgcHJvZ3Jlc3Mgc2VudGluZWxcclxuICAgICAgICAgICAgaWYgKGZuID09PSBcImlucHJvZ3Jlc3NcIikge1xyXG4gICAgICAgICAgICAgICAgZm4gPSBxdWV1ZS5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgc3RhcnRMZW5ndGgtLTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGZuKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQWRkIGEgcHJvZ3Jlc3Mgc2VudGluZWwgdG8gcHJldmVudCB0aGUgZnggcXVldWUgZnJvbSBiZWluZ1xyXG4gICAgICAgICAgICAgICAgLy8gYXV0b21hdGljYWxseSBkZXF1ZXVlZFxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiZnhcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlLnVuc2hpZnQoXCJpbnByb2dyZXNzXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIGNsZWFyIHVwIHRoZSBsYXN0IHF1ZXVlIHN0b3AgZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBob29rcy5zdG9wO1xyXG4gICAgICAgICAgICAgICAgZm4uY2FsbChlbGVtLCBuZXh0LCBob29rcyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICghc3RhcnRMZW5ndGggJiYgaG9va3MpIHtcclxuICAgICAgICAgICAgICAgIGhvb2tzLmVtcHR5LmZpcmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8vIG5vdCBpbnRlbmRlZCBmb3IgcHVibGljIGNvbnN1bXB0aW9uIC0gZ2VuZXJhdGVzIGEgcXVldWVIb29rcyBvYmplY3QsIG9yIHJldHVybnMgdGhlIGN1cnJlbnQgb25lXHJcbiAgICAgICAgX3F1ZXVlSG9va3M6IGZ1bmN0aW9uKGVsZW0sIHR5cGUpIHtcclxuICAgICAgICAgICAgdmFyIGtleSA9IHR5cGUgKyBcInF1ZXVlSG9va3NcIjtcclxuICAgICAgICAgICAgcmV0dXJuIGRhdGFfcHJpdi5nZXQoZWxlbSwga2V5KSB8fCBkYXRhX3ByaXYuYWNjZXNzKGVsZW0sIGtleSwge1xyXG4gICAgICAgICAgICAgICAgZW1wdHk6IGpRdWVyeS5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKS5hZGQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YV9wcml2LnJlbW92ZShlbGVtLCBbdHlwZSArIFwicXVldWVcIiwga2V5XSk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBqUXVlcnkuZm4uZXh0ZW5kKHtcclxuICAgICAgICBxdWV1ZTogZnVuY3Rpb24odHlwZSwgZGF0YSkge1xyXG4gICAgICAgICAgICB2YXIgc2V0dGVyID0gMjtcclxuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgZGF0YSA9IHR5cGU7XHJcbiAgICAgICAgICAgICAgICB0eXBlID0gXCJmeFwiO1xyXG4gICAgICAgICAgICAgICAgc2V0dGVyLS07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgc2V0dGVyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4galF1ZXJ5LnF1ZXVlKHRoaXNbMF0sIHR5cGUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZGF0YSA9PT0gdW5kZWZpbmVkID9cclxuICAgICAgICAgICAgICAgIHRoaXMgOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSh0aGlzLCB0eXBlLCBkYXRhKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZW5zdXJlIGEgaG9va3MgZm9yIHRoaXMgcXVldWVcclxuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuX3F1ZXVlSG9va3ModGhpcywgdHlwZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBcImZ4XCIgJiYgcXVldWVbMF0gIT09IFwiaW5wcm9ncmVzc1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5kZXF1ZXVlKHRoaXMsIHR5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGVxdWV1ZTogZnVuY3Rpb24odHlwZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgalF1ZXJ5LmRlcXVldWUodGhpcywgdHlwZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY2xlYXJRdWV1ZTogZnVuY3Rpb24odHlwZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZSh0eXBlIHx8IFwiZnhcIiwgW10pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gR2V0IGEgcHJvbWlzZSByZXNvbHZlZCB3aGVuIHF1ZXVlcyBvZiBhIGNlcnRhaW4gdHlwZVxyXG4gICAgICAgIC8vIGFyZSBlbXB0aWVkIChmeCBpcyB0aGUgdHlwZSBieSBkZWZhdWx0KVxyXG4gICAgICAgIHByb21pc2U6IGZ1bmN0aW9uKHR5cGUsIG9iaikge1xyXG4gICAgICAgICAgICB2YXIgdG1wLFxyXG4gICAgICAgICAgICAgICAgY291bnQgPSAxLFxyXG4gICAgICAgICAgICAgICAgZGVmZXIgPSBqUXVlcnkuRGVmZXJyZWQoKSxcclxuICAgICAgICAgICAgICAgIGVsZW1lbnRzID0gdGhpcyxcclxuICAgICAgICAgICAgICAgIGkgPSB0aGlzLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgIHJlc29sdmUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISgtLWNvdW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlci5yZXNvbHZlV2l0aChlbGVtZW50cywgW2VsZW1lbnRzXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgb2JqID0gdHlwZTtcclxuICAgICAgICAgICAgICAgIHR5cGUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xyXG5cclxuICAgICAgICAgICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgICAgICAgICAgdG1wID0gZGF0YV9wcml2LmdldChlbGVtZW50c1tpXSwgdHlwZSArIFwicXVldWVIb29rc1wiKTtcclxuICAgICAgICAgICAgICAgIGlmICh0bXAgJiYgdG1wLmVtcHR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY291bnQrKztcclxuICAgICAgICAgICAgICAgICAgICB0bXAuZW1wdHkuYWRkKHJlc29sdmUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgcmV0dXJuIGRlZmVyLnByb21pc2Uob2JqKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHZhciBwbnVtID0gKC9bKy1dPyg/OlxcZCpcXC58KVxcZCsoPzpbZUVdWystXT9cXGQrfCkvKS5zb3VyY2U7XHJcblxyXG4gICAgdmFyIGNzc0V4cGFuZCA9IFtcIlRvcFwiLCBcIlJpZ2h0XCIsIFwiQm90dG9tXCIsIFwiTGVmdFwiXTtcclxuXHJcbiAgICB2YXIgaXNIaWRkZW4gPSBmdW5jdGlvbihlbGVtLCBlbCkge1xyXG4gICAgICAgIC8vIGlzSGlkZGVuIG1pZ2h0IGJlIGNhbGxlZCBmcm9tIGpRdWVyeSNmaWx0ZXIgZnVuY3Rpb247XHJcbiAgICAgICAgLy8gaW4gdGhhdCBjYXNlLCBlbGVtZW50IHdpbGwgYmUgc2Vjb25kIGFyZ3VtZW50XHJcbiAgICAgICAgZWxlbSA9IGVsIHx8IGVsZW07XHJcbiAgICAgICAgcmV0dXJuIGpRdWVyeS5jc3MoZWxlbSwgXCJkaXNwbGF5XCIpID09PSBcIm5vbmVcIiB8fCAhalF1ZXJ5LmNvbnRhaW5zKGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciByY2hlY2thYmxlVHlwZSA9ICgvXig/OmNoZWNrYm94fHJhZGlvKSQvaSk7XHJcblxyXG5cclxuXHJcbiAgICAoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxyXG4gICAgICAgICAgICBkaXYgPSBmcmFnbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKSxcclxuICAgICAgICAgICAgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XHJcblxyXG4gICAgICAgIC8vICMxMTIxNyAtIFdlYktpdCBsb3NlcyBjaGVjayB3aGVuIHRoZSBuYW1lIGlzIGFmdGVyIHRoZSBjaGVja2VkIGF0dHJpYnV0ZVxyXG4gICAgICAgIC8vIFN1cHBvcnQ6IFdpbmRvd3MgV2ViIEFwcHMgKFdXQSlcclxuICAgICAgICAvLyBgbmFtZWAgYW5kIGB0eXBlYCBuZWVkIC5zZXRBdHRyaWJ1dGUgZm9yIFdXQVxyXG4gICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZShcInR5cGVcIiwgXCJyYWRpb1wiKTtcclxuICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoXCJjaGVja2VkXCIsIFwiY2hlY2tlZFwiKTtcclxuICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoXCJuYW1lXCIsIFwidFwiKTtcclxuXHJcbiAgICAgICAgZGl2LmFwcGVuZENoaWxkKGlucHV0KTtcclxuXHJcbiAgICAgICAgLy8gU3VwcG9ydDogU2FmYXJpIDUuMSwgaU9TIDUuMSwgQW5kcm9pZCA0LngsIEFuZHJvaWQgMi4zXHJcbiAgICAgICAgLy8gb2xkIFdlYktpdCBkb2Vzbid0IGNsb25lIGNoZWNrZWQgc3RhdGUgY29ycmVjdGx5IGluIGZyYWdtZW50c1xyXG4gICAgICAgIHN1cHBvcnQuY2hlY2tDbG9uZSA9IGRpdi5jbG9uZU5vZGUodHJ1ZSkuY2xvbmVOb2RlKHRydWUpLmxhc3RDaGlsZC5jaGVja2VkO1xyXG5cclxuICAgICAgICAvLyBNYWtlIHN1cmUgdGV4dGFyZWEgKGFuZCBjaGVja2JveCkgZGVmYXVsdFZhbHVlIGlzIHByb3Blcmx5IGNsb25lZFxyXG4gICAgICAgIC8vIFN1cHBvcnQ6IElFOS1JRTExK1xyXG4gICAgICAgIGRpdi5pbm5lckhUTUwgPSBcIjx0ZXh0YXJlYT54PC90ZXh0YXJlYT5cIjtcclxuICAgICAgICBzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkID0gISFkaXYuY2xvbmVOb2RlKHRydWUpLmxhc3RDaGlsZC5kZWZhdWx0VmFsdWU7XHJcbiAgICB9KSgpO1xyXG4gICAgdmFyIHN0cnVuZGVmaW5lZCA9IHR5cGVvZiB1bmRlZmluZWQ7XHJcblxyXG5cclxuXHJcbiAgICBzdXBwb3J0LmZvY3VzaW5CdWJibGVzID0gXCJvbmZvY3VzaW5cIiBpbiB3aW5kb3c7XHJcblxyXG5cclxuICAgIHZhclxyXG4gICAgICAgIHJrZXlFdmVudCA9IC9ea2V5LyxcclxuICAgICAgICBybW91c2VFdmVudCA9IC9eKD86bW91c2V8cG9pbnRlcnxjb250ZXh0bWVudSl8Y2xpY2svLFxyXG4gICAgICAgIHJmb2N1c01vcnBoID0gL14oPzpmb2N1c2luZm9jdXN8Zm9jdXNvdXRibHVyKSQvLFxyXG4gICAgICAgIHJ0eXBlbmFtZXNwYWNlID0gL14oW14uXSopKD86XFwuKC4rKXwpJC87XHJcblxyXG4gICAgZnVuY3Rpb24gcmV0dXJuVHJ1ZSgpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByZXR1cm5GYWxzZSgpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc2FmZUFjdGl2ZUVsZW1lbnQoKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxyXG4gICAgfVxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb25zIGZvciBtYW5hZ2luZyBldmVudHMgLS0gbm90IHBhcnQgb2YgdGhlIHB1YmxpYyBpbnRlcmZhY2UuXHJcbiAgICAgKiBQcm9wcyB0byBEZWFuIEVkd2FyZHMnIGFkZEV2ZW50IGxpYnJhcnkgZm9yIG1hbnkgb2YgdGhlIGlkZWFzLlxyXG4gICAgICovXHJcbiAgICBqUXVlcnkuZXZlbnQgPSB7XHJcblxyXG4gICAgICAgIGdsb2JhbDoge30sXHJcblxyXG4gICAgICAgIGFkZDogZnVuY3Rpb24oZWxlbSwgdHlwZXMsIGhhbmRsZXIsIGRhdGEsIHNlbGVjdG9yKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgaGFuZGxlT2JqSW4sIGV2ZW50SGFuZGxlLCB0bXAsXHJcbiAgICAgICAgICAgICAgICBldmVudHMsIHQsIGhhbmRsZU9iaixcclxuICAgICAgICAgICAgICAgIHNwZWNpYWwsIGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcclxuICAgICAgICAgICAgICAgIGVsZW1EYXRhID0gZGF0YV9wcml2LmdldChlbGVtKTtcclxuXHJcbiAgICAgICAgICAgIC8vIERvbid0IGF0dGFjaCBldmVudHMgdG8gbm9EYXRhIG9yIHRleHQvY29tbWVudCBub2RlcyAoYnV0IGFsbG93IHBsYWluIG9iamVjdHMpXHJcbiAgICAgICAgICAgIGlmICghZWxlbURhdGEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQ2FsbGVyIGNhbiBwYXNzIGluIGFuIG9iamVjdCBvZiBjdXN0b20gZGF0YSBpbiBsaWV1IG9mIHRoZSBoYW5kbGVyXHJcbiAgICAgICAgICAgIGlmIChoYW5kbGVyLmhhbmRsZXIpIHtcclxuICAgICAgICAgICAgICAgIGhhbmRsZU9iakluID0gaGFuZGxlcjtcclxuICAgICAgICAgICAgICAgIGhhbmRsZXIgPSBoYW5kbGVPYmpJbi5oYW5kbGVyO1xyXG4gICAgICAgICAgICAgICAgc2VsZWN0b3IgPSBoYW5kbGVPYmpJbi5zZWxlY3RvcjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgdGhlIGhhbmRsZXIgaGFzIGEgdW5pcXVlIElELCB1c2VkIHRvIGZpbmQvcmVtb3ZlIGl0IGxhdGVyXHJcbiAgICAgICAgICAgIGlmICghaGFuZGxlci5ndWlkKSB7XHJcbiAgICAgICAgICAgICAgICBoYW5kbGVyLmd1aWQgPSBqUXVlcnkuZ3VpZCsrO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBJbml0IHRoZSBlbGVtZW50J3MgZXZlbnQgc3RydWN0dXJlIGFuZCBtYWluIGhhbmRsZXIsIGlmIHRoaXMgaXMgdGhlIGZpcnN0XHJcbiAgICAgICAgICAgIGlmICghKGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cykpIHtcclxuICAgICAgICAgICAgICAgIGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyA9IHt9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghKGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlKSkge1xyXG4gICAgICAgICAgICAgICAgZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgPSBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRGlzY2FyZCB0aGUgc2Vjb25kIGV2ZW50IG9mIGEgalF1ZXJ5LmV2ZW50LnRyaWdnZXIoKSBhbmRcclxuICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIGFuIGV2ZW50IGlzIGNhbGxlZCBhZnRlciBhIHBhZ2UgaGFzIHVubG9hZGVkXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBqUXVlcnkgIT09IHN0cnVuZGVmaW5lZCAmJiBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICE9PSBlLnR5cGUgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQuZGlzcGF0Y2guYXBwbHkoZWxlbSwgYXJndW1lbnRzKSA6IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEhhbmRsZSBtdWx0aXBsZSBldmVudHMgc2VwYXJhdGVkIGJ5IGEgc3BhY2VcclxuICAgICAgICAgICAgdHlwZXMgPSAodHlwZXMgfHwgXCJcIikubWF0Y2gocm5vdHdoaXRlKSB8fCBbXCJcIl07XHJcbiAgICAgICAgICAgIHQgPSB0eXBlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIHdoaWxlICh0LS0pIHtcclxuICAgICAgICAgICAgICAgIHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWModHlwZXNbdF0pIHx8IFtdO1xyXG4gICAgICAgICAgICAgICAgdHlwZSA9IG9yaWdUeXBlID0gdG1wWzFdO1xyXG4gICAgICAgICAgICAgICAgbmFtZXNwYWNlcyA9ICh0bXBbMl0gfHwgXCJcIikuc3BsaXQoXCIuXCIpLnNvcnQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBUaGVyZSAqbXVzdCogYmUgYSB0eXBlLCBubyBhdHRhY2hpbmcgbmFtZXNwYWNlLW9ubHkgaGFuZGxlcnNcclxuICAgICAgICAgICAgICAgIGlmICghdHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIElmIGV2ZW50IGNoYW5nZXMgaXRzIHR5cGUsIHVzZSB0aGUgc3BlY2lhbCBldmVudCBoYW5kbGVycyBmb3IgdGhlIGNoYW5nZWQgdHlwZVxyXG4gICAgICAgICAgICAgICAgc3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsW3R5cGVdIHx8IHt9O1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIElmIHNlbGVjdG9yIGRlZmluZWQsIGRldGVybWluZSBzcGVjaWFsIGV2ZW50IGFwaSB0eXBlLCBvdGhlcndpc2UgZ2l2ZW4gdHlwZVxyXG4gICAgICAgICAgICAgICAgdHlwZSA9IChzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSkgfHwgdHlwZTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgc3BlY2lhbCBiYXNlZCBvbiBuZXdseSByZXNldCB0eXBlXHJcbiAgICAgICAgICAgICAgICBzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbdHlwZV0gfHwge307XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gaGFuZGxlT2JqIGlzIHBhc3NlZCB0byBhbGwgZXZlbnQgaGFuZGxlcnNcclxuICAgICAgICAgICAgICAgIGhhbmRsZU9iaiA9IGpRdWVyeS5leHRlbmQoe1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgb3JpZ1R5cGU6IG9yaWdUeXBlLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEsXHJcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlcjogaGFuZGxlcixcclxuICAgICAgICAgICAgICAgICAgICBndWlkOiBoYW5kbGVyLmd1aWQsXHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6IHNlbGVjdG9yLFxyXG4gICAgICAgICAgICAgICAgICAgIG5lZWRzQ29udGV4dDogc2VsZWN0b3IgJiYgalF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0LnRlc3Qoc2VsZWN0b3IpLFxyXG4gICAgICAgICAgICAgICAgICAgIG5hbWVzcGFjZTogbmFtZXNwYWNlcy5qb2luKFwiLlwiKVxyXG4gICAgICAgICAgICAgICAgfSwgaGFuZGxlT2JqSW4pO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEluaXQgdGhlIGV2ZW50IGhhbmRsZXIgcXVldWUgaWYgd2UncmUgdGhlIGZpcnN0XHJcbiAgICAgICAgICAgICAgICBpZiAoIShoYW5kbGVycyA9IGV2ZW50c1t0eXBlXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVycyA9IGV2ZW50c1t0eXBlXSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXJzLmRlbGVnYXRlQ291bnQgPSAwO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IHVzZSBhZGRFdmVudExpc3RlbmVyIGlmIHRoZSBzcGVjaWFsIGV2ZW50cyBoYW5kbGVyIHJldHVybnMgZmFsc2VcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXNwZWNpYWwuc2V0dXAgfHwgc3BlY2lhbC5zZXR1cC5jYWxsKGVsZW0sIGRhdGEsIG5hbWVzcGFjZXMsIGV2ZW50SGFuZGxlKSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW0uYWRkRXZlbnRMaXN0ZW5lcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGV2ZW50SGFuZGxlLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHNwZWNpYWwuYWRkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3BlY2lhbC5hZGQuY2FsbChlbGVtLCBoYW5kbGVPYmopO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWhhbmRsZU9iai5oYW5kbGVyLmd1aWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCA9IGhhbmRsZXIuZ3VpZDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQWRkIHRvIHRoZSBlbGVtZW50J3MgaGFuZGxlciBsaXN0LCBkZWxlZ2F0ZXMgaW4gZnJvbnRcclxuICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXJzLnNwbGljZShoYW5kbGVycy5kZWxlZ2F0ZUNvdW50KyssIDAsIGhhbmRsZU9iaik7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXJzLnB1c2goaGFuZGxlT2JqKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBLZWVwIHRyYWNrIG9mIHdoaWNoIGV2ZW50cyBoYXZlIGV2ZXIgYmVlbiB1c2VkLCBmb3IgZXZlbnQgb3B0aW1pemF0aW9uXHJcbiAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQuZ2xvYmFsW3R5cGVdID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvLyBEZXRhY2ggYW4gZXZlbnQgb3Igc2V0IG9mIGV2ZW50cyBmcm9tIGFuIGVsZW1lbnRcclxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uKGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBzZWxlY3RvciwgbWFwcGVkVHlwZXMpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBqLCBvcmlnQ291bnQsIHRtcCxcclxuICAgICAgICAgICAgICAgIGV2ZW50cywgdCwgaGFuZGxlT2JqLFxyXG4gICAgICAgICAgICAgICAgc3BlY2lhbCwgaGFuZGxlcnMsIHR5cGUsIG5hbWVzcGFjZXMsIG9yaWdUeXBlLFxyXG4gICAgICAgICAgICAgICAgZWxlbURhdGEgPSBkYXRhX3ByaXYuaGFzRGF0YShlbGVtKSAmJiBkYXRhX3ByaXYuZ2V0KGVsZW0pO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFlbGVtRGF0YSB8fCAhKGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gT25jZSBmb3IgZWFjaCB0eXBlLm5hbWVzcGFjZSBpbiB0eXBlczsgdHlwZSBtYXkgYmUgb21pdHRlZFxyXG4gICAgICAgICAgICB0eXBlcyA9ICh0eXBlcyB8fCBcIlwiKS5tYXRjaChybm90d2hpdGUpIHx8IFtcIlwiXTtcclxuICAgICAgICAgICAgdCA9IHR5cGVzLmxlbmd0aDtcclxuICAgICAgICAgICAgd2hpbGUgKHQtLSkge1xyXG4gICAgICAgICAgICAgICAgdG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyh0eXBlc1t0XSkgfHwgW107XHJcbiAgICAgICAgICAgICAgICB0eXBlID0gb3JpZ1R5cGUgPSB0bXBbMV07XHJcbiAgICAgICAgICAgICAgICBuYW1lc3BhY2VzID0gKHRtcFsyXSB8fCBcIlwiKS5zcGxpdChcIi5cIikuc29ydCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFVuYmluZCBhbGwgZXZlbnRzIChvbiB0aGlzIG5hbWVzcGFjZSwgaWYgcHJvdmlkZWQpIGZvciB0aGUgZWxlbWVudFxyXG4gICAgICAgICAgICAgICAgaWYgKCF0eXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh0eXBlIGluIGV2ZW50cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQucmVtb3ZlKGVsZW0sIHR5cGUgKyB0eXBlc1t0XSwgaGFuZGxlciwgc2VsZWN0b3IsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbdHlwZV0gfHwge307XHJcbiAgICAgICAgICAgICAgICB0eXBlID0gKHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlKSB8fCB0eXBlO1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlcnMgPSBldmVudHNbdHlwZV0gfHwgW107XHJcbiAgICAgICAgICAgICAgICB0bXAgPSB0bXBbMl0gJiYgbmV3IFJlZ0V4cChcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKFwiXFxcXC4oPzouKlxcXFwufClcIikgKyBcIihcXFxcLnwkKVwiKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgbWF0Y2hpbmcgZXZlbnRzXHJcbiAgICAgICAgICAgICAgICBvcmlnQ291bnQgPSBqID0gaGFuZGxlcnMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGotLSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZU9iaiA9IGhhbmRsZXJzW2pdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoKG1hcHBlZFR5cGVzIHx8IG9yaWdUeXBlID09PSBoYW5kbGVPYmoub3JpZ1R5cGUpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICghaGFuZGxlciB8fCBoYW5kbGVyLmd1aWQgPT09IGhhbmRsZU9iai5ndWlkKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoIXRtcCB8fCB0bXAudGVzdChoYW5kbGVPYmoubmFtZXNwYWNlKSkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgKCFzZWxlY3RvciB8fCBzZWxlY3RvciA9PT0gaGFuZGxlT2JqLnNlbGVjdG9yIHx8IHNlbGVjdG9yID09PSBcIioqXCIgJiYgaGFuZGxlT2JqLnNlbGVjdG9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVycy5zcGxpY2UoaiwgMSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlT2JqLnNlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LS07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNwZWNpYWwucmVtb3ZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGVjaWFsLnJlbW92ZS5jYWxsKGVsZW0sIGhhbmRsZU9iaik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGdlbmVyaWMgZXZlbnQgaGFuZGxlciBpZiB3ZSByZW1vdmVkIHNvbWV0aGluZyBhbmQgbm8gbW9yZSBoYW5kbGVycyBleGlzdFxyXG4gICAgICAgICAgICAgICAgLy8gKGF2b2lkcyBwb3RlbnRpYWwgZm9yIGVuZGxlc3MgcmVjdXJzaW9uIGR1cmluZyByZW1vdmFsIG9mIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMpXHJcbiAgICAgICAgICAgICAgICBpZiAob3JpZ0NvdW50ICYmICFoYW5kbGVycy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXNwZWNpYWwudGVhcmRvd24gfHwgc3BlY2lhbC50ZWFyZG93bi5jYWxsKGVsZW0sIG5hbWVzcGFjZXMsIGVsZW1EYXRhLmhhbmRsZSkgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5yZW1vdmVFdmVudChlbGVtLCB0eXBlLCBlbGVtRGF0YS5oYW5kbGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBleHBhbmRvIGlmIGl0J3Mgbm8gbG9uZ2VyIHVzZWRcclxuICAgICAgICAgICAgaWYgKGpRdWVyeS5pc0VtcHR5T2JqZWN0KGV2ZW50cykpIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBlbGVtRGF0YS5oYW5kbGU7XHJcbiAgICAgICAgICAgICAgICBkYXRhX3ByaXYucmVtb3ZlKGVsZW0sIFwiZXZlbnRzXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgdHJpZ2dlcjogZnVuY3Rpb24oZXZlbnQsIGRhdGEsIGVsZW0sIG9ubHlIYW5kbGVycykge1xyXG5cclxuICAgICAgICAgICAgdmFyIGksIGN1ciwgdG1wLCBidWJibGVUeXBlLCBvbnR5cGUsIGhhbmRsZSwgc3BlY2lhbCxcclxuICAgICAgICAgICAgICAgIGV2ZW50UGF0aCA9IFtlbGVtIHx8IGRvY3VtZW50XSxcclxuICAgICAgICAgICAgICAgIHR5cGUgPSBoYXNPd24uY2FsbChldmVudCwgXCJ0eXBlXCIpID8gZXZlbnQudHlwZSA6IGV2ZW50LFxyXG4gICAgICAgICAgICAgICAgbmFtZXNwYWNlcyA9IGhhc093bi5jYWxsKGV2ZW50LCBcIm5hbWVzcGFjZVwiKSA/IGV2ZW50Lm5hbWVzcGFjZS5zcGxpdChcIi5cIikgOiBbXTtcclxuXHJcbiAgICAgICAgICAgIGN1ciA9IHRtcCA9IGVsZW0gPSBlbGVtIHx8IGRvY3VtZW50O1xyXG5cclxuICAgICAgICAgICAgLy8gRG9uJ3QgZG8gZXZlbnRzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcclxuICAgICAgICAgICAgaWYgKGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBmb2N1cy9ibHVyIG1vcnBocyB0byBmb2N1c2luL291dDsgZW5zdXJlIHdlJ3JlIG5vdCBmaXJpbmcgdGhlbSByaWdodCBub3dcclxuICAgICAgICAgICAgaWYgKHJmb2N1c01vcnBoLnRlc3QodHlwZSArIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0eXBlLmluZGV4T2YoXCIuXCIpID49IDApIHtcclxuICAgICAgICAgICAgICAgIC8vIE5hbWVzcGFjZWQgdHJpZ2dlcjsgY3JlYXRlIGEgcmVnZXhwIHRvIG1hdGNoIGV2ZW50IHR5cGUgaW4gaGFuZGxlKClcclxuICAgICAgICAgICAgICAgIG5hbWVzcGFjZXMgPSB0eXBlLnNwbGl0KFwiLlwiKTtcclxuICAgICAgICAgICAgICAgIHR5cGUgPSBuYW1lc3BhY2VzLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICBuYW1lc3BhY2VzLnNvcnQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvbnR5cGUgPSB0eXBlLmluZGV4T2YoXCI6XCIpIDwgMCAmJiBcIm9uXCIgKyB0eXBlO1xyXG5cclxuICAgICAgICAgICAgLy8gQ2FsbGVyIGNhbiBwYXNzIGluIGEgalF1ZXJ5LkV2ZW50IG9iamVjdCwgT2JqZWN0LCBvciBqdXN0IGFuIGV2ZW50IHR5cGUgc3RyaW5nXHJcbiAgICAgICAgICAgIGV2ZW50ID0gZXZlbnRbalF1ZXJ5LmV4cGFuZG9dID9cclxuICAgICAgICAgICAgICAgIGV2ZW50IDpcclxuICAgICAgICAgICAgICAgIG5ldyBqUXVlcnkuRXZlbnQodHlwZSwgdHlwZW9mIGV2ZW50ID09PSBcIm9iamVjdFwiICYmIGV2ZW50KTtcclxuXHJcbiAgICAgICAgICAgIC8vIFRyaWdnZXIgYml0bWFzazogJiAxIGZvciBuYXRpdmUgaGFuZGxlcnM7ICYgMiBmb3IgalF1ZXJ5IChhbHdheXMgdHJ1ZSlcclxuICAgICAgICAgICAgZXZlbnQuaXNUcmlnZ2VyID0gb25seUhhbmRsZXJzID8gMiA6IDM7XHJcbiAgICAgICAgICAgIGV2ZW50Lm5hbWVzcGFjZSA9IG5hbWVzcGFjZXMuam9pbihcIi5cIik7XHJcbiAgICAgICAgICAgIGV2ZW50Lm5hbWVzcGFjZV9yZSA9IGV2ZW50Lm5hbWVzcGFjZSA/XHJcbiAgICAgICAgICAgICAgICBuZXcgUmVnRXhwKFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2VzLmpvaW4oXCJcXFxcLig/Oi4qXFxcXC58KVwiKSArIFwiKFxcXFwufCQpXCIpIDpcclxuICAgICAgICAgICAgICAgIG51bGw7XHJcblxyXG4gICAgICAgICAgICAvLyBDbGVhbiB1cCB0aGUgZXZlbnQgaW4gY2FzZSBpdCBpcyBiZWluZyByZXVzZWRcclxuICAgICAgICAgICAgZXZlbnQucmVzdWx0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICBpZiAoIWV2ZW50LnRhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgZXZlbnQudGFyZ2V0ID0gZWxlbTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQ2xvbmUgYW55IGluY29taW5nIGRhdGEgYW5kIHByZXBlbmQgdGhlIGV2ZW50LCBjcmVhdGluZyB0aGUgaGFuZGxlciBhcmcgbGlzdFxyXG4gICAgICAgICAgICBkYXRhID0gZGF0YSA9PSBudWxsID8gW2V2ZW50XSA6XHJcbiAgICAgICAgICAgICAgICBqUXVlcnkubWFrZUFycmF5KGRhdGEsIFtldmVudF0pO1xyXG5cclxuICAgICAgICAgICAgLy8gQWxsb3cgc3BlY2lhbCBldmVudHMgdG8gZHJhdyBvdXRzaWRlIHRoZSBsaW5lc1xyXG4gICAgICAgICAgICBzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbdHlwZV0gfHwge307XHJcbiAgICAgICAgICAgIGlmICghb25seUhhbmRsZXJzICYmIHNwZWNpYWwudHJpZ2dlciAmJiBzcGVjaWFsLnRyaWdnZXIuYXBwbHkoZWxlbSwgZGF0YSkgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIERldGVybWluZSBldmVudCBwcm9wYWdhdGlvbiBwYXRoIGluIGFkdmFuY2UsIHBlciBXM0MgZXZlbnRzIHNwZWMgKCM5OTUxKVxyXG4gICAgICAgICAgICAvLyBCdWJibGUgdXAgdG8gZG9jdW1lbnQsIHRoZW4gdG8gd2luZG93OyB3YXRjaCBmb3IgYSBnbG9iYWwgb3duZXJEb2N1bWVudCB2YXIgKCM5NzI0KVxyXG4gICAgICAgICAgICBpZiAoIW9ubHlIYW5kbGVycyAmJiAhc3BlY2lhbC5ub0J1YmJsZSAmJiAhalF1ZXJ5LmlzV2luZG93KGVsZW0pKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgYnViYmxlVHlwZSA9IHNwZWNpYWwuZGVsZWdhdGVUeXBlIHx8IHR5cGU7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXJmb2N1c01vcnBoLnRlc3QoYnViYmxlVHlwZSArIHR5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VyID0gY3VyLnBhcmVudE5vZGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmb3IgKDsgY3VyOyBjdXIgPSBjdXIucGFyZW50Tm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50UGF0aC5wdXNoKGN1cik7XHJcbiAgICAgICAgICAgICAgICAgICAgdG1wID0gY3VyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIE9ubHkgYWRkIHdpbmRvdyBpZiB3ZSBnb3QgdG8gZG9jdW1lbnQgKGUuZy4sIG5vdCBwbGFpbiBvYmogb3IgZGV0YWNoZWQgRE9NKVxyXG4gICAgICAgICAgICAgICAgaWYgKHRtcCA9PT0gKGVsZW0ub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBldmVudFBhdGgucHVzaCh0bXAuZGVmYXVsdFZpZXcgfHwgdG1wLnBhcmVudFdpbmRvdyB8fCB3aW5kb3cpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBGaXJlIGhhbmRsZXJzIG9uIHRoZSBldmVudCBwYXRoXHJcbiAgICAgICAgICAgIGkgPSAwO1xyXG4gICAgICAgICAgICB3aGlsZSAoKGN1ciA9IGV2ZW50UGF0aFtpKytdKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xyXG5cclxuICAgICAgICAgICAgICAgIGV2ZW50LnR5cGUgPSBpID4gMSA/XHJcbiAgICAgICAgICAgICAgICAgICAgYnViYmxlVHlwZSA6XHJcbiAgICAgICAgICAgICAgICAgICAgc3BlY2lhbC5iaW5kVHlwZSB8fCB0eXBlO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGpRdWVyeSBoYW5kbGVyXHJcbiAgICAgICAgICAgICAgICBoYW5kbGUgPSAoZGF0YV9wcml2LmdldChjdXIsIFwiZXZlbnRzXCIpIHx8IHt9KVtldmVudC50eXBlXSAmJiBkYXRhX3ByaXYuZ2V0KGN1ciwgXCJoYW5kbGVcIik7XHJcbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlLmFwcGx5KGN1ciwgZGF0YSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gTmF0aXZlIGhhbmRsZXJcclxuICAgICAgICAgICAgICAgIGhhbmRsZSA9IG9udHlwZSAmJiBjdXJbb250eXBlXTtcclxuICAgICAgICAgICAgICAgIGlmIChoYW5kbGUgJiYgaGFuZGxlLmFwcGx5ICYmIGpRdWVyeS5hY2NlcHREYXRhKGN1cikpIHtcclxuICAgICAgICAgICAgICAgICAgICBldmVudC5yZXN1bHQgPSBoYW5kbGUuYXBwbHkoY3VyLCBkYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQucmVzdWx0ID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBldmVudC50eXBlID0gdHlwZTtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIG5vYm9keSBwcmV2ZW50ZWQgdGhlIGRlZmF1bHQgYWN0aW9uLCBkbyBpdCBub3dcclxuICAgICAgICAgICAgaWYgKCFvbmx5SGFuZGxlcnMgJiYgIWV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCghc3BlY2lhbC5fZGVmYXVsdCB8fCBzcGVjaWFsLl9kZWZhdWx0LmFwcGx5KGV2ZW50UGF0aC5wb3AoKSwgZGF0YSkgPT09IGZhbHNlKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5hY2NlcHREYXRhKGVsZW0pKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIENhbGwgYSBuYXRpdmUgRE9NIG1ldGhvZCBvbiB0aGUgdGFyZ2V0IHdpdGggdGhlIHNhbWUgbmFtZSBuYW1lIGFzIHRoZSBldmVudC5cclxuICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBkbyBkZWZhdWx0IGFjdGlvbnMgb24gd2luZG93LCB0aGF0J3Mgd2hlcmUgZ2xvYmFsIHZhcmlhYmxlcyBiZSAoIzYxNzApXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9udHlwZSAmJiBqUXVlcnkuaXNGdW5jdGlvbihlbGVtW3R5cGVdKSAmJiAhalF1ZXJ5LmlzV2luZG93KGVsZW0pKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCByZS10cmlnZ2VyIGFuIG9uRk9PIGV2ZW50IHdoZW4gd2UgY2FsbCBpdHMgRk9PKCkgbWV0aG9kXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRtcCA9IGVsZW1bb250eXBlXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0bXApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1bb250eXBlXSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgcmUtdHJpZ2dlcmluZyBvZiB0aGUgc2FtZSBldmVudCwgc2luY2Ugd2UgYWxyZWFkeSBidWJibGVkIGl0IGFib3ZlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB0eXBlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtW3R5cGVdKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodG1wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtW29udHlwZV0gPSB0bXA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBldmVudC5yZXN1bHQ7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZGlzcGF0Y2g6IGZ1bmN0aW9uKGV2ZW50KSB7XHJcblxyXG4gICAgICAgICAgICAvLyBNYWtlIGEgd3JpdGFibGUgalF1ZXJ5LkV2ZW50IGZyb20gdGhlIG5hdGl2ZSBldmVudCBvYmplY3RcclxuICAgICAgICAgICAgZXZlbnQgPSBqUXVlcnkuZXZlbnQuZml4KGV2ZW50KTtcclxuXHJcbiAgICAgICAgICAgIHZhciBpLCBqLCByZXQsIG1hdGNoZWQsIGhhbmRsZU9iaixcclxuICAgICAgICAgICAgICAgIGhhbmRsZXJRdWV1ZSA9IFtdLFxyXG4gICAgICAgICAgICAgICAgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzKSxcclxuICAgICAgICAgICAgICAgIGhhbmRsZXJzID0gKGRhdGFfcHJpdi5nZXQodGhpcywgXCJldmVudHNcIikgfHwge30pW2V2ZW50LnR5cGVdIHx8IFtdLFxyXG4gICAgICAgICAgICAgICAgc3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsW2V2ZW50LnR5cGVdIHx8IHt9O1xyXG5cclxuICAgICAgICAgICAgLy8gVXNlIHRoZSBmaXgtZWQgalF1ZXJ5LkV2ZW50IHJhdGhlciB0aGFuIHRoZSAocmVhZC1vbmx5KSBuYXRpdmUgZXZlbnRcclxuICAgICAgICAgICAgYXJnc1swXSA9IGV2ZW50O1xyXG4gICAgICAgICAgICBldmVudC5kZWxlZ2F0ZVRhcmdldCA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICAvLyBDYWxsIHRoZSBwcmVEaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGUsIGFuZCBsZXQgaXQgYmFpbCBpZiBkZXNpcmVkXHJcbiAgICAgICAgICAgIGlmIChzcGVjaWFsLnByZURpc3BhdGNoICYmIHNwZWNpYWwucHJlRGlzcGF0Y2guY2FsbCh0aGlzLCBldmVudCkgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIERldGVybWluZSBoYW5kbGVyc1xyXG4gICAgICAgICAgICBoYW5kbGVyUXVldWUgPSBqUXVlcnkuZXZlbnQuaGFuZGxlcnMuY2FsbCh0aGlzLCBldmVudCwgaGFuZGxlcnMpO1xyXG5cclxuICAgICAgICAgICAgLy8gUnVuIGRlbGVnYXRlcyBmaXJzdDsgdGhleSBtYXkgd2FudCB0byBzdG9wIHByb3BhZ2F0aW9uIGJlbmVhdGggdXNcclxuICAgICAgICAgICAgaSA9IDA7XHJcbiAgICAgICAgICAgIHdoaWxlICgobWF0Y2hlZCA9IGhhbmRsZXJRdWV1ZVtpKytdKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgZXZlbnQuY3VycmVudFRhcmdldCA9IG1hdGNoZWQuZWxlbTtcclxuXHJcbiAgICAgICAgICAgICAgICBqID0gMDtcclxuICAgICAgICAgICAgICAgIHdoaWxlICgoaGFuZGxlT2JqID0gbWF0Y2hlZC5oYW5kbGVyc1tqKytdKSAmJiAhZXZlbnQuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBUcmlnZ2VyZWQgZXZlbnQgbXVzdCBlaXRoZXIgMSkgaGF2ZSBubyBuYW1lc3BhY2UsIG9yXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gMikgaGF2ZSBuYW1lc3BhY2UocykgYSBzdWJzZXQgb3IgZXF1YWwgdG8gdGhvc2UgaW4gdGhlIGJvdW5kIGV2ZW50IChib3RoIGNhbiBoYXZlIG5vIG5hbWVzcGFjZSkuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFldmVudC5uYW1lc3BhY2VfcmUgfHwgZXZlbnQubmFtZXNwYWNlX3JlLnRlc3QoaGFuZGxlT2JqLm5hbWVzcGFjZSkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LmhhbmRsZU9iaiA9IGhhbmRsZU9iajtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuZGF0YSA9IGhhbmRsZU9iai5kYXRhO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0ID0gKChqUXVlcnkuZXZlbnQuc3BlY2lhbFtoYW5kbGVPYmoub3JpZ1R5cGVdIHx8IHt9KS5oYW5kbGUgfHwgaGFuZGxlT2JqLmhhbmRsZXIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwbHkobWF0Y2hlZC5lbGVtLCBhcmdzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChldmVudC5yZXN1bHQgPSByZXQpID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIENhbGwgdGhlIHBvc3REaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGVcclxuICAgICAgICAgICAgaWYgKHNwZWNpYWwucG9zdERpc3BhdGNoKSB7XHJcbiAgICAgICAgICAgICAgICBzcGVjaWFsLnBvc3REaXNwYXRjaC5jYWxsKHRoaXMsIGV2ZW50KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50LnJlc3VsdDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBoYW5kbGVyczogZnVuY3Rpb24oZXZlbnQsIGhhbmRsZXJzKSB7XHJcbiAgICAgICAgICAgIHZhciBpLCBtYXRjaGVzLCBzZWwsIGhhbmRsZU9iaixcclxuICAgICAgICAgICAgICAgIGhhbmRsZXJRdWV1ZSA9IFtdLFxyXG4gICAgICAgICAgICAgICAgZGVsZWdhdGVDb3VudCA9IGhhbmRsZXJzLmRlbGVnYXRlQ291bnQsXHJcbiAgICAgICAgICAgICAgICBjdXIgPSBldmVudC50YXJnZXQ7XHJcblxyXG4gICAgICAgICAgICAvLyBGaW5kIGRlbGVnYXRlIGhhbmRsZXJzXHJcbiAgICAgICAgICAgIC8vIEJsYWNrLWhvbGUgU1ZHIDx1c2U+IGluc3RhbmNlIHRyZWVzICgjMTMxODApXHJcbiAgICAgICAgICAgIC8vIEF2b2lkIG5vbi1sZWZ0LWNsaWNrIGJ1YmJsaW5nIGluIEZpcmVmb3ggKCMzODYxKVxyXG4gICAgICAgICAgICBpZiAoZGVsZWdhdGVDb3VudCAmJiBjdXIubm9kZVR5cGUgJiYgKCFldmVudC5idXR0b24gfHwgZXZlbnQudHlwZSAhPT0gXCJjbGlja1wiKSkge1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoOyBjdXIgIT09IHRoaXM7IGN1ciA9IGN1ci5wYXJlbnROb2RlIHx8IHRoaXMpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgcHJvY2VzcyBjbGlja3Mgb24gZGlzYWJsZWQgZWxlbWVudHMgKCM2OTExLCAjODE2NSwgIzExMzgyLCAjMTE3NjQpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1ci5kaXNhYmxlZCAhPT0gdHJ1ZSB8fCBldmVudC50eXBlICE9PSBcImNsaWNrXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZGVsZWdhdGVDb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVPYmogPSBoYW5kbGVyc1tpXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBjb25mbGljdCB3aXRoIE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoIzEzMjAzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsID0gaGFuZGxlT2JqLnNlbGVjdG9yICsgXCIgXCI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoZXNbc2VsXSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlc1tzZWxdID0gaGFuZGxlT2JqLm5lZWRzQ29udGV4dCA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeShzZWwsIHRoaXMpLmluZGV4KGN1cikgPj0gMCA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5maW5kKHNlbCwgdGhpcywgbnVsbCwgW2N1cl0pLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzW3NlbF0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVzLnB1c2goaGFuZGxlT2JqKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXJRdWV1ZS5wdXNoKHsgZWxlbTogY3VyLCBoYW5kbGVyczogbWF0Y2hlcyB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQWRkIHRoZSByZW1haW5pbmcgKGRpcmVjdGx5LWJvdW5kKSBoYW5kbGVyc1xyXG4gICAgICAgICAgICBpZiAoZGVsZWdhdGVDb3VudCA8IGhhbmRsZXJzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlclF1ZXVlLnB1c2goeyBlbGVtOiB0aGlzLCBoYW5kbGVyczogaGFuZGxlcnMuc2xpY2UoZGVsZWdhdGVDb3VudCkgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVyUXVldWU7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy8gSW5jbHVkZXMgc29tZSBldmVudCBwcm9wcyBzaGFyZWQgYnkgS2V5RXZlbnQgYW5kIE1vdXNlRXZlbnRcclxuICAgICAgICBwcm9wczogXCJhbHRLZXkgYnViYmxlcyBjYW5jZWxhYmxlIGN0cmxLZXkgY3VycmVudFRhcmdldCBldmVudFBoYXNlIG1ldGFLZXkgcmVsYXRlZFRhcmdldCBzaGlmdEtleSB0YXJnZXQgdGltZVN0YW1wIHZpZXcgd2hpY2hcIi5zcGxpdChcIiBcIiksXHJcblxyXG4gICAgICAgIGZpeEhvb2tzOiB7fSxcclxuXHJcbiAgICAgICAga2V5SG9va3M6IHtcclxuICAgICAgICAgICAgcHJvcHM6IFwiY2hhciBjaGFyQ29kZSBrZXkga2V5Q29kZVwiLnNwbGl0KFwiIFwiKSxcclxuICAgICAgICAgICAgZmlsdGVyOiBmdW5jdGlvbihldmVudCwgb3JpZ2luYWwpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBBZGQgd2hpY2ggZm9yIGtleSBldmVudHNcclxuICAgICAgICAgICAgICAgIGlmIChldmVudC53aGljaCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQud2hpY2ggPSBvcmlnaW5hbC5jaGFyQ29kZSAhPSBudWxsID8gb3JpZ2luYWwuY2hhckNvZGUgOiBvcmlnaW5hbC5rZXlDb2RlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBldmVudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIG1vdXNlSG9va3M6IHtcclxuICAgICAgICAgICAgcHJvcHM6IFwiYnV0dG9uIGJ1dHRvbnMgY2xpZW50WCBjbGllbnRZIG9mZnNldFggb2Zmc2V0WSBwYWdlWCBwYWdlWSBzY3JlZW5YIHNjcmVlblkgdG9FbGVtZW50XCIuc3BsaXQoXCIgXCIpLFxyXG4gICAgICAgICAgICBmaWx0ZXI6IGZ1bmN0aW9uKGV2ZW50LCBvcmlnaW5hbCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50RG9jLCBkb2MsIGJvZHksXHJcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uID0gb3JpZ2luYWwuYnV0dG9uO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBwYWdlWC9ZIGlmIG1pc3NpbmcgYW5kIGNsaWVudFgvWSBhdmFpbGFibGVcclxuICAgICAgICAgICAgICAgIGlmIChldmVudC5wYWdlWCA9PSBudWxsICYmIG9yaWdpbmFsLmNsaWVudFggIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50RG9jID0gZXZlbnQudGFyZ2V0Lm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9jID0gZXZlbnREb2MuZG9jdW1lbnRFbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIGJvZHkgPSBldmVudERvYy5ib2R5O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBldmVudC5wYWdlWCA9IG9yaWdpbmFsLmNsaWVudFggKyAoZG9jICYmIGRvYy5zY3JvbGxMZWZ0IHx8IGJvZHkgJiYgYm9keS5zY3JvbGxMZWZ0IHx8IDApIC0gKGRvYyAmJiBkb2MuY2xpZW50TGVmdCB8fCBib2R5ICYmIGJvZHkuY2xpZW50TGVmdCB8fCAwKTtcclxuICAgICAgICAgICAgICAgICAgICBldmVudC5wYWdlWSA9IG9yaWdpbmFsLmNsaWVudFkgKyAoZG9jICYmIGRvYy5zY3JvbGxUb3AgfHwgYm9keSAmJiBib2R5LnNjcm9sbFRvcCB8fCAwKSAtIChkb2MgJiYgZG9jLmNsaWVudFRvcCB8fCBib2R5ICYmIGJvZHkuY2xpZW50VG9wIHx8IDApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIEFkZCB3aGljaCBmb3IgY2xpY2s6IDEgPT09IGxlZnQ7IDIgPT09IG1pZGRsZTsgMyA9PT0gcmlnaHRcclxuICAgICAgICAgICAgICAgIC8vIE5vdGU6IGJ1dHRvbiBpcyBub3Qgbm9ybWFsaXplZCwgc28gZG9uJ3QgdXNlIGl0XHJcbiAgICAgICAgICAgICAgICBpZiAoIWV2ZW50LndoaWNoICYmIGJ1dHRvbiAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQud2hpY2ggPSAoYnV0dG9uICYgMSA/IDEgOiAoYnV0dG9uICYgMiA/IDMgOiAoYnV0dG9uICYgNCA/IDIgOiAwKSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBldmVudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGZpeDogZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgICAgICAgaWYgKGV2ZW50W2pRdWVyeS5leHBhbmRvXSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBDcmVhdGUgYSB3cml0YWJsZSBjb3B5IG9mIHRoZSBldmVudCBvYmplY3QgYW5kIG5vcm1hbGl6ZSBzb21lIHByb3BlcnRpZXNcclxuICAgICAgICAgICAgdmFyIGksIHByb3AsIGNvcHksXHJcbiAgICAgICAgICAgICAgICB0eXBlID0gZXZlbnQudHlwZSxcclxuICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQgPSBldmVudCxcclxuICAgICAgICAgICAgICAgIGZpeEhvb2sgPSB0aGlzLmZpeEhvb2tzW3R5cGVdO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFmaXhIb29rKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZpeEhvb2tzW3R5cGVdID0gZml4SG9vayA9XHJcbiAgICAgICAgICAgICAgICAgICAgcm1vdXNlRXZlbnQudGVzdCh0eXBlKSA/IHRoaXMubW91c2VIb29rcyA6XHJcbiAgICAgICAgICAgICAgICAgICAgcmtleUV2ZW50LnRlc3QodHlwZSkgPyB0aGlzLmtleUhvb2tzIDoge307XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29weSA9IGZpeEhvb2sucHJvcHMgPyB0aGlzLnByb3BzLmNvbmNhdChmaXhIb29rLnByb3BzKSA6IHRoaXMucHJvcHM7XHJcblxyXG4gICAgICAgICAgICBldmVudCA9IG5ldyBqUXVlcnkuRXZlbnQob3JpZ2luYWxFdmVudCk7XHJcblxyXG4gICAgICAgICAgICBpID0gY29weS5sZW5ndGg7XHJcbiAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgICAgICAgICAgIHByb3AgPSBjb3B5W2ldO1xyXG4gICAgICAgICAgICAgICAgZXZlbnRbcHJvcF0gPSBvcmlnaW5hbEV2ZW50W3Byb3BdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBTdXBwb3J0OiBDb3Jkb3ZhIDIuNSAoV2ViS2l0KSAoIzEzMjU1KVxyXG4gICAgICAgICAgICAvLyBBbGwgZXZlbnRzIHNob3VsZCBoYXZlIGEgdGFyZ2V0OyBDb3Jkb3ZhIGRldmljZXJlYWR5IGRvZXNuJ3RcclxuICAgICAgICAgICAgaWYgKCFldmVudC50YXJnZXQpIHtcclxuICAgICAgICAgICAgICAgIGV2ZW50LnRhcmdldCA9IGRvY3VtZW50O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBTdXBwb3J0OiBTYWZhcmkgNi4wKywgQ2hyb21lIDwgMjhcclxuICAgICAgICAgICAgLy8gVGFyZ2V0IHNob3VsZCBub3QgYmUgYSB0ZXh0IG5vZGUgKCM1MDQsICMxMzE0MylcclxuICAgICAgICAgICAgaWYgKGV2ZW50LnRhcmdldC5ub2RlVHlwZSA9PT0gMykge1xyXG4gICAgICAgICAgICAgICAgZXZlbnQudGFyZ2V0ID0gZXZlbnQudGFyZ2V0LnBhcmVudE5vZGU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBmaXhIb29rLmZpbHRlciA/IGZpeEhvb2suZmlsdGVyKGV2ZW50LCBvcmlnaW5hbEV2ZW50KSA6IGV2ZW50O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNwZWNpYWw6IHtcclxuICAgICAgICAgICAgbG9hZDoge1xyXG4gICAgICAgICAgICAgICAgLy8gUHJldmVudCB0cmlnZ2VyZWQgaW1hZ2UubG9hZCBldmVudHMgZnJvbSBidWJibGluZyB0byB3aW5kb3cubG9hZFxyXG4gICAgICAgICAgICAgICAgbm9CdWJibGU6IHRydWVcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZm9jdXM6IHtcclxuICAgICAgICAgICAgICAgIC8vIEZpcmUgbmF0aXZlIGV2ZW50IGlmIHBvc3NpYmxlIHNvIGJsdXIvZm9jdXMgc2VxdWVuY2UgaXMgY29ycmVjdFxyXG4gICAgICAgICAgICAgICAgdHJpZ2dlcjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMgIT09IHNhZmVBY3RpdmVFbGVtZW50KCkgJiYgdGhpcy5mb2N1cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZvY3VzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZGVsZWdhdGVUeXBlOiBcImZvY3VzaW5cIlxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBibHVyOiB7XHJcbiAgICAgICAgICAgICAgICB0cmlnZ2VyOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcyA9PT0gc2FmZUFjdGl2ZUVsZW1lbnQoKSAmJiB0aGlzLmJsdXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ibHVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZGVsZWdhdGVUeXBlOiBcImZvY3Vzb3V0XCJcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY2xpY2s6IHtcclxuICAgICAgICAgICAgICAgIC8vIEZvciBjaGVja2JveCwgZmlyZSBuYXRpdmUgZXZlbnQgc28gY2hlY2tlZCBzdGF0ZSB3aWxsIGJlIHJpZ2h0XHJcbiAgICAgICAgICAgICAgICB0cmlnZ2VyOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSBcImNoZWNrYm94XCIgJiYgdGhpcy5jbGljayAmJiBqUXVlcnkubm9kZU5hbWUodGhpcywgXCJpbnB1dFwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNsaWNrKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIC8vIEZvciBjcm9zcy1icm93c2VyIGNvbnNpc3RlbmN5LCBkb24ndCBmaXJlIG5hdGl2ZSAuY2xpY2soKSBvbiBsaW5rc1xyXG4gICAgICAgICAgICAgICAgX2RlZmF1bHQ6IGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5ub2RlTmFtZShldmVudC50YXJnZXQsIFwiYVwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIGJlZm9yZXVubG9hZDoge1xyXG4gICAgICAgICAgICAgICAgcG9zdERpc3BhdGNoOiBmdW5jdGlvbihldmVudCkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBGaXJlZm94IDIwK1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpcmVmb3ggZG9lc24ndCBhbGVydCBpZiB0aGUgcmV0dXJuVmFsdWUgZmllbGQgaXMgbm90IHNldC5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQucmVzdWx0ICE9PSB1bmRlZmluZWQgJiYgZXZlbnQub3JpZ2luYWxFdmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5vcmlnaW5hbEV2ZW50LnJldHVyblZhbHVlID0gZXZlbnQucmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNpbXVsYXRlOiBmdW5jdGlvbih0eXBlLCBlbGVtLCBldmVudCwgYnViYmxlKSB7XHJcbiAgICAgICAgICAgIC8vIFBpZ2d5YmFjayBvbiBhIGRvbm9yIGV2ZW50IHRvIHNpbXVsYXRlIGEgZGlmZmVyZW50IG9uZS5cclxuICAgICAgICAgICAgLy8gRmFrZSBvcmlnaW5hbEV2ZW50IHRvIGF2b2lkIGRvbm9yJ3Mgc3RvcFByb3BhZ2F0aW9uLCBidXQgaWYgdGhlXHJcbiAgICAgICAgICAgIC8vIHNpbXVsYXRlZCBldmVudCBwcmV2ZW50cyBkZWZhdWx0IHRoZW4gd2UgZG8gdGhlIHNhbWUgb24gdGhlIGRvbm9yLlxyXG4gICAgICAgICAgICB2YXIgZSA9IGpRdWVyeS5leHRlbmQoXHJcbiAgICAgICAgICAgICAgICBuZXcgalF1ZXJ5LkV2ZW50KCksXHJcbiAgICAgICAgICAgICAgICBldmVudCwge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgaXNTaW11bGF0ZWQ6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDoge31cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgaWYgKGJ1YmJsZSkge1xyXG4gICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LnRyaWdnZXIoZSwgbnVsbCwgZWxlbSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQuZGlzcGF0Y2guY2FsbChlbGVtLCBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgalF1ZXJ5LnJlbW92ZUV2ZW50ID0gZnVuY3Rpb24oZWxlbSwgdHlwZSwgaGFuZGxlKSB7XHJcbiAgICAgICAgaWYgKGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xyXG4gICAgICAgICAgICBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlLCBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBqUXVlcnkuRXZlbnQgPSBmdW5jdGlvbihzcmMsIHByb3BzKSB7XHJcbiAgICAgICAgLy8gQWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IHRoZSAnbmV3JyBrZXl3b3JkXHJcbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIGpRdWVyeS5FdmVudCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBqUXVlcnkuRXZlbnQoc3JjLCBwcm9wcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBFdmVudCBvYmplY3RcclxuICAgICAgICBpZiAoc3JjICYmIHNyYy50eXBlKSB7XHJcbiAgICAgICAgICAgIHRoaXMub3JpZ2luYWxFdmVudCA9IHNyYztcclxuICAgICAgICAgICAgdGhpcy50eXBlID0gc3JjLnR5cGU7XHJcblxyXG4gICAgICAgICAgICAvLyBFdmVudHMgYnViYmxpbmcgdXAgdGhlIGRvY3VtZW50IG1heSBoYXZlIGJlZW4gbWFya2VkIGFzIHByZXZlbnRlZFxyXG4gICAgICAgICAgICAvLyBieSBhIGhhbmRsZXIgbG93ZXIgZG93biB0aGUgdHJlZTsgcmVmbGVjdCB0aGUgY29ycmVjdCB2YWx1ZS5cclxuICAgICAgICAgICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBzcmMuZGVmYXVsdFByZXZlbnRlZCB8fFxyXG4gICAgICAgICAgICAgICAgc3JjLmRlZmF1bHRQcmV2ZW50ZWQgPT09IHVuZGVmaW5lZCAmJlxyXG4gICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogQW5kcm9pZCA8IDQuMFxyXG4gICAgICAgICAgICAgICAgc3JjLnJldHVyblZhbHVlID09PSBmYWxzZSA/XHJcbiAgICAgICAgICAgICAgICByZXR1cm5UcnVlIDpcclxuICAgICAgICAgICAgICAgIHJldHVybkZhbHNlO1xyXG5cclxuICAgICAgICAgICAgLy8gRXZlbnQgdHlwZVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IHNyYztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFB1dCBleHBsaWNpdGx5IHByb3ZpZGVkIHByb3BlcnRpZXMgb250byB0aGUgZXZlbnQgb2JqZWN0XHJcbiAgICAgICAgaWYgKHByb3BzKSB7XHJcbiAgICAgICAgICAgIGpRdWVyeS5leHRlbmQodGhpcywgcHJvcHMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ3JlYXRlIGEgdGltZXN0YW1wIGlmIGluY29taW5nIGV2ZW50IGRvZXNuJ3QgaGF2ZSBvbmVcclxuICAgICAgICB0aGlzLnRpbWVTdGFtcCA9IHNyYyAmJiBzcmMudGltZVN0YW1wIHx8IGpRdWVyeS5ub3coKTtcclxuXHJcbiAgICAgICAgLy8gTWFyayBpdCBhcyBmaXhlZFxyXG4gICAgICAgIHRoaXNbalF1ZXJ5LmV4cGFuZG9dID0gdHJ1ZTtcclxuICAgIH07XHJcblxyXG4gICAgLy8galF1ZXJ5LkV2ZW50IGlzIGJhc2VkIG9uIERPTTMgRXZlbnRzIGFzIHNwZWNpZmllZCBieSB0aGUgRUNNQVNjcmlwdCBMYW5ndWFnZSBCaW5kaW5nXHJcbiAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDAzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDAzMDMzMS9lY21hLXNjcmlwdC1iaW5kaW5nLmh0bWxcclxuICAgIGpRdWVyeS5FdmVudC5wcm90b3R5cGUgPSB7XHJcbiAgICAgICAgaXNEZWZhdWx0UHJldmVudGVkOiByZXR1cm5GYWxzZSxcclxuICAgICAgICBpc1Byb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXHJcbiAgICAgICAgaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxyXG5cclxuICAgICAgICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xyXG5cclxuICAgICAgICAgICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSByZXR1cm5UcnVlO1xyXG5cclxuICAgICAgICAgICAgaWYgKGUgJiYgZS5wcmV2ZW50RGVmYXVsdCkge1xyXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xyXG5cclxuICAgICAgICAgICAgaWYgKGUgJiYgZS5zdG9wUHJvcGFnYXRpb24pIHtcclxuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xyXG5cclxuICAgICAgICAgICAgdGhpcy5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XHJcblxyXG4gICAgICAgICAgICBpZiAoZSAmJiBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIENyZWF0ZSBtb3VzZWVudGVyL2xlYXZlIGV2ZW50cyB1c2luZyBtb3VzZW92ZXIvb3V0IGFuZCBldmVudC10aW1lIGNoZWNrc1xyXG4gICAgLy8gU3VwcG9ydDogQ2hyb21lIDE1K1xyXG4gICAgalF1ZXJ5LmVhY2goe1xyXG4gICAgICAgIG1vdXNlZW50ZXI6IFwibW91c2VvdmVyXCIsXHJcbiAgICAgICAgbW91c2VsZWF2ZTogXCJtb3VzZW91dFwiLFxyXG4gICAgICAgIHBvaW50ZXJlbnRlcjogXCJwb2ludGVyb3ZlclwiLFxyXG4gICAgICAgIHBvaW50ZXJsZWF2ZTogXCJwb2ludGVyb3V0XCJcclxuICAgIH0sIGZ1bmN0aW9uKG9yaWcsIGZpeCkge1xyXG4gICAgICAgIGpRdWVyeS5ldmVudC5zcGVjaWFsW29yaWddID0ge1xyXG4gICAgICAgICAgICBkZWxlZ2F0ZVR5cGU6IGZpeCxcclxuICAgICAgICAgICAgYmluZFR5cGU6IGZpeCxcclxuXHJcbiAgICAgICAgICAgIGhhbmRsZTogZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gdGhpcyxcclxuICAgICAgICAgICAgICAgICAgICByZWxhdGVkID0gZXZlbnQucmVsYXRlZFRhcmdldCxcclxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVPYmogPSBldmVudC5oYW5kbGVPYmo7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRm9yIG1vdXNlbnRlci9sZWF2ZSBjYWxsIHRoZSBoYW5kbGVyIGlmIHJlbGF0ZWQgaXMgb3V0c2lkZSB0aGUgdGFyZ2V0LlxyXG4gICAgICAgICAgICAgICAgLy8gTkI6IE5vIHJlbGF0ZWRUYXJnZXQgaWYgdGhlIG1vdXNlIGxlZnQvZW50ZXJlZCB0aGUgYnJvd3NlciB3aW5kb3dcclxuICAgICAgICAgICAgICAgIGlmICghcmVsYXRlZCB8fCAocmVsYXRlZCAhPT0gdGFyZ2V0ICYmICFqUXVlcnkuY29udGFpbnModGFyZ2V0LCByZWxhdGVkKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBldmVudC50eXBlID0gaGFuZGxlT2JqLm9yaWdUeXBlO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldCA9IGhhbmRsZU9iai5oYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQudHlwZSA9IGZpeDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gQ3JlYXRlIFwiYnViYmxpbmdcIiBmb2N1cyBhbmQgYmx1ciBldmVudHNcclxuICAgIC8vIFN1cHBvcnQ6IEZpcmVmb3gsIENocm9tZSwgU2FmYXJpXHJcbiAgICBpZiAoIXN1cHBvcnQuZm9jdXNpbkJ1YmJsZXMpIHtcclxuICAgICAgICBqUXVlcnkuZWFjaCh7IGZvY3VzOiBcImZvY3VzaW5cIiwgYmx1cjogXCJmb2N1c291dFwiIH0sIGZ1bmN0aW9uKG9yaWcsIGZpeCkge1xyXG5cclxuICAgICAgICAgICAgLy8gQXR0YWNoIGEgc2luZ2xlIGNhcHR1cmluZyBoYW5kbGVyIG9uIHRoZSBkb2N1bWVudCB3aGlsZSBzb21lb25lIHdhbnRzIGZvY3VzaW4vZm9jdXNvdXRcclxuICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbihldmVudCkge1xyXG4gICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LnNpbXVsYXRlKGZpeCwgZXZlbnQudGFyZ2V0LCBqUXVlcnkuZXZlbnQuZml4KGV2ZW50KSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBqUXVlcnkuZXZlbnQuc3BlY2lhbFtmaXhdID0ge1xyXG4gICAgICAgICAgICAgICAgc2V0dXA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0YWNoZXMgPSBkYXRhX3ByaXYuYWNjZXNzKGRvYywgZml4KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhdHRhY2hlcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcihvcmlnLCBoYW5kbGVyLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YV9wcml2LmFjY2Vzcyhkb2MsIGZpeCwgKGF0dGFjaGVzIHx8IDApICsgMSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgdGVhcmRvd246IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0YWNoZXMgPSBkYXRhX3ByaXYuYWNjZXNzKGRvYywgZml4KSAtIDE7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghYXR0YWNoZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIob3JpZywgaGFuZGxlciwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFfcHJpdi5yZW1vdmUoZG9jLCBmaXgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhX3ByaXYuYWNjZXNzKGRvYywgZml4LCBhdHRhY2hlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGpRdWVyeS5mbi5leHRlbmQoe1xyXG5cclxuICAgICAgICBvbjogZnVuY3Rpb24odHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgLypJTlRFUk5BTCovIG9uZSkge1xyXG4gICAgICAgICAgICB2YXIgb3JpZ0ZuLCB0eXBlO1xyXG5cclxuICAgICAgICAgICAgLy8gVHlwZXMgY2FuIGJlIGEgbWFwIG9mIHR5cGVzL2hhbmRsZXJzXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdHlwZXMgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICAgICAgICAgIC8vICggdHlwZXMtT2JqZWN0LCBzZWxlY3RvciwgZGF0YSApXHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gKCB0eXBlcy1PYmplY3QsIGRhdGEgKVxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhIHx8IHNlbGVjdG9yO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZm9yICh0eXBlIGluIHR5cGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbih0eXBlLCBzZWxlY3RvciwgZGF0YSwgdHlwZXNbdHlwZV0sIG9uZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGRhdGEgPT0gbnVsbCAmJiBmbiA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAvLyAoIHR5cGVzLCBmbiApXHJcbiAgICAgICAgICAgICAgICBmbiA9IHNlbGVjdG9yO1xyXG4gICAgICAgICAgICAgICAgZGF0YSA9IHNlbGVjdG9yID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZuID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyAoIHR5cGVzLCBzZWxlY3RvciwgZm4gKVxyXG4gICAgICAgICAgICAgICAgICAgIGZuID0gZGF0YTtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyAoIHR5cGVzLCBkYXRhLCBmbiApXHJcbiAgICAgICAgICAgICAgICAgICAgZm4gPSBkYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBzZWxlY3RvcjtcclxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvciA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZm4gPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICBmbiA9IHJldHVybkZhbHNlO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFmbikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChvbmUgPT09IDEpIHtcclxuICAgICAgICAgICAgICAgIG9yaWdGbiA9IGZuO1xyXG4gICAgICAgICAgICAgICAgZm4gPSBmdW5jdGlvbihldmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIENhbiB1c2UgYW4gZW1wdHkgc2V0LCBzaW5jZSBldmVudCBjb250YWlucyB0aGUgaW5mb1xyXG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeSgpLm9mZihldmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdGbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8vIFVzZSBzYW1lIGd1aWQgc28gY2FsbGVyIGNhbiByZW1vdmUgdXNpbmcgb3JpZ0ZuXHJcbiAgICAgICAgICAgICAgICBmbi5ndWlkID0gb3JpZ0ZuLmd1aWQgfHwgKG9yaWdGbi5ndWlkID0galF1ZXJ5Lmd1aWQrKyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC5hZGQodGhpcywgdHlwZXMsIGZuLCBkYXRhLCBzZWxlY3Rvcik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25lOiBmdW5jdGlvbih0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9uKHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIDEpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb2ZmOiBmdW5jdGlvbih0eXBlcywgc2VsZWN0b3IsIGZuKSB7XHJcbiAgICAgICAgICAgIHZhciBoYW5kbGVPYmosIHR5cGU7XHJcbiAgICAgICAgICAgIGlmICh0eXBlcyAmJiB0eXBlcy5wcmV2ZW50RGVmYXVsdCAmJiB0eXBlcy5oYW5kbGVPYmopIHtcclxuICAgICAgICAgICAgICAgIC8vICggZXZlbnQgKSAgZGlzcGF0Y2hlZCBqUXVlcnkuRXZlbnRcclxuICAgICAgICAgICAgICAgIGhhbmRsZU9iaiA9IHR5cGVzLmhhbmRsZU9iajtcclxuICAgICAgICAgICAgICAgIGpRdWVyeSh0eXBlcy5kZWxlZ2F0ZVRhcmdldCkub2ZmKFxyXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZU9iai5uYW1lc3BhY2UgPyBoYW5kbGVPYmoub3JpZ1R5cGUgKyBcIi5cIiArIGhhbmRsZU9iai5uYW1lc3BhY2UgOiBoYW5kbGVPYmoub3JpZ1R5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlT2JqLnNlbGVjdG9yLFxyXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZU9iai5oYW5kbGVyXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgICAgICAgICAgLy8gKCB0eXBlcy1vYmplY3QgWywgc2VsZWN0b3JdIClcclxuICAgICAgICAgICAgICAgIGZvciAodHlwZSBpbiB0eXBlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2ZmKHR5cGUsIHNlbGVjdG9yLCB0eXBlc1t0eXBlXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoc2VsZWN0b3IgPT09IGZhbHNlIHx8IHR5cGVvZiBzZWxlY3RvciA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICAvLyAoIHR5cGVzIFssIGZuXSApXHJcbiAgICAgICAgICAgICAgICBmbiA9IHNlbGVjdG9yO1xyXG4gICAgICAgICAgICAgICAgc2VsZWN0b3IgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGZuID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgZm4gPSByZXR1cm5GYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LnJlbW92ZSh0aGlzLCB0eXBlcywgZm4sIHNlbGVjdG9yKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgdHJpZ2dlcjogZnVuY3Rpb24odHlwZSwgZGF0YSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgalF1ZXJ5LmV2ZW50LnRyaWdnZXIodHlwZSwgZGF0YSwgdGhpcyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdHJpZ2dlckhhbmRsZXI6IGZ1bmN0aW9uKHR5cGUsIGRhdGEpIHtcclxuICAgICAgICAgICAgdmFyIGVsZW0gPSB0aGlzWzBdO1xyXG4gICAgICAgICAgICBpZiAoZWxlbSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5ldmVudC50cmlnZ2VyKHR5cGUsIGRhdGEsIGVsZW0sIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG5cclxuICAgIHZhclxyXG4gICAgICAgIHJ4aHRtbFRhZyA9IC88KD8hYXJlYXxicnxjb2x8ZW1iZWR8aHJ8aW1nfGlucHV0fGxpbmt8bWV0YXxwYXJhbSkoKFtcXHc6XSspW14+XSopXFwvPi9naSxcclxuICAgICAgICBydGFnTmFtZSA9IC88KFtcXHc6XSspLyxcclxuICAgICAgICByaHRtbCA9IC88fCYjP1xcdys7LyxcclxuICAgICAgICBybm9Jbm5lcmh0bWwgPSAvPCg/OnNjcmlwdHxzdHlsZXxsaW5rKS9pLFxyXG4gICAgICAgIC8vIGNoZWNrZWQ9XCJjaGVja2VkXCIgb3IgY2hlY2tlZFxyXG4gICAgICAgIHJjaGVja2VkID0gL2NoZWNrZWRcXHMqKD86W149XXw9XFxzKi5jaGVja2VkLikvaSxcclxuICAgICAgICByc2NyaXB0VHlwZSA9IC9eJHxcXC8oPzpqYXZhfGVjbWEpc2NyaXB0L2ksXHJcbiAgICAgICAgcnNjcmlwdFR5cGVNYXNrZWQgPSAvXnRydWVcXC8oLiopLyxcclxuICAgICAgICByY2xlYW5TY3JpcHQgPSAvXlxccyo8ISg/OlxcW0NEQVRBXFxbfC0tKXwoPzpcXF1cXF18LS0pPlxccyokL2csXHJcblxyXG4gICAgICAgIC8vIFdlIGhhdmUgdG8gY2xvc2UgdGhlc2UgdGFncyB0byBzdXBwb3J0IFhIVE1MICgjMTMyMDApXHJcbiAgICAgICAgd3JhcE1hcCA9IHtcclxuXHJcbiAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFIDlcclxuICAgICAgICAgICAgb3B0aW9uOiBbMSwgXCI8c2VsZWN0IG11bHRpcGxlPSdtdWx0aXBsZSc+XCIsIFwiPC9zZWxlY3Q+XCJdLFxyXG5cclxuICAgICAgICAgICAgdGhlYWQ6IFsxLCBcIjx0YWJsZT5cIiwgXCI8L3RhYmxlPlwiXSxcclxuICAgICAgICAgICAgY29sOiBbMiwgXCI8dGFibGU+PGNvbGdyb3VwPlwiLCBcIjwvY29sZ3JvdXA+PC90YWJsZT5cIl0sXHJcbiAgICAgICAgICAgIHRyOiBbMiwgXCI8dGFibGU+PHRib2R5PlwiLCBcIjwvdGJvZHk+PC90YWJsZT5cIl0sXHJcbiAgICAgICAgICAgIHRkOiBbMywgXCI8dGFibGU+PHRib2R5Pjx0cj5cIiwgXCI8L3RyPjwvdGJvZHk+PC90YWJsZT5cIl0sXHJcblxyXG4gICAgICAgICAgICBfZGVmYXVsdDogWzAsIFwiXCIsIFwiXCJdXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAvLyBTdXBwb3J0OiBJRSA5XHJcbiAgICB3cmFwTWFwLm9wdGdyb3VwID0gd3JhcE1hcC5vcHRpb247XHJcblxyXG4gICAgd3JhcE1hcC50Ym9keSA9IHdyYXBNYXAudGZvb3QgPSB3cmFwTWFwLmNvbGdyb3VwID0gd3JhcE1hcC5jYXB0aW9uID0gd3JhcE1hcC50aGVhZDtcclxuICAgIHdyYXBNYXAudGggPSB3cmFwTWFwLnRkO1xyXG5cclxuICAgIC8vIFN1cHBvcnQ6IDEueCBjb21wYXRpYmlsaXR5XHJcbiAgICAvLyBNYW5pcHVsYXRpbmcgdGFibGVzIHJlcXVpcmVzIGEgdGJvZHlcclxuICAgIGZ1bmN0aW9uIG1hbmlwdWxhdGlvblRhcmdldChlbGVtLCBjb250ZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIGpRdWVyeS5ub2RlTmFtZShlbGVtLCBcInRhYmxlXCIpICYmXHJcbiAgICAgICAgICAgIGpRdWVyeS5ub2RlTmFtZShjb250ZW50Lm5vZGVUeXBlICE9PSAxMSA/IGNvbnRlbnQgOiBjb250ZW50LmZpcnN0Q2hpbGQsIFwidHJcIikgP1xyXG5cclxuICAgICAgICAgICAgZWxlbS5nZXRFbGVtZW50c0J5VGFnTmFtZShcInRib2R5XCIpWzBdIHx8XHJcbiAgICAgICAgICAgIGVsZW0uYXBwZW5kQ2hpbGQoZWxlbS5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0Ym9keVwiKSkgOlxyXG4gICAgICAgICAgICBlbGVtO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlcGxhY2UvcmVzdG9yZSB0aGUgdHlwZSBhdHRyaWJ1dGUgb2Ygc2NyaXB0IGVsZW1lbnRzIGZvciBzYWZlIERPTSBtYW5pcHVsYXRpb25cclxuICAgIGZ1bmN0aW9uIGRpc2FibGVTY3JpcHQoZWxlbSkge1xyXG4gICAgICAgIGVsZW0udHlwZSA9IChlbGVtLmdldEF0dHJpYnV0ZShcInR5cGVcIikgIT09IG51bGwpICsgXCIvXCIgKyBlbGVtLnR5cGU7XHJcbiAgICAgICAgcmV0dXJuIGVsZW07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcmVzdG9yZVNjcmlwdChlbGVtKSB7XHJcbiAgICAgICAgdmFyIG1hdGNoID0gcnNjcmlwdFR5cGVNYXNrZWQuZXhlYyhlbGVtLnR5cGUpO1xyXG5cclxuICAgICAgICBpZiAobWF0Y2gpIHtcclxuICAgICAgICAgICAgZWxlbS50eXBlID0gbWF0Y2hbMV07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZWxlbS5yZW1vdmVBdHRyaWJ1dGUoXCJ0eXBlXCIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGVsZW07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTWFyayBzY3JpcHRzIGFzIGhhdmluZyBhbHJlYWR5IGJlZW4gZXZhbHVhdGVkXHJcbiAgICBmdW5jdGlvbiBzZXRHbG9iYWxFdmFsKGVsZW1zLCByZWZFbGVtZW50cykge1xyXG4gICAgICAgIHZhciBpID0gMCxcclxuICAgICAgICAgICAgbCA9IGVsZW1zLmxlbmd0aDtcclxuXHJcbiAgICAgICAgZm9yICg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgZGF0YV9wcml2LnNldChcclxuICAgICAgICAgICAgICAgIGVsZW1zW2ldLCBcImdsb2JhbEV2YWxcIiwgIXJlZkVsZW1lbnRzIHx8IGRhdGFfcHJpdi5nZXQocmVmRWxlbWVudHNbaV0sIFwiZ2xvYmFsRXZhbFwiKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjbG9uZUNvcHlFdmVudChzcmMsIGRlc3QpIHtcclxuICAgICAgICB2YXIgaSwgbCwgdHlwZSwgcGRhdGFPbGQsIHBkYXRhQ3VyLCB1ZGF0YU9sZCwgdWRhdGFDdXIsIGV2ZW50cztcclxuXHJcbiAgICAgICAgaWYgKGRlc3Qubm9kZVR5cGUgIT09IDEpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gMS4gQ29weSBwcml2YXRlIGRhdGE6IGV2ZW50cywgaGFuZGxlcnMsIGV0Yy5cclxuICAgICAgICBpZiAoZGF0YV9wcml2Lmhhc0RhdGEoc3JjKSkge1xyXG4gICAgICAgICAgICBwZGF0YU9sZCA9IGRhdGFfcHJpdi5hY2Nlc3Moc3JjKTtcclxuICAgICAgICAgICAgcGRhdGFDdXIgPSBkYXRhX3ByaXYuc2V0KGRlc3QsIHBkYXRhT2xkKTtcclxuICAgICAgICAgICAgZXZlbnRzID0gcGRhdGFPbGQuZXZlbnRzO1xyXG5cclxuICAgICAgICAgICAgaWYgKGV2ZW50cykge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHBkYXRhQ3VyLmhhbmRsZTtcclxuICAgICAgICAgICAgICAgIHBkYXRhQ3VyLmV2ZW50cyA9IHt9O1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAodHlwZSBpbiBldmVudHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gZXZlbnRzW3R5cGVdLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQuYWRkKGRlc3QsIHR5cGUsIGV2ZW50c1t0eXBlXVtpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAyLiBDb3B5IHVzZXIgZGF0YVxyXG4gICAgICAgIGlmIChkYXRhX3VzZXIuaGFzRGF0YShzcmMpKSB7XHJcbiAgICAgICAgICAgIHVkYXRhT2xkID0gZGF0YV91c2VyLmFjY2VzcyhzcmMpO1xyXG4gICAgICAgICAgICB1ZGF0YUN1ciA9IGpRdWVyeS5leHRlbmQoe30sIHVkYXRhT2xkKTtcclxuXHJcbiAgICAgICAgICAgIGRhdGFfdXNlci5zZXQoZGVzdCwgdWRhdGFDdXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRBbGwoY29udGV4dCwgdGFnKSB7XHJcbiAgICAgICAgdmFyIHJldCA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgPyBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKHRhZyB8fCBcIipcIikgOlxyXG4gICAgICAgICAgICBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwgPyBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwodGFnIHx8IFwiKlwiKSA6IFtdO1xyXG5cclxuICAgICAgICByZXR1cm4gdGFnID09PSB1bmRlZmluZWQgfHwgdGFnICYmIGpRdWVyeS5ub2RlTmFtZShjb250ZXh0LCB0YWcpID9cclxuICAgICAgICAgICAgalF1ZXJ5Lm1lcmdlKFtjb250ZXh0XSwgcmV0KSA6XHJcbiAgICAgICAgICAgIHJldDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTdXBwb3J0OiBJRSA+PSA5XHJcbiAgICBmdW5jdGlvbiBmaXhJbnB1dChzcmMsIGRlc3QpIHtcclxuICAgICAgICB2YXIgbm9kZU5hbWUgPSBkZXN0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XHJcblxyXG4gICAgICAgIC8vIEZhaWxzIHRvIHBlcnNpc3QgdGhlIGNoZWNrZWQgc3RhdGUgb2YgYSBjbG9uZWQgY2hlY2tib3ggb3IgcmFkaW8gYnV0dG9uLlxyXG4gICAgICAgIGlmIChub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmIHJjaGVja2FibGVUeXBlLnRlc3Qoc3JjLnR5cGUpKSB7XHJcbiAgICAgICAgICAgIGRlc3QuY2hlY2tlZCA9IHNyYy5jaGVja2VkO1xyXG5cclxuICAgICAgICAgICAgLy8gRmFpbHMgdG8gcmV0dXJuIHRoZSBzZWxlY3RlZCBvcHRpb24gdG8gdGhlIGRlZmF1bHQgc2VsZWN0ZWQgc3RhdGUgd2hlbiBjbG9uaW5nIG9wdGlvbnNcclxuICAgICAgICB9IGVsc2UgaWYgKG5vZGVOYW1lID09PSBcImlucHV0XCIgfHwgbm9kZU5hbWUgPT09IFwidGV4dGFyZWFcIikge1xyXG4gICAgICAgICAgICBkZXN0LmRlZmF1bHRWYWx1ZSA9IHNyYy5kZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGpRdWVyeS5leHRlbmQoe1xyXG4gICAgICAgIGNsb25lOiBmdW5jdGlvbihlbGVtLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cykge1xyXG4gICAgICAgICAgICB2YXIgaSwgbCwgc3JjRWxlbWVudHMsIGRlc3RFbGVtZW50cyxcclxuICAgICAgICAgICAgICAgIGNsb25lID0gZWxlbS5jbG9uZU5vZGUodHJ1ZSksXHJcbiAgICAgICAgICAgICAgICBpblBhZ2UgPSBqUXVlcnkuY29udGFpbnMoZWxlbS5vd25lckRvY3VtZW50LCBlbGVtKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFID49IDlcclxuICAgICAgICAgICAgLy8gRml4IENsb25pbmcgaXNzdWVzXHJcbiAgICAgICAgICAgIGlmICghc3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCAmJiAoZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBlbGVtLm5vZGVUeXBlID09PSAxMSkgJiZcclxuICAgICAgICAgICAgICAgICFqUXVlcnkuaXNYTUxEb2MoZWxlbSkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBXZSBlc2NoZXcgU2l6emxlIGhlcmUgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnM6IGh0dHA6Ly9qc3BlcmYuY29tL2dldGFsbC12cy1zaXp6bGUvMlxyXG4gICAgICAgICAgICAgICAgZGVzdEVsZW1lbnRzID0gZ2V0QWxsKGNsb25lKTtcclxuICAgICAgICAgICAgICAgIHNyY0VsZW1lbnRzID0gZ2V0QWxsKGVsZW0pO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBzcmNFbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBmaXhJbnB1dChzcmNFbGVtZW50c1tpXSwgZGVzdEVsZW1lbnRzW2ldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQ29weSB0aGUgZXZlbnRzIGZyb20gdGhlIG9yaWdpbmFsIHRvIHRoZSBjbG9uZVxyXG4gICAgICAgICAgICBpZiAoZGF0YUFuZEV2ZW50cykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGRlZXBEYXRhQW5kRXZlbnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3JjRWxlbWVudHMgPSBzcmNFbGVtZW50cyB8fCBnZXRBbGwoZWxlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVzdEVsZW1lbnRzID0gZGVzdEVsZW1lbnRzIHx8IGdldEFsbChjbG9uZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBzcmNFbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmVDb3B5RXZlbnQoc3JjRWxlbWVudHNbaV0sIGRlc3RFbGVtZW50c1tpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjbG9uZUNvcHlFdmVudChlbGVtLCBjbG9uZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3RvcnlcclxuICAgICAgICAgICAgZGVzdEVsZW1lbnRzID0gZ2V0QWxsKGNsb25lLCBcInNjcmlwdFwiKTtcclxuICAgICAgICAgICAgaWYgKGRlc3RFbGVtZW50cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRHbG9iYWxFdmFsKGRlc3RFbGVtZW50cywgIWluUGFnZSAmJiBnZXRBbGwoZWxlbSwgXCJzY3JpcHRcIikpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBSZXR1cm4gdGhlIGNsb25lZCBzZXRcclxuICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGJ1aWxkRnJhZ21lbnQ6IGZ1bmN0aW9uKGVsZW1zLCBjb250ZXh0LCBzY3JpcHRzLCBzZWxlY3Rpb24pIHtcclxuICAgICAgICAgICAgdmFyIGVsZW0sIHRtcCwgdGFnLCB3cmFwLCBjb250YWlucywgaixcclxuICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gY29udGV4dC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXHJcbiAgICAgICAgICAgICAgICBub2RlcyA9IFtdLFxyXG4gICAgICAgICAgICAgICAgaSA9IDAsXHJcbiAgICAgICAgICAgICAgICBsID0gZWxlbXMubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgZm9yICg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGVsZW0gPSBlbGVtc1tpXTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZWxlbSB8fCBlbGVtID09PSAwKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCBub2RlcyBkaXJlY3RseVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChqUXVlcnkudHlwZShlbGVtKSA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBRdFdlYktpdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBqUXVlcnkubWVyZ2UgYmVjYXVzZSBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5tZXJnZShub2RlcywgZWxlbS5ub2RlVHlwZSA/IFtlbGVtXSA6IGVsZW0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29udmVydCBub24taHRtbCBpbnRvIGEgdGV4dCBub2RlXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICghcmh0bWwudGVzdChlbGVtKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKGNvbnRleHQuY3JlYXRlVGV4dE5vZGUoZWxlbSkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29udmVydCBodG1sIGludG8gRE9NIG5vZGVzXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG1wID0gdG1wIHx8IGZyYWdtZW50LmFwcGVuZENoaWxkKGNvbnRleHQuY3JlYXRlRWxlbWVudChcImRpdlwiKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEZXNlcmlhbGl6ZSBhIHN0YW5kYXJkIHJlcHJlc2VudGF0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZyA9IChydGFnTmFtZS5leGVjKGVsZW0pIHx8IFtcIlwiLCBcIlwiXSlbMV0udG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd3JhcCA9IHdyYXBNYXBbdGFnXSB8fCB3cmFwTWFwLl9kZWZhdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0bXAuaW5uZXJIVE1MID0gd3JhcFsxXSArIGVsZW0ucmVwbGFjZShyeGh0bWxUYWcsIFwiPCQxPjwvJDI+XCIpICsgd3JhcFsyXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlc2NlbmQgdGhyb3VnaCB3cmFwcGVycyB0byB0aGUgcmlnaHQgY29udGVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBqID0gd3JhcFswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGotLSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wID0gdG1wLmxhc3RDaGlsZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogUXRXZWJLaXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8galF1ZXJ5Lm1lcmdlIGJlY2F1c2UgcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkubWVyZ2Uobm9kZXMsIHRtcC5jaGlsZE5vZGVzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlbWVtYmVyIHRoZSB0b3AtbGV2ZWwgY29udGFpbmVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRtcCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGaXhlcyAjMTIzNDZcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogV2Via2l0LCBJRVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0bXAudGV4dENvbnRlbnQgPSBcIlwiO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gUmVtb3ZlIHdyYXBwZXIgZnJvbSBmcmFnbWVudFxyXG4gICAgICAgICAgICBmcmFnbWVudC50ZXh0Q29udGVudCA9IFwiXCI7XHJcblxyXG4gICAgICAgICAgICBpID0gMDtcclxuICAgICAgICAgICAgd2hpbGUgKChlbGVtID0gbm9kZXNbaSsrXSkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyAjNDA4NyAtIElmIG9yaWdpbiBhbmQgZGVzdGluYXRpb24gZWxlbWVudHMgYXJlIHRoZSBzYW1lLCBhbmQgdGhpcyBpc1xyXG4gICAgICAgICAgICAgICAgLy8gdGhhdCBlbGVtZW50LCBkbyBub3QgZG8gYW55dGhpbmdcclxuICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb24gJiYgalF1ZXJ5LmluQXJyYXkoZWxlbSwgc2VsZWN0aW9uKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBjb250YWlucyA9IGpRdWVyeS5jb250YWlucyhlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0pO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEFwcGVuZCB0byBmcmFnbWVudFxyXG4gICAgICAgICAgICAgICAgdG1wID0gZ2V0QWxsKGZyYWdtZW50LmFwcGVuZENoaWxkKGVsZW0pLCBcInNjcmlwdFwiKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBQcmVzZXJ2ZSBzY3JpcHQgZXZhbHVhdGlvbiBoaXN0b3J5XHJcbiAgICAgICAgICAgICAgICBpZiAoY29udGFpbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXRHbG9iYWxFdmFsKHRtcCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ2FwdHVyZSBleGVjdXRhYmxlc1xyXG4gICAgICAgICAgICAgICAgaWYgKHNjcmlwdHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBqID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKGVsZW0gPSB0bXBbaisrXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJzY3JpcHRUeXBlLnRlc3QoZWxlbS50eXBlIHx8IFwiXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JpcHRzLnB1c2goZWxlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBmcmFnbWVudDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBjbGVhbkRhdGE6IGZ1bmN0aW9uKGVsZW1zKSB7XHJcbiAgICAgICAgICAgIHZhciBkYXRhLCBlbGVtLCB0eXBlLCBrZXksXHJcbiAgICAgICAgICAgICAgICBzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWwsXHJcbiAgICAgICAgICAgICAgICBpID0gMDtcclxuXHJcbiAgICAgICAgICAgIGZvciAoO1xyXG4gICAgICAgICAgICAgICAgKGVsZW0gPSBlbGVtc1tpXSkgIT09IHVuZGVmaW5lZDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoalF1ZXJ5LmFjY2VwdERhdGEoZWxlbSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBrZXkgPSBlbGVtW2RhdGFfcHJpdi5leHBhbmRvXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleSAmJiAoZGF0YSA9IGRhdGFfcHJpdi5jYWNoZVtrZXldKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5ldmVudHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodHlwZSBpbiBkYXRhLmV2ZW50cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzcGVjaWFsW3R5cGVdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC5yZW1vdmUoZWxlbSwgdHlwZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgc2hvcnRjdXQgdG8gYXZvaWQgalF1ZXJ5LmV2ZW50LnJlbW92ZSdzIG92ZXJoZWFkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LnJlbW92ZUV2ZW50KGVsZW0sIHR5cGUsIGRhdGEuaGFuZGxlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFfcHJpdi5jYWNoZVtrZXldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEaXNjYXJkIGFueSByZW1haW5pbmcgYHByaXZhdGVgIGRhdGFcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBkYXRhX3ByaXYuY2FjaGVba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIERpc2NhcmQgYW55IHJlbWFpbmluZyBgdXNlcmAgZGF0YVxyXG4gICAgICAgICAgICAgICAgZGVsZXRlIGRhdGFfdXNlci5jYWNoZVtlbGVtW2RhdGFfdXNlci5leHBhbmRvXV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBqUXVlcnkuZm4uZXh0ZW5kKHtcclxuICAgICAgICB0ZXh0OiBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYWNjZXNzKHRoaXMsIGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XHJcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LnRleHQodGhpcykgOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1wdHkoKS5lYWNoKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRleHRDb250ZW50ID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGgpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGFwcGVuZDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRvbU1hbmlwKGFyZ3VtZW50cywgZnVuY3Rpb24oZWxlbSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQodGhpcywgZWxlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LmFwcGVuZENoaWxkKGVsZW0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBwcmVwZW5kOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZG9tTWFuaXAoYXJndW1lbnRzLCBmdW5jdGlvbihlbGVtKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCh0aGlzLCBlbGVtKTtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQuaW5zZXJ0QmVmb3JlKGVsZW0sIHRhcmdldC5maXJzdENoaWxkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgYmVmb3JlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZG9tTWFuaXAoYXJndW1lbnRzLCBmdW5jdGlvbihlbGVtKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJlbnROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlbGVtLCB0aGlzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgYWZ0ZXI6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kb21NYW5pcChhcmd1bWVudHMsIGZ1bmN0aW9uKGVsZW0pIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudE5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsZW0sIHRoaXMubmV4dFNpYmxpbmcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uKHNlbGVjdG9yLCBrZWVwRGF0YSAvKiBJbnRlcm5hbCBVc2UgT25seSAqLyApIHtcclxuICAgICAgICAgICAgdmFyIGVsZW0sXHJcbiAgICAgICAgICAgICAgICBlbGVtcyA9IHNlbGVjdG9yID8galF1ZXJ5LmZpbHRlcihzZWxlY3RvciwgdGhpcykgOiB0aGlzLFxyXG4gICAgICAgICAgICAgICAgaSA9IDA7XHJcblxyXG4gICAgICAgICAgICBmb3IgKDtcclxuICAgICAgICAgICAgICAgIChlbGVtID0gZWxlbXNbaV0pICE9IG51bGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFrZWVwRGF0YSAmJiBlbGVtLm5vZGVUeXBlID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmNsZWFuRGF0YShnZXRBbGwoZWxlbSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChlbGVtLnBhcmVudE5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoa2VlcERhdGEgJiYgalF1ZXJ5LmNvbnRhaW5zKGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0R2xvYmFsRXZhbChnZXRBbGwoZWxlbSwgXCJzY3JpcHRcIikpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbGVtLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxlbSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGVtcHR5OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIGVsZW0sXHJcbiAgICAgICAgICAgICAgICBpID0gMDtcclxuXHJcbiAgICAgICAgICAgIGZvciAoO1xyXG4gICAgICAgICAgICAgICAgKGVsZW0gPSB0aGlzW2ldKSAhPSBudWxsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChlbGVtLm5vZGVUeXBlID09PSAxKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgbWVtb3J5IGxlYWtzXHJcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmNsZWFuRGF0YShnZXRBbGwoZWxlbSwgZmFsc2UpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGFueSByZW1haW5pbmcgbm9kZXNcclxuICAgICAgICAgICAgICAgICAgICBlbGVtLnRleHRDb250ZW50ID0gXCJcIjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgY2xvbmU6IGZ1bmN0aW9uKGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzKSB7XHJcbiAgICAgICAgICAgIGRhdGFBbmRFdmVudHMgPSBkYXRhQW5kRXZlbnRzID09IG51bGwgPyBmYWxzZSA6IGRhdGFBbmRFdmVudHM7XHJcbiAgICAgICAgICAgIGRlZXBEYXRhQW5kRXZlbnRzID0gZGVlcERhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGRhdGFBbmRFdmVudHMgOiBkZWVwRGF0YUFuZEV2ZW50cztcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBqUXVlcnkuY2xvbmUodGhpcywgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBodG1sOiBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYWNjZXNzKHRoaXMsIGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZWxlbSA9IHRoaXNbMF0gfHwge30sXHJcbiAgICAgICAgICAgICAgICAgICAgaSA9IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgbCA9IHRoaXMubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5pbm5lckhUTUw7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU2VlIGlmIHdlIGNhbiB0YWtlIGEgc2hvcnRjdXQgYW5kIGp1c3QgdXNlIGlubmVySFRNTFxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiAhcm5vSW5uZXJodG1sLnRlc3QodmFsdWUpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgIXdyYXBNYXBbKHJ0YWdOYW1lLmV4ZWModmFsdWUpIHx8IFtcIlwiLCBcIlwiXSlbMV0udG9Mb3dlckNhc2UoKV0pIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHJ4aHRtbFRhZywgXCI8JDE+PC8kMj5cIik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtID0gdGhpc1tpXSB8fCB7fTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgZWxlbWVudCBub2RlcyBhbmQgcHJldmVudCBtZW1vcnkgbGVha3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtLm5vZGVUeXBlID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmNsZWFuRGF0YShnZXRBbGwoZWxlbSwgZmFsc2UpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmlubmVySFRNTCA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHVzaW5nIGlubmVySFRNTCB0aHJvd3MgYW4gZXhjZXB0aW9uLCB1c2UgdGhlIGZhbGxiYWNrIG1ldGhvZFxyXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGVsZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtcHR5KCkuYXBwZW5kKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGgpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHJlcGxhY2VXaXRoOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIGFyZyA9IGFyZ3VtZW50c1swXTtcclxuXHJcbiAgICAgICAgICAgIC8vIE1ha2UgdGhlIGNoYW5nZXMsIHJlcGxhY2luZyBlYWNoIGNvbnRleHQgZWxlbWVudCB3aXRoIHRoZSBuZXcgY29udGVudFxyXG4gICAgICAgICAgICB0aGlzLmRvbU1hbmlwKGFyZ3VtZW50cywgZnVuY3Rpb24oZWxlbSkge1xyXG4gICAgICAgICAgICAgICAgYXJnID0gdGhpcy5wYXJlbnROb2RlO1xyXG5cclxuICAgICAgICAgICAgICAgIGpRdWVyeS5jbGVhbkRhdGEoZ2V0QWxsKHRoaXMpKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoYXJnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJnLnJlcGxhY2VDaGlsZChlbGVtLCB0aGlzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAvLyBGb3JjZSByZW1vdmFsIGlmIHRoZXJlIHdhcyBubyBuZXcgY29udGVudCAoZS5nLiwgZnJvbSBlbXB0eSBhcmd1bWVudHMpXHJcbiAgICAgICAgICAgIHJldHVybiBhcmcgJiYgKGFyZy5sZW5ndGggfHwgYXJnLm5vZGVUeXBlKSA/IHRoaXMgOiB0aGlzLnJlbW92ZSgpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGRldGFjaDogZnVuY3Rpb24oc2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlKHNlbGVjdG9yLCB0cnVlKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBkb21NYW5pcDogZnVuY3Rpb24oYXJncywgY2FsbGJhY2spIHtcclxuXHJcbiAgICAgICAgICAgIC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcclxuICAgICAgICAgICAgYXJncyA9IGNvbmNhdC5hcHBseShbXSwgYXJncyk7XHJcblxyXG4gICAgICAgICAgICB2YXIgZnJhZ21lbnQsIGZpcnN0LCBzY3JpcHRzLCBoYXNTY3JpcHRzLCBub2RlLCBkb2MsXHJcbiAgICAgICAgICAgICAgICBpID0gMCxcclxuICAgICAgICAgICAgICAgIGwgPSB0aGlzLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgIHNldCA9IHRoaXMsXHJcbiAgICAgICAgICAgICAgICBpTm9DbG9uZSA9IGwgLSAxLFxyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBhcmdzWzBdLFxyXG4gICAgICAgICAgICAgICAgaXNGdW5jdGlvbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKHZhbHVlKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFdlIGNhbid0IGNsb25lTm9kZSBmcmFnbWVudHMgdGhhdCBjb250YWluIGNoZWNrZWQsIGluIFdlYktpdFxyXG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbiB8fFxyXG4gICAgICAgICAgICAgICAgKGwgPiAxICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJlxyXG4gICAgICAgICAgICAgICAgICAgICFzdXBwb3J0LmNoZWNrQ2xvbmUgJiYgcmNoZWNrZWQudGVzdCh2YWx1ZSkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGYgPSBzZXQuZXEoaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3NbMF0gPSB2YWx1ZS5jYWxsKHRoaXMsIGluZGV4LCBzZWxmLmh0bWwoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZG9tTWFuaXAoYXJncywgY2FsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChsKSB7XHJcbiAgICAgICAgICAgICAgICBmcmFnbWVudCA9IGpRdWVyeS5idWlsZEZyYWdtZW50KGFyZ3MsIHRoaXNbMF0ub3duZXJEb2N1bWVudCwgZmFsc2UsIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgZmlyc3QgPSBmcmFnbWVudC5maXJzdENoaWxkO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChmcmFnbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gZmlyc3Q7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2NyaXB0cyA9IGpRdWVyeS5tYXAoZ2V0QWxsKGZyYWdtZW50LCBcInNjcmlwdFwiKSwgZGlzYWJsZVNjcmlwdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFzU2NyaXB0cyA9IHNjcmlwdHMubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIG9yaWdpbmFsIGZyYWdtZW50IGZvciB0aGUgbGFzdCBpdGVtIGluc3RlYWQgb2YgdGhlIGZpcnN0IGJlY2F1c2UgaXQgY2FuIGVuZCB1cFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGJlaW5nIGVtcHRpZWQgaW5jb3JyZWN0bHkgaW4gY2VydGFpbiBzaXR1YXRpb25zICgjODA3MCkuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGZyYWdtZW50O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgIT09IGlOb0Nsb25lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlID0galF1ZXJ5LmNsb25lKG5vZGUsIHRydWUsIHRydWUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEtlZXAgcmVmZXJlbmNlcyB0byBjbG9uZWQgc2NyaXB0cyBmb3IgbGF0ZXIgcmVzdG9yYXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNTY3JpcHRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogUXRXZWJLaXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBqUXVlcnkubWVyZ2UgYmVjYXVzZSBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5Lm1lcmdlKHNjcmlwdHMsIGdldEFsbChub2RlLCBcInNjcmlwdFwiKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwodGhpc1tpXSwgbm9kZSwgaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzU2NyaXB0cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkb2MgPSBzY3JpcHRzW3NjcmlwdHMubGVuZ3RoIC0gMV0ub3duZXJEb2N1bWVudDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlZW5hYmxlIHNjcmlwdHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5Lm1hcChzY3JpcHRzLCByZXN0b3JlU2NyaXB0KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV2YWx1YXRlIGV4ZWN1dGFibGUgc2NyaXB0cyBvbiBmaXJzdCBkb2N1bWVudCBpbnNlcnRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGhhc1NjcmlwdHM7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHNjcmlwdHNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocnNjcmlwdFR5cGUudGVzdChub2RlLnR5cGUgfHwgXCJcIikgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhZGF0YV9wcml2LmFjY2Vzcyhub2RlLCBcImdsb2JhbEV2YWxcIikgJiYgalF1ZXJ5LmNvbnRhaW5zKGRvYywgbm9kZSkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuc3JjKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9wdGlvbmFsIEFKQVggZGVwZW5kZW5jeSwgYnV0IHdvbid0IHJ1biBzY3JpcHRzIGlmIG5vdCBwcmVzZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqUXVlcnkuX2V2YWxVcmwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5fZXZhbFVybChub2RlLnNyYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZ2xvYmFsRXZhbChub2RlLnRleHRDb250ZW50LnJlcGxhY2UocmNsZWFuU2NyaXB0LCBcIlwiKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBqUXVlcnkuZWFjaCh7XHJcbiAgICAgICAgYXBwZW5kVG86IFwiYXBwZW5kXCIsXHJcbiAgICAgICAgcHJlcGVuZFRvOiBcInByZXBlbmRcIixcclxuICAgICAgICBpbnNlcnRCZWZvcmU6IFwiYmVmb3JlXCIsXHJcbiAgICAgICAgaW5zZXJ0QWZ0ZXI6IFwiYWZ0ZXJcIixcclxuICAgICAgICByZXBsYWNlQWxsOiBcInJlcGxhY2VXaXRoXCJcclxuICAgIH0sIGZ1bmN0aW9uKG5hbWUsIG9yaWdpbmFsKSB7XHJcbiAgICAgICAgalF1ZXJ5LmZuW25hbWVdID0gZnVuY3Rpb24oc2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgdmFyIGVsZW1zLFxyXG4gICAgICAgICAgICAgICAgcmV0ID0gW10sXHJcbiAgICAgICAgICAgICAgICBpbnNlcnQgPSBqUXVlcnkoc2VsZWN0b3IpLFxyXG4gICAgICAgICAgICAgICAgbGFzdCA9IGluc2VydC5sZW5ndGggLSAxLFxyXG4gICAgICAgICAgICAgICAgaSA9IDA7XHJcblxyXG4gICAgICAgICAgICBmb3IgKDsgaSA8PSBsYXN0OyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGVsZW1zID0gaSA9PT0gbGFzdCA/IHRoaXMgOiB0aGlzLmNsb25lKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgalF1ZXJ5KGluc2VydFtpXSlbb3JpZ2luYWxdKGVsZW1zKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBRdFdlYktpdFxyXG4gICAgICAgICAgICAgICAgLy8gLmdldCgpIGJlY2F1c2UgcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93c1xyXG4gICAgICAgICAgICAgICAgcHVzaC5hcHBseShyZXQsIGVsZW1zLmdldCgpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKHJldCk7XHJcbiAgICAgICAgfTtcclxuICAgIH0pO1xyXG5cclxuXHJcbiAgICB2YXIgaWZyYW1lLFxyXG4gICAgICAgIGVsZW1kaXNwbGF5ID0ge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZSB0aGUgYWN0dWFsIGRpc3BsYXkgb2YgYSBlbGVtZW50XHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBub2RlTmFtZSBvZiB0aGUgZWxlbWVudFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRvYyBEb2N1bWVudCBvYmplY3RcclxuICAgICAqL1xyXG4gICAgLy8gQ2FsbGVkIG9ubHkgZnJvbSB3aXRoaW4gZGVmYXVsdERpc3BsYXlcclxuICAgIGZ1bmN0aW9uIGFjdHVhbERpc3BsYXkobmFtZSwgZG9jKSB7XHJcbiAgICAgICAgdmFyIHN0eWxlLFxyXG4gICAgICAgICAgICBlbGVtID0galF1ZXJ5KGRvYy5jcmVhdGVFbGVtZW50KG5hbWUpKS5hcHBlbmRUbyhkb2MuYm9keSksXHJcblxyXG4gICAgICAgICAgICAvLyBnZXREZWZhdWx0Q29tcHV0ZWRTdHlsZSBtaWdodCBiZSByZWxpYWJseSB1c2VkIG9ubHkgb24gYXR0YWNoZWQgZWxlbWVudFxyXG4gICAgICAgICAgICBkaXNwbGF5ID0gd2luZG93LmdldERlZmF1bHRDb21wdXRlZFN0eWxlICYmIChzdHlsZSA9IHdpbmRvdy5nZXREZWZhdWx0Q29tcHV0ZWRTdHlsZShlbGVtWzBdKSkgP1xyXG5cclxuICAgICAgICAgICAgLy8gVXNlIG9mIHRoaXMgbWV0aG9kIGlzIGEgdGVtcG9yYXJ5IGZpeCAobW9yZSBsaWtlIG9wdG1pemF0aW9uKSB1bnRpbCBzb21ldGhpbmcgYmV0dGVyIGNvbWVzIGFsb25nLFxyXG4gICAgICAgICAgICAvLyBzaW5jZSBpdCB3YXMgcmVtb3ZlZCBmcm9tIHNwZWNpZmljYXRpb24gYW5kIHN1cHBvcnRlZCBvbmx5IGluIEZGXHJcbiAgICAgICAgICAgIHN0eWxlLmRpc3BsYXkgOiBqUXVlcnkuY3NzKGVsZW1bMF0sIFwiZGlzcGxheVwiKTtcclxuXHJcbiAgICAgICAgLy8gV2UgZG9uJ3QgaGF2ZSBhbnkgZGF0YSBzdG9yZWQgb24gdGhlIGVsZW1lbnQsXHJcbiAgICAgICAgLy8gc28gdXNlIFwiZGV0YWNoXCIgbWV0aG9kIGFzIGZhc3Qgd2F5IHRvIGdldCByaWQgb2YgdGhlIGVsZW1lbnRcclxuICAgICAgICBlbGVtLmRldGFjaCgpO1xyXG5cclxuICAgICAgICByZXR1cm4gZGlzcGxheTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRyeSB0byBkZXRlcm1pbmUgdGhlIGRlZmF1bHQgZGlzcGxheSB2YWx1ZSBvZiBhbiBlbGVtZW50XHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbm9kZU5hbWVcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZGVmYXVsdERpc3BsYXkobm9kZU5hbWUpIHtcclxuICAgICAgICB2YXIgZG9jID0gZG9jdW1lbnQsXHJcbiAgICAgICAgICAgIGRpc3BsYXkgPSBlbGVtZGlzcGxheVtub2RlTmFtZV07XHJcblxyXG4gICAgICAgIGlmICghZGlzcGxheSkge1xyXG4gICAgICAgICAgICBkaXNwbGF5ID0gYWN0dWFsRGlzcGxheShub2RlTmFtZSwgZG9jKTtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIHRoZSBzaW1wbGUgd2F5IGZhaWxzLCByZWFkIGZyb20gaW5zaWRlIGFuIGlmcmFtZVxyXG4gICAgICAgICAgICBpZiAoZGlzcGxheSA9PT0gXCJub25lXCIgfHwgIWRpc3BsYXkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIGFscmVhZHktY3JlYXRlZCBpZnJhbWUgaWYgcG9zc2libGVcclxuICAgICAgICAgICAgICAgIGlmcmFtZSA9IChpZnJhbWUgfHwgalF1ZXJ5KFwiPGlmcmFtZSBmcmFtZWJvcmRlcj0nMCcgd2lkdGg9JzAnIGhlaWdodD0nMCcvPlwiKSkuYXBwZW5kVG8oZG9jLmRvY3VtZW50RWxlbWVudCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQWx3YXlzIHdyaXRlIGEgbmV3IEhUTUwgc2tlbGV0b24gc28gV2Via2l0IGFuZCBGaXJlZm94IGRvbid0IGNob2tlIG9uIHJldXNlXHJcbiAgICAgICAgICAgICAgICBkb2MgPSBpZnJhbWVbMF0uY29udGVudERvY3VtZW50O1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFXHJcbiAgICAgICAgICAgICAgICBkb2Mud3JpdGUoKTtcclxuICAgICAgICAgICAgICAgIGRvYy5jbG9zZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGRpc3BsYXkgPSBhY3R1YWxEaXNwbGF5KG5vZGVOYW1lLCBkb2MpO1xyXG4gICAgICAgICAgICAgICAgaWZyYW1lLmRldGFjaCgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBTdG9yZSB0aGUgY29ycmVjdCBkZWZhdWx0IGRpc3BsYXlcclxuICAgICAgICAgICAgZWxlbWRpc3BsYXlbbm9kZU5hbWVdID0gZGlzcGxheTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBkaXNwbGF5O1xyXG4gICAgfVxyXG4gICAgdmFyIHJtYXJnaW4gPSAoL15tYXJnaW4vKTtcclxuXHJcbiAgICB2YXIgcm51bW5vbnB4ID0gbmV3IFJlZ0V4cChcIl4oXCIgKyBwbnVtICsgXCIpKD8hcHgpW2EteiVdKyRcIiwgXCJpXCIpO1xyXG5cclxuICAgIHZhciBnZXRTdHlsZXMgPSBmdW5jdGlvbihlbGVtKSB7XHJcbiAgICAgICAgcmV0dXJuIGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKGVsZW0sIG51bGwpO1xyXG4gICAgfTtcclxuXHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIGN1ckNTUyhlbGVtLCBuYW1lLCBjb21wdXRlZCkge1xyXG4gICAgICAgIHZhciB3aWR0aCwgbWluV2lkdGgsIG1heFdpZHRoLCByZXQsXHJcbiAgICAgICAgICAgIHN0eWxlID0gZWxlbS5zdHlsZTtcclxuXHJcbiAgICAgICAgY29tcHV0ZWQgPSBjb21wdXRlZCB8fCBnZXRTdHlsZXMoZWxlbSk7XHJcblxyXG4gICAgICAgIC8vIFN1cHBvcnQ6IElFOVxyXG4gICAgICAgIC8vIGdldFByb3BlcnR5VmFsdWUgaXMgb25seSBuZWVkZWQgZm9yIC5jc3MoJ2ZpbHRlcicpIGluIElFOSwgc2VlICMxMjUzN1xyXG4gICAgICAgIGlmIChjb21wdXRlZCkge1xyXG4gICAgICAgICAgICByZXQgPSBjb21wdXRlZC5nZXRQcm9wZXJ0eVZhbHVlKG5hbWUpIHx8IGNvbXB1dGVkW25hbWVdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGNvbXB1dGVkKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAocmV0ID09PSBcIlwiICYmICFqUXVlcnkuY29udGFpbnMoZWxlbS5vd25lckRvY3VtZW50LCBlbGVtKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0ID0galF1ZXJ5LnN0eWxlKGVsZW0sIG5hbWUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBTdXBwb3J0OiBpT1MgPCA2XHJcbiAgICAgICAgICAgIC8vIEEgdHJpYnV0ZSB0byB0aGUgXCJhd2Vzb21lIGhhY2sgYnkgRGVhbiBFZHdhcmRzXCJcclxuICAgICAgICAgICAgLy8gaU9TIDwgNiAoYXQgbGVhc3QpIHJldHVybnMgcGVyY2VudGFnZSBmb3IgYSBsYXJnZXIgc2V0IG9mIHZhbHVlcywgYnV0IHdpZHRoIHNlZW1zIHRvIGJlIHJlbGlhYmx5IHBpeGVsc1xyXG4gICAgICAgICAgICAvLyB0aGlzIGlzIGFnYWluc3QgdGhlIENTU09NIGRyYWZ0IHNwZWM6IGh0dHA6Ly9kZXYudzMub3JnL2Nzc3dnL2Nzc29tLyNyZXNvbHZlZC12YWx1ZXNcclxuICAgICAgICAgICAgaWYgKHJudW1ub25weC50ZXN0KHJldCkgJiYgcm1hcmdpbi50ZXN0KG5hbWUpKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUmVtZW1iZXIgdGhlIG9yaWdpbmFsIHZhbHVlc1xyXG4gICAgICAgICAgICAgICAgd2lkdGggPSBzdHlsZS53aWR0aDtcclxuICAgICAgICAgICAgICAgIG1pbldpZHRoID0gc3R5bGUubWluV2lkdGg7XHJcbiAgICAgICAgICAgICAgICBtYXhXaWR0aCA9IHN0eWxlLm1heFdpZHRoO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFB1dCBpbiB0aGUgbmV3IHZhbHVlcyB0byBnZXQgYSBjb21wdXRlZCB2YWx1ZSBvdXRcclxuICAgICAgICAgICAgICAgIHN0eWxlLm1pbldpZHRoID0gc3R5bGUubWF4V2lkdGggPSBzdHlsZS53aWR0aCA9IHJldDtcclxuICAgICAgICAgICAgICAgIHJldCA9IGNvbXB1dGVkLndpZHRoO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFJldmVydCB0aGUgY2hhbmdlZCB2YWx1ZXNcclxuICAgICAgICAgICAgICAgIHN0eWxlLndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgICAgICAgICBzdHlsZS5taW5XaWR0aCA9IG1pbldpZHRoO1xyXG4gICAgICAgICAgICAgICAgc3R5bGUubWF4V2lkdGggPSBtYXhXaWR0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHJldCAhPT0gdW5kZWZpbmVkID9cclxuICAgICAgICAgICAgLy8gU3VwcG9ydDogSUVcclxuICAgICAgICAgICAgLy8gSUUgcmV0dXJucyB6SW5kZXggdmFsdWUgYXMgYW4gaW50ZWdlci5cclxuICAgICAgICAgICAgcmV0ICsgXCJcIiA6XHJcbiAgICAgICAgICAgIHJldDtcclxuICAgIH1cclxuXHJcblxyXG4gICAgZnVuY3Rpb24gYWRkR2V0SG9va0lmKGNvbmRpdGlvbkZuLCBob29rRm4pIHtcclxuICAgICAgICAvLyBEZWZpbmUgdGhlIGhvb2ssIHdlJ2xsIGNoZWNrIG9uIHRoZSBmaXJzdCBydW4gaWYgaXQncyByZWFsbHkgbmVlZGVkLlxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29uZGl0aW9uRm4oKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEhvb2sgbm90IG5lZWRlZCAob3IgaXQncyBub3QgcG9zc2libGUgdG8gdXNlIGl0IGR1ZSB0byBtaXNzaW5nIGRlcGVuZGVuY3kpLFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBpdC5cclxuICAgICAgICAgICAgICAgICAgICAvLyBTaW5jZSB0aGVyZSBhcmUgbm8gb3RoZXIgaG9va3MgZm9yIG1hcmdpblJpZ2h0LCByZW1vdmUgdGhlIHdob2xlIG9iamVjdC5cclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5nZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIEhvb2sgbmVlZGVkOyByZWRlZmluZSBpdCBzbyB0aGF0IHRoZSBzdXBwb3J0IHRlc3QgaXMgbm90IGV4ZWN1dGVkIGFnYWluLlxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5nZXQgPSBob29rRm4pLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHBpeGVsUG9zaXRpb25WYWwsIGJveFNpemluZ1JlbGlhYmxlVmFsLFxyXG4gICAgICAgICAgICBkb2NFbGVtID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxyXG4gICAgICAgICAgICBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLFxyXG4gICAgICAgICAgICBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG5cclxuICAgICAgICBpZiAoIWRpdi5zdHlsZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcImNvbnRlbnQtYm94XCI7XHJcbiAgICAgICAgZGl2LmNsb25lTm9kZSh0cnVlKS5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFwiXCI7XHJcbiAgICAgICAgc3VwcG9ydC5jbGVhckNsb25lU3R5bGUgPSBkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPT09IFwiY29udGVudC1ib3hcIjtcclxuXHJcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLmNzc1RleHQgPSBcImJvcmRlcjowO3dpZHRoOjA7aGVpZ2h0OjA7dG9wOjA7bGVmdDotOTk5OXB4O21hcmdpbi10b3A6MXB4O1wiICtcclxuICAgICAgICAgICAgXCJwb3NpdGlvbjphYnNvbHV0ZVwiO1xyXG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChkaXYpO1xyXG5cclxuICAgICAgICAvLyBFeGVjdXRpbmcgYm90aCBwaXhlbFBvc2l0aW9uICYgYm94U2l6aW5nUmVsaWFibGUgdGVzdHMgcmVxdWlyZSBvbmx5IG9uZSBsYXlvdXRcclxuICAgICAgICAvLyBzbyB0aGV5J3JlIGV4ZWN1dGVkIGF0IHRoZSBzYW1lIHRpbWUgdG8gc2F2ZSB0aGUgc2Vjb25kIGNvbXB1dGF0aW9uLlxyXG4gICAgICAgIGZ1bmN0aW9uIGNvbXB1dGVQaXhlbFBvc2l0aW9uQW5kQm94U2l6aW5nUmVsaWFibGUoKSB7XHJcbiAgICAgICAgICAgIGRpdi5zdHlsZS5jc3NUZXh0ID1cclxuICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IEZpcmVmb3g8MjksIEFuZHJvaWQgMi4zXHJcbiAgICAgICAgICAgICAgICAvLyBWZW5kb3ItcHJlZml4IGJveC1zaXppbmdcclxuICAgICAgICAgICAgICAgIFwiLXdlYmtpdC1ib3gtc2l6aW5nOmJvcmRlci1ib3g7LW1vei1ib3gtc2l6aW5nOmJvcmRlci1ib3g7XCIgK1xyXG4gICAgICAgICAgICAgICAgXCJib3gtc2l6aW5nOmJvcmRlci1ib3g7ZGlzcGxheTpibG9jazttYXJnaW4tdG9wOjElO3RvcDoxJTtcIiArXHJcbiAgICAgICAgICAgICAgICBcImJvcmRlcjoxcHg7cGFkZGluZzoxcHg7d2lkdGg6NHB4O3Bvc2l0aW9uOmFic29sdXRlXCI7XHJcbiAgICAgICAgICAgIGRpdi5pbm5lckhUTUwgPSBcIlwiO1xyXG4gICAgICAgICAgICBkb2NFbGVtLmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XHJcblxyXG4gICAgICAgICAgICB2YXIgZGl2U3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkaXYsIG51bGwpO1xyXG4gICAgICAgICAgICBwaXhlbFBvc2l0aW9uVmFsID0gZGl2U3R5bGUudG9wICE9PSBcIjElXCI7XHJcbiAgICAgICAgICAgIGJveFNpemluZ1JlbGlhYmxlVmFsID0gZGl2U3R5bGUud2lkdGggPT09IFwiNHB4XCI7XHJcblxyXG4gICAgICAgICAgICBkb2NFbGVtLnJlbW92ZUNoaWxkKGNvbnRhaW5lcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBTdXBwb3J0OiBub2RlLmpzIGpzZG9tXHJcbiAgICAgICAgLy8gRG9uJ3QgYXNzdW1lIHRoYXQgZ2V0Q29tcHV0ZWRTdHlsZSBpcyBhIHByb3BlcnR5IG9mIHRoZSBnbG9iYWwgb2JqZWN0XHJcbiAgICAgICAgaWYgKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKSB7XHJcbiAgICAgICAgICAgIGpRdWVyeS5leHRlbmQoc3VwcG9ydCwge1xyXG4gICAgICAgICAgICAgICAgcGl4ZWxQb3NpdGlvbjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyB0ZXN0IGlzIGV4ZWN1dGVkIG9ubHkgb25jZSBidXQgd2Ugc3RpbGwgZG8gbWVtb2l6aW5nXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc2luY2Ugd2UgY2FuIHVzZSB0aGUgYm94U2l6aW5nUmVsaWFibGUgcHJlLWNvbXB1dGluZy5cclxuICAgICAgICAgICAgICAgICAgICAvLyBObyBuZWVkIHRvIGNoZWNrIGlmIHRoZSB0ZXN0IHdhcyBhbHJlYWR5IHBlcmZvcm1lZCwgdGhvdWdoLlxyXG4gICAgICAgICAgICAgICAgICAgIGNvbXB1dGVQaXhlbFBvc2l0aW9uQW5kQm94U2l6aW5nUmVsaWFibGUoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGl4ZWxQb3NpdGlvblZhbDtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBib3hTaXppbmdSZWxpYWJsZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJveFNpemluZ1JlbGlhYmxlVmFsID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcHV0ZVBpeGVsUG9zaXRpb25BbmRCb3hTaXppbmdSZWxpYWJsZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYm94U2l6aW5nUmVsaWFibGVWYWw7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgcmVsaWFibGVNYXJnaW5SaWdodDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogQW5kcm9pZCAyLjNcclxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBkaXYgd2l0aCBleHBsaWNpdCB3aWR0aCBhbmQgbm8gbWFyZ2luLXJpZ2h0IGluY29ycmVjdGx5XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZ2V0cyBjb21wdXRlZCBtYXJnaW4tcmlnaHQgYmFzZWQgb24gd2lkdGggb2YgY29udGFpbmVyLiAoIzMzMzMpXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2ViS2l0IEJ1ZyAxMzM0MyAtIGdldENvbXB1dGVkU3R5bGUgcmV0dXJucyB3cm9uZyB2YWx1ZSBmb3IgbWFyZ2luLXJpZ2h0XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBzdXBwb3J0IGZ1bmN0aW9uIGlzIG9ubHkgZXhlY3V0ZWQgb25jZSBzbyBubyBtZW1vaXppbmcgaXMgbmVlZGVkLlxyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpbkRpdiA9IGRpdi5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgQ1NTOiBib3gtc2l6aW5nOyBkaXNwbGF5OyBtYXJnaW47IGJvcmRlcjsgcGFkZGluZ1xyXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbkRpdi5zdHlsZS5jc3NUZXh0ID0gZGl2LnN0eWxlLmNzc1RleHQgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0OiBGaXJlZm94PDI5LCBBbmRyb2lkIDIuM1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBWZW5kb3ItcHJlZml4IGJveC1zaXppbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCItd2Via2l0LWJveC1zaXppbmc6Y29udGVudC1ib3g7LW1vei1ib3gtc2l6aW5nOmNvbnRlbnQtYm94O1wiICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCJib3gtc2l6aW5nOmNvbnRlbnQtYm94O2Rpc3BsYXk6YmxvY2s7bWFyZ2luOjA7Ym9yZGVyOjA7cGFkZGluZzowXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luRGl2LnN0eWxlLm1hcmdpblJpZ2h0ID0gbWFyZ2luRGl2LnN0eWxlLndpZHRoID0gXCIwXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgZGl2LnN0eWxlLndpZHRoID0gXCIxcHhcIjtcclxuICAgICAgICAgICAgICAgICAgICBkb2NFbGVtLmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldCA9ICFwYXJzZUZsb2F0KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKG1hcmdpbkRpdiwgbnVsbCkubWFyZ2luUmlnaHQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBkb2NFbGVtLnJlbW92ZUNoaWxkKGNvbnRhaW5lcik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0pKCk7XHJcblxyXG5cclxuICAgIC8vIEEgbWV0aG9kIGZvciBxdWlja2x5IHN3YXBwaW5nIGluL291dCBDU1MgcHJvcGVydGllcyB0byBnZXQgY29ycmVjdCBjYWxjdWxhdGlvbnMuXHJcbiAgICBqUXVlcnkuc3dhcCA9IGZ1bmN0aW9uKGVsZW0sIG9wdGlvbnMsIGNhbGxiYWNrLCBhcmdzKSB7XHJcbiAgICAgICAgdmFyIHJldCwgbmFtZSxcclxuICAgICAgICAgICAgb2xkID0ge307XHJcblxyXG4gICAgICAgIC8vIFJlbWVtYmVyIHRoZSBvbGQgdmFsdWVzLCBhbmQgaW5zZXJ0IHRoZSBuZXcgb25lc1xyXG4gICAgICAgIGZvciAobmFtZSBpbiBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIG9sZFtuYW1lXSA9IGVsZW0uc3R5bGVbbmFtZV07XHJcbiAgICAgICAgICAgIGVsZW0uc3R5bGVbbmFtZV0gPSBvcHRpb25zW25hbWVdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0ID0gY2FsbGJhY2suYXBwbHkoZWxlbSwgYXJncyB8fCBbXSk7XHJcblxyXG4gICAgICAgIC8vIFJldmVydCB0aGUgb2xkIHZhbHVlc1xyXG4gICAgICAgIGZvciAobmFtZSBpbiBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIGVsZW0uc3R5bGVbbmFtZV0gPSBvbGRbbmFtZV07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgdmFyXHJcbiAgICAvLyBzd2FwcGFibGUgaWYgZGlzcGxheSBpcyBub25lIG9yIHN0YXJ0cyB3aXRoIHRhYmxlIGV4Y2VwdCBcInRhYmxlXCIsIFwidGFibGUtY2VsbFwiLCBvciBcInRhYmxlLWNhcHRpb25cIlxyXG4gICAgLy8gc2VlIGhlcmUgZm9yIGRpc3BsYXkgdmFsdWVzOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0NTUy9kaXNwbGF5XHJcbiAgICAgICAgcmRpc3BsYXlzd2FwID0gL14obm9uZXx0YWJsZSg/IS1jW2VhXSkuKykvLFxyXG4gICAgICAgIHJudW1zcGxpdCA9IG5ldyBSZWdFeHAoXCJeKFwiICsgcG51bSArIFwiKSguKikkXCIsIFwiaVwiKSxcclxuICAgICAgICBycmVsTnVtID0gbmV3IFJlZ0V4cChcIl4oWystXSk9KFwiICsgcG51bSArIFwiKVwiLCBcImlcIiksXHJcblxyXG4gICAgICAgIGNzc1Nob3cgPSB7IHBvc2l0aW9uOiBcImFic29sdXRlXCIsIHZpc2liaWxpdHk6IFwiaGlkZGVuXCIsIGRpc3BsYXk6IFwiYmxvY2tcIiB9LFxyXG4gICAgICAgIGNzc05vcm1hbFRyYW5zZm9ybSA9IHtcclxuICAgICAgICAgICAgbGV0dGVyU3BhY2luZzogXCIwXCIsXHJcbiAgICAgICAgICAgIGZvbnRXZWlnaHQ6IFwiNDAwXCJcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBjc3NQcmVmaXhlcyA9IFtcIldlYmtpdFwiLCBcIk9cIiwgXCJNb3pcIiwgXCJtc1wiXTtcclxuXHJcbiAgICAvLyByZXR1cm4gYSBjc3MgcHJvcGVydHkgbWFwcGVkIHRvIGEgcG90ZW50aWFsbHkgdmVuZG9yIHByZWZpeGVkIHByb3BlcnR5XHJcbiAgICBmdW5jdGlvbiB2ZW5kb3JQcm9wTmFtZShzdHlsZSwgbmFtZSkge1xyXG5cclxuICAgICAgICAvLyBzaG9ydGN1dCBmb3IgbmFtZXMgdGhhdCBhcmUgbm90IHZlbmRvciBwcmVmaXhlZFxyXG4gICAgICAgIGlmIChuYW1lIGluIHN0eWxlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuYW1lO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gY2hlY2sgZm9yIHZlbmRvciBwcmVmaXhlZCBuYW1lc1xyXG4gICAgICAgIHZhciBjYXBOYW1lID0gbmFtZVswXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKSxcclxuICAgICAgICAgICAgb3JpZ05hbWUgPSBuYW1lLFxyXG4gICAgICAgICAgICBpID0gY3NzUHJlZml4ZXMubGVuZ3RoO1xyXG5cclxuICAgICAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgICAgIG5hbWUgPSBjc3NQcmVmaXhlc1tpXSArIGNhcE5hbWU7XHJcbiAgICAgICAgICAgIGlmIChuYW1lIGluIHN0eWxlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmFtZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG9yaWdOYW1lO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNldFBvc2l0aXZlTnVtYmVyKGVsZW0sIHZhbHVlLCBzdWJ0cmFjdCkge1xyXG4gICAgICAgIHZhciBtYXRjaGVzID0gcm51bXNwbGl0LmV4ZWModmFsdWUpO1xyXG4gICAgICAgIHJldHVybiBtYXRjaGVzID9cclxuICAgICAgICAgICAgLy8gR3VhcmQgYWdhaW5zdCB1bmRlZmluZWQgXCJzdWJ0cmFjdFwiLCBlLmcuLCB3aGVuIHVzZWQgYXMgaW4gY3NzSG9va3NcclxuICAgICAgICAgICAgTWF0aC5tYXgoMCwgbWF0Y2hlc1sxXSAtIChzdWJ0cmFjdCB8fCAwKSkgKyAobWF0Y2hlc1syXSB8fCBcInB4XCIpIDpcclxuICAgICAgICAgICAgdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYXVnbWVudFdpZHRoT3JIZWlnaHQoZWxlbSwgbmFtZSwgZXh0cmEsIGlzQm9yZGVyQm94LCBzdHlsZXMpIHtcclxuICAgICAgICB2YXIgaSA9IGV4dHJhID09PSAoaXNCb3JkZXJCb3ggPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIpID9cclxuICAgICAgICAgICAgLy8gSWYgd2UgYWxyZWFkeSBoYXZlIHRoZSByaWdodCBtZWFzdXJlbWVudCwgYXZvaWQgYXVnbWVudGF0aW9uXHJcbiAgICAgICAgICAgIDQgOlxyXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UgaW5pdGlhbGl6ZSBmb3IgaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbCBwcm9wZXJ0aWVzXHJcbiAgICAgICAgICAgIG5hbWUgPT09IFwid2lkdGhcIiA/IDEgOiAwLFxyXG5cclxuICAgICAgICAgICAgdmFsID0gMDtcclxuXHJcbiAgICAgICAgZm9yICg7IGkgPCA0OyBpICs9IDIpIHtcclxuICAgICAgICAgICAgLy8gYm90aCBib3ggbW9kZWxzIGV4Y2x1ZGUgbWFyZ2luLCBzbyBhZGQgaXQgaWYgd2Ugd2FudCBpdFxyXG4gICAgICAgICAgICBpZiAoZXh0cmEgPT09IFwibWFyZ2luXCIpIHtcclxuICAgICAgICAgICAgICAgIHZhbCArPSBqUXVlcnkuY3NzKGVsZW0sIGV4dHJhICsgY3NzRXhwYW5kW2ldLCB0cnVlLCBzdHlsZXMpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoaXNCb3JkZXJCb3gpIHtcclxuICAgICAgICAgICAgICAgIC8vIGJvcmRlci1ib3ggaW5jbHVkZXMgcGFkZGluZywgc28gcmVtb3ZlIGl0IGlmIHdlIHdhbnQgY29udGVudFxyXG4gICAgICAgICAgICAgICAgaWYgKGV4dHJhID09PSBcImNvbnRlbnRcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbCAtPSBqUXVlcnkuY3NzKGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kW2ldLCB0cnVlLCBzdHlsZXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIGF0IHRoaXMgcG9pbnQsIGV4dHJhIGlzbid0IGJvcmRlciBub3IgbWFyZ2luLCBzbyByZW1vdmUgYm9yZGVyXHJcbiAgICAgICAgICAgICAgICBpZiAoZXh0cmEgIT09IFwibWFyZ2luXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWwgLT0galF1ZXJ5LmNzcyhlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kW2ldICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gYXQgdGhpcyBwb2ludCwgZXh0cmEgaXNuJ3QgY29udGVudCwgc28gYWRkIHBhZGRpbmdcclxuICAgICAgICAgICAgICAgIHZhbCArPSBqUXVlcnkuY3NzKGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kW2ldLCB0cnVlLCBzdHlsZXMpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGF0IHRoaXMgcG9pbnQsIGV4dHJhIGlzbid0IGNvbnRlbnQgbm9yIHBhZGRpbmcsIHNvIGFkZCBib3JkZXJcclxuICAgICAgICAgICAgICAgIGlmIChleHRyYSAhPT0gXCJwYWRkaW5nXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWwgKz0galF1ZXJ5LmNzcyhlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kW2ldICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdmFsO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldFdpZHRoT3JIZWlnaHQoZWxlbSwgbmFtZSwgZXh0cmEpIHtcclxuXHJcbiAgICAgICAgLy8gU3RhcnQgd2l0aCBvZmZzZXQgcHJvcGVydHksIHdoaWNoIGlzIGVxdWl2YWxlbnQgdG8gdGhlIGJvcmRlci1ib3ggdmFsdWVcclxuICAgICAgICB2YXIgdmFsdWVJc0JvcmRlckJveCA9IHRydWUsXHJcbiAgICAgICAgICAgIHZhbCA9IG5hbWUgPT09IFwid2lkdGhcIiA/IGVsZW0ub2Zmc2V0V2lkdGggOiBlbGVtLm9mZnNldEhlaWdodCxcclxuICAgICAgICAgICAgc3R5bGVzID0gZ2V0U3R5bGVzKGVsZW0pLFxyXG4gICAgICAgICAgICBpc0JvcmRlckJveCA9IGpRdWVyeS5jc3MoZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcykgPT09IFwiYm9yZGVyLWJveFwiO1xyXG5cclxuICAgICAgICAvLyBzb21lIG5vbi1odG1sIGVsZW1lbnRzIHJldHVybiB1bmRlZmluZWQgZm9yIG9mZnNldFdpZHRoLCBzbyBjaGVjayBmb3IgbnVsbC91bmRlZmluZWRcclxuICAgICAgICAvLyBzdmcgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02NDkyODVcclxuICAgICAgICAvLyBNYXRoTUwgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD00OTE2NjhcclxuICAgICAgICBpZiAodmFsIDw9IDAgfHwgdmFsID09IG51bGwpIHtcclxuICAgICAgICAgICAgLy8gRmFsbCBiYWNrIHRvIGNvbXB1dGVkIHRoZW4gdW5jb21wdXRlZCBjc3MgaWYgbmVjZXNzYXJ5XHJcbiAgICAgICAgICAgIHZhbCA9IGN1ckNTUyhlbGVtLCBuYW1lLCBzdHlsZXMpO1xyXG4gICAgICAgICAgICBpZiAodmFsIDwgMCB8fCB2YWwgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdmFsID0gZWxlbS5zdHlsZVtuYW1lXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQ29tcHV0ZWQgdW5pdCBpcyBub3QgcGl4ZWxzLiBTdG9wIGhlcmUgYW5kIHJldHVybi5cclxuICAgICAgICAgICAgaWYgKHJudW1ub25weC50ZXN0KHZhbCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIHdlIG5lZWQgdGhlIGNoZWNrIGZvciBzdHlsZSBpbiBjYXNlIGEgYnJvd3NlciB3aGljaCByZXR1cm5zIHVucmVsaWFibGUgdmFsdWVzXHJcbiAgICAgICAgICAgIC8vIGZvciBnZXRDb21wdXRlZFN0eWxlIHNpbGVudGx5IGZhbGxzIGJhY2sgdG8gdGhlIHJlbGlhYmxlIGVsZW0uc3R5bGVcclxuICAgICAgICAgICAgdmFsdWVJc0JvcmRlckJveCA9IGlzQm9yZGVyQm94ICYmXHJcbiAgICAgICAgICAgICAgICAoc3VwcG9ydC5ib3hTaXppbmdSZWxpYWJsZSgpIHx8IHZhbCA9PT0gZWxlbS5zdHlsZVtuYW1lXSk7XHJcblxyXG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgXCJcIiwgYXV0bywgYW5kIHByZXBhcmUgZm9yIGV4dHJhXHJcbiAgICAgICAgICAgIHZhbCA9IHBhcnNlRmxvYXQodmFsKSB8fCAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gdXNlIHRoZSBhY3RpdmUgYm94LXNpemluZyBtb2RlbCB0byBhZGQvc3VidHJhY3QgaXJyZWxldmFudCBzdHlsZXNcclxuICAgICAgICByZXR1cm4gKHZhbCArXHJcbiAgICAgICAgICAgIGF1Z21lbnRXaWR0aE9ySGVpZ2h0KFxyXG4gICAgICAgICAgICAgICAgZWxlbSxcclxuICAgICAgICAgICAgICAgIG5hbWUsXHJcbiAgICAgICAgICAgICAgICBleHRyYSB8fCAoaXNCb3JkZXJCb3ggPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIpLFxyXG4gICAgICAgICAgICAgICAgdmFsdWVJc0JvcmRlckJveCxcclxuICAgICAgICAgICAgICAgIHN0eWxlc1xyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgKSArIFwicHhcIjtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzaG93SGlkZShlbGVtZW50cywgc2hvdykge1xyXG4gICAgICAgIHZhciBkaXNwbGF5LCBlbGVtLCBoaWRkZW4sXHJcbiAgICAgICAgICAgIHZhbHVlcyA9IFtdLFxyXG4gICAgICAgICAgICBpbmRleCA9IDAsXHJcbiAgICAgICAgICAgIGxlbmd0aCA9IGVsZW1lbnRzLmxlbmd0aDtcclxuXHJcbiAgICAgICAgZm9yICg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgICAgICAgIGVsZW0gPSBlbGVtZW50c1tpbmRleF07XHJcbiAgICAgICAgICAgIGlmICghZWxlbS5zdHlsZSkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhbHVlc1tpbmRleF0gPSBkYXRhX3ByaXYuZ2V0KGVsZW0sIFwib2xkZGlzcGxheVwiKTtcclxuICAgICAgICAgICAgZGlzcGxheSA9IGVsZW0uc3R5bGUuZGlzcGxheTtcclxuICAgICAgICAgICAgaWYgKHNob3cpIHtcclxuICAgICAgICAgICAgICAgIC8vIFJlc2V0IHRoZSBpbmxpbmUgZGlzcGxheSBvZiB0aGlzIGVsZW1lbnQgdG8gbGVhcm4gaWYgaXQgaXNcclxuICAgICAgICAgICAgICAgIC8vIGJlaW5nIGhpZGRlbiBieSBjYXNjYWRlZCBydWxlcyBvciBub3RcclxuICAgICAgICAgICAgICAgIGlmICghdmFsdWVzW2luZGV4XSAmJiBkaXNwbGF5ID09PSBcIm5vbmVcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZW0uc3R5bGUuZGlzcGxheSA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU2V0IGVsZW1lbnRzIHdoaWNoIGhhdmUgYmVlbiBvdmVycmlkZGVuIHdpdGggZGlzcGxheTogbm9uZVxyXG4gICAgICAgICAgICAgICAgLy8gaW4gYSBzdHlsZXNoZWV0IHRvIHdoYXRldmVyIHRoZSBkZWZhdWx0IGJyb3dzZXIgc3R5bGUgaXNcclxuICAgICAgICAgICAgICAgIC8vIGZvciBzdWNoIGFuIGVsZW1lbnRcclxuICAgICAgICAgICAgICAgIGlmIChlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgJiYgaXNIaWRkZW4oZWxlbSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXNbaW5kZXhdID0gZGF0YV9wcml2LmFjY2VzcyhlbGVtLCBcIm9sZGRpc3BsYXlcIiwgZGVmYXVsdERpc3BsYXkoZWxlbS5ub2RlTmFtZSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaGlkZGVuID0gaXNIaWRkZW4oZWxlbSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGRpc3BsYXkgIT09IFwibm9uZVwiIHx8ICFoaWRkZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhX3ByaXYuc2V0KGVsZW0sIFwib2xkZGlzcGxheVwiLCBoaWRkZW4gPyBkaXNwbGF5IDogalF1ZXJ5LmNzcyhlbGVtLCBcImRpc3BsYXlcIikpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBTZXQgdGhlIGRpc3BsYXkgb2YgbW9zdCBvZiB0aGUgZWxlbWVudHMgaW4gYSBzZWNvbmQgbG9vcFxyXG4gICAgICAgIC8vIHRvIGF2b2lkIHRoZSBjb25zdGFudCByZWZsb3dcclxuICAgICAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcclxuICAgICAgICAgICAgZWxlbSA9IGVsZW1lbnRzW2luZGV4XTtcclxuICAgICAgICAgICAgaWYgKCFlbGVtLnN0eWxlKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIXNob3cgfHwgZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIm5vbmVcIiB8fCBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIpIHtcclxuICAgICAgICAgICAgICAgIGVsZW0uc3R5bGUuZGlzcGxheSA9IHNob3cgPyB2YWx1ZXNbaW5kZXhdIHx8IFwiXCIgOiBcIm5vbmVcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGVsZW1lbnRzO1xyXG4gICAgfVxyXG5cclxuICAgIGpRdWVyeS5leHRlbmQoe1xyXG4gICAgICAgIC8vIEFkZCBpbiBzdHlsZSBwcm9wZXJ0eSBob29rcyBmb3Igb3ZlcnJpZGluZyB0aGUgZGVmYXVsdFxyXG4gICAgICAgIC8vIGJlaGF2aW9yIG9mIGdldHRpbmcgYW5kIHNldHRpbmcgYSBzdHlsZSBwcm9wZXJ0eVxyXG4gICAgICAgIGNzc0hvb2tzOiB7XHJcbiAgICAgICAgICAgIG9wYWNpdHk6IHtcclxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oZWxlbSwgY29tcHV0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcHV0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2Ugc2hvdWxkIGFsd2F5cyBnZXQgYSBudW1iZXIgYmFjayBmcm9tIG9wYWNpdHlcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJldCA9IGN1ckNTUyhlbGVtLCBcIm9wYWNpdHlcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQgPT09IFwiXCIgPyBcIjFcIiA6IHJldDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvLyBEb24ndCBhdXRvbWF0aWNhbGx5IGFkZCBcInB4XCIgdG8gdGhlc2UgcG9zc2libHktdW5pdGxlc3MgcHJvcGVydGllc1xyXG4gICAgICAgIGNzc051bWJlcjoge1xyXG4gICAgICAgICAgICBcImNvbHVtbkNvdW50XCI6IHRydWUsXHJcbiAgICAgICAgICAgIFwiZmlsbE9wYWNpdHlcIjogdHJ1ZSxcclxuICAgICAgICAgICAgXCJmbGV4R3Jvd1wiOiB0cnVlLFxyXG4gICAgICAgICAgICBcImZsZXhTaHJpbmtcIjogdHJ1ZSxcclxuICAgICAgICAgICAgXCJmb250V2VpZ2h0XCI6IHRydWUsXHJcbiAgICAgICAgICAgIFwibGluZUhlaWdodFwiOiB0cnVlLFxyXG4gICAgICAgICAgICBcIm9wYWNpdHlcIjogdHJ1ZSxcclxuICAgICAgICAgICAgXCJvcmRlclwiOiB0cnVlLFxyXG4gICAgICAgICAgICBcIm9ycGhhbnNcIjogdHJ1ZSxcclxuICAgICAgICAgICAgXCJ3aWRvd3NcIjogdHJ1ZSxcclxuICAgICAgICAgICAgXCJ6SW5kZXhcIjogdHJ1ZSxcclxuICAgICAgICAgICAgXCJ6b29tXCI6IHRydWVcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvLyBBZGQgaW4gcHJvcGVydGllcyB3aG9zZSBuYW1lcyB5b3Ugd2lzaCB0byBmaXggYmVmb3JlXHJcbiAgICAgICAgLy8gc2V0dGluZyBvciBnZXR0aW5nIHRoZSB2YWx1ZVxyXG4gICAgICAgIGNzc1Byb3BzOiB7XHJcbiAgICAgICAgICAgIC8vIG5vcm1hbGl6ZSBmbG9hdCBjc3MgcHJvcGVydHlcclxuICAgICAgICAgICAgXCJmbG9hdFwiOiBcImNzc0Zsb2F0XCJcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvLyBHZXQgYW5kIHNldCB0aGUgc3R5bGUgcHJvcGVydHkgb24gYSBET00gTm9kZVxyXG4gICAgICAgIHN0eWxlOiBmdW5jdGlvbihlbGVtLCBuYW1lLCB2YWx1ZSwgZXh0cmEpIHtcclxuICAgICAgICAgICAgLy8gRG9uJ3Qgc2V0IHN0eWxlcyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXHJcbiAgICAgICAgICAgIGlmICghZWxlbSB8fCBlbGVtLm5vZGVUeXBlID09PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT09IDggfHwgIWVsZW0uc3R5bGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lXHJcbiAgICAgICAgICAgIHZhciByZXQsIHR5cGUsIGhvb2tzLFxyXG4gICAgICAgICAgICAgICAgb3JpZ05hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKG5hbWUpLFxyXG4gICAgICAgICAgICAgICAgc3R5bGUgPSBlbGVtLnN0eWxlO1xyXG5cclxuICAgICAgICAgICAgbmFtZSA9IGpRdWVyeS5jc3NQcm9wc1tvcmlnTmFtZV0gfHwgKGpRdWVyeS5jc3NQcm9wc1tvcmlnTmFtZV0gPSB2ZW5kb3JQcm9wTmFtZShzdHlsZSwgb3JpZ05hbWUpKTtcclxuXHJcbiAgICAgICAgICAgIC8vIGdldHMgaG9vayBmb3IgdGhlIHByZWZpeGVkIHZlcnNpb25cclxuICAgICAgICAgICAgLy8gZm9sbG93ZWQgYnkgdGhlIHVucHJlZml4ZWQgdmVyc2lvblxyXG4gICAgICAgICAgICBob29rcyA9IGpRdWVyeS5jc3NIb29rc1tuYW1lXSB8fCBqUXVlcnkuY3NzSG9va3Nbb3JpZ05hbWVdO1xyXG5cclxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgd2UncmUgc2V0dGluZyBhIHZhbHVlXHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICB0eXBlID0gdHlwZW9mIHZhbHVlO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGNvbnZlcnQgcmVsYXRpdmUgbnVtYmVyIHN0cmluZ3MgKCs9IG9yIC09KSB0byByZWxhdGl2ZSBudW1iZXJzLiAjNzM0NVxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwic3RyaW5nXCIgJiYgKHJldCA9IHJyZWxOdW0uZXhlYyh2YWx1ZSkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAocmV0WzFdICsgMSkgKiByZXRbMl0gKyBwYXJzZUZsb2F0KGpRdWVyeS5jc3MoZWxlbSwgbmFtZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpeGVzIGJ1ZyAjOTIzN1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSBcIm51bWJlclwiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IG51bGwgYW5kIE5hTiB2YWx1ZXMgYXJlbid0IHNldC4gU2VlOiAjNzExNlxyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwgfHwgdmFsdWUgIT09IHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIElmIGEgbnVtYmVyIHdhcyBwYXNzZWQgaW4sIGFkZCAncHgnIHRvIHRoZSAoZXhjZXB0IGZvciBjZXJ0YWluIENTUyBwcm9wZXJ0aWVzKVxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwibnVtYmVyXCIgJiYgIWpRdWVyeS5jc3NOdW1iZXJbb3JpZ05hbWVdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gXCJweFwiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIEZpeGVzICM4OTA4LCBpdCBjYW4gYmUgZG9uZSBtb3JlIGNvcnJlY3RseSBieSBzcGVjaWZ5aW5nIHNldHRlcnMgaW4gY3NzSG9va3MsXHJcbiAgICAgICAgICAgICAgICAvLyBidXQgaXQgd291bGQgbWVhbiB0byBkZWZpbmUgZWlnaHQgKGZvciBldmVyeSBwcm9ibGVtYXRpYyBwcm9wZXJ0eSkgaWRlbnRpY2FsIGZ1bmN0aW9uc1xyXG4gICAgICAgICAgICAgICAgaWYgKCFzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSAmJiB2YWx1ZSA9PT0gXCJcIiAmJiBuYW1lLmluZGV4T2YoXCJiYWNrZ3JvdW5kXCIpID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVbbmFtZV0gPSBcImluaGVyaXRcIjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkLCB1c2UgdGhhdCB2YWx1ZSwgb3RoZXJ3aXNlIGp1c3Qgc2V0IHRoZSBzcGVjaWZpZWQgdmFsdWVcclxuICAgICAgICAgICAgICAgIGlmICghaG9va3MgfHwgIShcInNldFwiIGluIGhvb2tzKSB8fCAodmFsdWUgPSBob29rcy5zZXQoZWxlbSwgdmFsdWUsIGV4dHJhKSkgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlW25hbWVdID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIG5vbi1jb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXHJcbiAgICAgICAgICAgICAgICBpZiAoaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAocmV0ID0gaG9va3MuZ2V0KGVsZW0sIGZhbHNlLCBleHRyYSkpICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSBqdXN0IGdldCB0aGUgdmFsdWUgZnJvbSB0aGUgc3R5bGUgb2JqZWN0XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3R5bGVbbmFtZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBjc3M6IGZ1bmN0aW9uKGVsZW0sIG5hbWUsIGV4dHJhLCBzdHlsZXMpIHtcclxuICAgICAgICAgICAgdmFyIHZhbCwgbnVtLCBob29rcyxcclxuICAgICAgICAgICAgICAgIG9yaWdOYW1lID0galF1ZXJ5LmNhbWVsQ2FzZShuYW1lKTtcclxuXHJcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZVxyXG4gICAgICAgICAgICBuYW1lID0galF1ZXJ5LmNzc1Byb3BzW29yaWdOYW1lXSB8fCAoalF1ZXJ5LmNzc1Byb3BzW29yaWdOYW1lXSA9IHZlbmRvclByb3BOYW1lKGVsZW0uc3R5bGUsIG9yaWdOYW1lKSk7XHJcblxyXG4gICAgICAgICAgICAvLyBnZXRzIGhvb2sgZm9yIHRoZSBwcmVmaXhlZCB2ZXJzaW9uXHJcbiAgICAgICAgICAgIC8vIGZvbGxvd2VkIGJ5IHRoZSB1bnByZWZpeGVkIHZlcnNpb25cclxuICAgICAgICAgICAgaG9va3MgPSBqUXVlcnkuY3NzSG9va3NbbmFtZV0gfHwgalF1ZXJ5LmNzc0hvb2tzW29yaWdOYW1lXTtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXHJcbiAgICAgICAgICAgIGlmIChob29rcyAmJiBcImdldFwiIGluIGhvb2tzKSB7XHJcbiAgICAgICAgICAgICAgICB2YWwgPSBob29rcy5nZXQoZWxlbSwgdHJ1ZSwgZXh0cmEpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIGlmIGEgd2F5IHRvIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZXhpc3RzLCB1c2UgdGhhdFxyXG4gICAgICAgICAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHZhbCA9IGN1ckNTUyhlbGVtLCBuYW1lLCBzdHlsZXMpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL2NvbnZlcnQgXCJub3JtYWxcIiB0byBjb21wdXRlZCB2YWx1ZVxyXG4gICAgICAgICAgICBpZiAodmFsID09PSBcIm5vcm1hbFwiICYmIG5hbWUgaW4gY3NzTm9ybWFsVHJhbnNmb3JtKSB7XHJcbiAgICAgICAgICAgICAgICB2YWwgPSBjc3NOb3JtYWxUcmFuc2Zvcm1bbmFtZV07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFJldHVybiwgY29udmVydGluZyB0byBudW1iZXIgaWYgZm9yY2VkIG9yIGEgcXVhbGlmaWVyIHdhcyBwcm92aWRlZCBhbmQgdmFsIGxvb2tzIG51bWVyaWNcclxuICAgICAgICAgICAgaWYgKGV4dHJhID09PSBcIlwiIHx8IGV4dHJhKSB7XHJcbiAgICAgICAgICAgICAgICBudW0gPSBwYXJzZUZsb2F0KHZhbCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZXh0cmEgPT09IHRydWUgfHwgalF1ZXJ5LmlzTnVtZXJpYyhudW0pID8gbnVtIHx8IDAgOiB2YWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHZhbDtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBqUXVlcnkuZWFjaChbXCJoZWlnaHRcIiwgXCJ3aWR0aFwiXSwgZnVuY3Rpb24oaSwgbmFtZSkge1xyXG4gICAgICAgIGpRdWVyeS5jc3NIb29rc1tuYW1lXSA9IHtcclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbihlbGVtLCBjb21wdXRlZCwgZXh0cmEpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjb21wdXRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNlcnRhaW4gZWxlbWVudHMgY2FuIGhhdmUgZGltZW5zaW9uIGluZm8gaWYgd2UgaW52aXNpYmx5IHNob3cgdGhlbVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGhvd2V2ZXIsIGl0IG11c3QgaGF2ZSBhIGN1cnJlbnQgZGlzcGxheSBzdHlsZSB0aGF0IHdvdWxkIGJlbmVmaXQgZnJvbSB0aGlzXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJkaXNwbGF5c3dhcC50ZXN0KGpRdWVyeS5jc3MoZWxlbSwgXCJkaXNwbGF5XCIpKSAmJiBlbGVtLm9mZnNldFdpZHRoID09PSAwID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LnN3YXAoZWxlbSwgY3NzU2hvdywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0V2lkdGhPckhlaWdodChlbGVtLCBuYW1lLCBleHRyYSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0V2lkdGhPckhlaWdodChlbGVtLCBuYW1lLCBleHRyYSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKGVsZW0sIHZhbHVlLCBleHRyYSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0eWxlcyA9IGV4dHJhICYmIGdldFN0eWxlcyhlbGVtKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzZXRQb3NpdGl2ZU51bWJlcihlbGVtLCB2YWx1ZSwgZXh0cmEgP1xyXG4gICAgICAgICAgICAgICAgICAgIGF1Z21lbnRXaWR0aE9ySGVpZ2h0KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHRyYSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmNzcyhlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzKSA9PT0gXCJib3JkZXItYm94XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlc1xyXG4gICAgICAgICAgICAgICAgICAgICkgOiAwXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIFN1cHBvcnQ6IEFuZHJvaWQgMi4zXHJcbiAgICBqUXVlcnkuY3NzSG9va3MubWFyZ2luUmlnaHQgPSBhZGRHZXRIb29rSWYoc3VwcG9ydC5yZWxpYWJsZU1hcmdpblJpZ2h0LFxyXG4gICAgICAgIGZ1bmN0aW9uKGVsZW0sIGNvbXB1dGVkKSB7XHJcbiAgICAgICAgICAgIGlmIChjb21wdXRlZCkge1xyXG4gICAgICAgICAgICAgICAgLy8gV2ViS2l0IEJ1ZyAxMzM0MyAtIGdldENvbXB1dGVkU3R5bGUgcmV0dXJucyB3cm9uZyB2YWx1ZSBmb3IgbWFyZ2luLXJpZ2h0XHJcbiAgICAgICAgICAgICAgICAvLyBXb3JrIGFyb3VuZCBieSB0ZW1wb3JhcmlseSBzZXR0aW5nIGVsZW1lbnQgZGlzcGxheSB0byBpbmxpbmUtYmxvY2tcclxuICAgICAgICAgICAgICAgIHJldHVybiBqUXVlcnkuc3dhcChlbGVtLCB7IFwiZGlzcGxheVwiOiBcImlubGluZS1ibG9ja1wiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgY3VyQ1NTLCBbZWxlbSwgXCJtYXJnaW5SaWdodFwiXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICApO1xyXG5cclxuICAgIC8vIFRoZXNlIGhvb2tzIGFyZSB1c2VkIGJ5IGFuaW1hdGUgdG8gZXhwYW5kIHByb3BlcnRpZXNcclxuICAgIGpRdWVyeS5lYWNoKHtcclxuICAgICAgICBtYXJnaW46IFwiXCIsXHJcbiAgICAgICAgcGFkZGluZzogXCJcIixcclxuICAgICAgICBib3JkZXI6IFwiV2lkdGhcIlxyXG4gICAgfSwgZnVuY3Rpb24ocHJlZml4LCBzdWZmaXgpIHtcclxuICAgICAgICBqUXVlcnkuY3NzSG9va3NbcHJlZml4ICsgc3VmZml4XSA9IHtcclxuICAgICAgICAgICAgZXhwYW5kOiBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGkgPSAwLFxyXG4gICAgICAgICAgICAgICAgICAgIGV4cGFuZGVkID0ge30sXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFzc3VtZXMgYSBzaW5nbGUgbnVtYmVyIGlmIG5vdCBhIHN0cmluZ1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcnRzID0gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiID8gdmFsdWUuc3BsaXQoXCIgXCIpIDogW3ZhbHVlXTtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IDQ7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGV4cGFuZGVkW3ByZWZpeCArIGNzc0V4cGFuZFtpXSArIHN1ZmZpeF0gPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0c1tpXSB8fCBwYXJ0c1tpIC0gMl0gfHwgcGFydHNbMF07XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4cGFuZGVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgaWYgKCFybWFyZ2luLnRlc3QocHJlZml4KSkge1xyXG4gICAgICAgICAgICBqUXVlcnkuY3NzSG9va3NbcHJlZml4ICsgc3VmZml4XS5zZXQgPSBzZXRQb3NpdGl2ZU51bWJlcjtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBqUXVlcnkuZm4uZXh0ZW5kKHtcclxuICAgICAgICBjc3M6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhY2Nlc3ModGhpcywgZnVuY3Rpb24oZWxlbSwgbmFtZSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzdHlsZXMsIGxlbixcclxuICAgICAgICAgICAgICAgICAgICBtYXAgPSB7fSxcclxuICAgICAgICAgICAgICAgICAgICBpID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoalF1ZXJ5LmlzQXJyYXkobmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZXMgPSBnZXRTdHlsZXMoZWxlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVuID0gbmFtZS5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWFwW25hbWVbaV1dID0galF1ZXJ5LmNzcyhlbGVtLCBuYW1lW2ldLCBmYWxzZSwgc3R5bGVzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXA7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgP1xyXG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5zdHlsZShlbGVtLCBuYW1lLCB2YWx1ZSkgOlxyXG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5jc3MoZWxlbSwgbmFtZSk7XHJcbiAgICAgICAgICAgIH0sIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzaG93OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNob3dIaWRlKHRoaXMsIHRydWUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaGlkZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzaG93SGlkZSh0aGlzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHRvZ2dsZTogZnVuY3Rpb24oc3RhdGUpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJib29sZWFuXCIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZSA/IHRoaXMuc2hvdygpIDogdGhpcy5oaWRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNIaWRkZW4odGhpcykpIHtcclxuICAgICAgICAgICAgICAgICAgICBqUXVlcnkodGhpcykuc2hvdygpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBqUXVlcnkodGhpcykuaGlkZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcblxyXG4gICAgZnVuY3Rpb24gVHdlZW4oZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFR3ZWVuLnByb3RvdHlwZS5pbml0KGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nKTtcclxuICAgIH1cclxuICAgIGpRdWVyeS5Ud2VlbiA9IFR3ZWVuO1xyXG5cclxuICAgIFR3ZWVuLnByb3RvdHlwZSA9IHtcclxuICAgICAgICBjb25zdHJ1Y3RvcjogVHdlZW4sXHJcbiAgICAgICAgaW5pdDogZnVuY3Rpb24oZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcsIHVuaXQpIHtcclxuICAgICAgICAgICAgdGhpcy5lbGVtID0gZWxlbTtcclxuICAgICAgICAgICAgdGhpcy5wcm9wID0gcHJvcDtcclxuICAgICAgICAgICAgdGhpcy5lYXNpbmcgPSBlYXNpbmcgfHwgXCJzd2luZ1wiO1xyXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0ID0gdGhpcy5ub3cgPSB0aGlzLmN1cigpO1xyXG4gICAgICAgICAgICB0aGlzLmVuZCA9IGVuZDtcclxuICAgICAgICAgICAgdGhpcy51bml0ID0gdW5pdCB8fCAoalF1ZXJ5LmNzc051bWJlcltwcm9wXSA/IFwiXCIgOiBcInB4XCIpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY3VyOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgdmFyIGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzW3RoaXMucHJvcF07XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gaG9va3MgJiYgaG9va3MuZ2V0ID9cclxuICAgICAgICAgICAgICAgIGhvb2tzLmdldCh0aGlzKSA6XHJcbiAgICAgICAgICAgICAgICBUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuZ2V0KHRoaXMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcnVuOiBmdW5jdGlvbihwZXJjZW50KSB7XHJcbiAgICAgICAgICAgIHZhciBlYXNlZCxcclxuICAgICAgICAgICAgICAgIGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzW3RoaXMucHJvcF07XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmR1cmF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IGVhc2VkID0galF1ZXJ5LmVhc2luZ1t0aGlzLmVhc2luZ10oXHJcbiAgICAgICAgICAgICAgICAgICAgcGVyY2VudCwgdGhpcy5vcHRpb25zLmR1cmF0aW9uICogcGVyY2VudCwgMCwgMSwgdGhpcy5vcHRpb25zLmR1cmF0aW9uXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgPSBlYXNlZCA9IHBlcmNlbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5ub3cgPSAodGhpcy5lbmQgLSB0aGlzLnN0YXJ0KSAqIGVhc2VkICsgdGhpcy5zdGFydDtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3RlcCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnN0ZXAuY2FsbCh0aGlzLmVsZW0sIHRoaXMubm93LCB0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGhvb2tzICYmIGhvb2tzLnNldCkge1xyXG4gICAgICAgICAgICAgICAgaG9va3Muc2V0KHRoaXMpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgVHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LnNldCh0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIFR3ZWVuLnByb3RvdHlwZS5pbml0LnByb3RvdHlwZSA9IFR3ZWVuLnByb3RvdHlwZTtcclxuXHJcbiAgICBUd2Vlbi5wcm9wSG9va3MgPSB7XHJcbiAgICAgICAgX2RlZmF1bHQ6IHtcclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbih0d2Vlbikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodHdlZW4uZWxlbVt0d2Vlbi5wcm9wXSAhPSBudWxsICYmXHJcbiAgICAgICAgICAgICAgICAgICAgKCF0d2Vlbi5lbGVtLnN0eWxlIHx8IHR3ZWVuLmVsZW0uc3R5bGVbdHdlZW4ucHJvcF0gPT0gbnVsbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHdlZW4uZWxlbVt0d2Vlbi5wcm9wXTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBwYXNzaW5nIGFuIGVtcHR5IHN0cmluZyBhcyBhIDNyZCBwYXJhbWV0ZXIgdG8gLmNzcyB3aWxsIGF1dG9tYXRpY2FsbHlcclxuICAgICAgICAgICAgICAgIC8vIGF0dGVtcHQgYSBwYXJzZUZsb2F0IGFuZCBmYWxsYmFjayB0byBhIHN0cmluZyBpZiB0aGUgcGFyc2UgZmFpbHNcclxuICAgICAgICAgICAgICAgIC8vIHNvLCBzaW1wbGUgdmFsdWVzIHN1Y2ggYXMgXCIxMHB4XCIgYXJlIHBhcnNlZCB0byBGbG9hdC5cclxuICAgICAgICAgICAgICAgIC8vIGNvbXBsZXggdmFsdWVzIHN1Y2ggYXMgXCJyb3RhdGUoMXJhZClcIiBhcmUgcmV0dXJuZWQgYXMgaXMuXHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBqUXVlcnkuY3NzKHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIFwiXCIpO1xyXG4gICAgICAgICAgICAgICAgLy8gRW1wdHkgc3RyaW5ncywgbnVsbCwgdW5kZWZpbmVkIGFuZCBcImF1dG9cIiBhcmUgY29udmVydGVkIHRvIDAuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gIXJlc3VsdCB8fCByZXN1bHQgPT09IFwiYXV0b1wiID8gMCA6IHJlc3VsdDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih0d2Vlbikge1xyXG4gICAgICAgICAgICAgICAgLy8gdXNlIHN0ZXAgaG9vayBmb3IgYmFjayBjb21wYXQgLSB1c2UgY3NzSG9vayBpZiBpdHMgdGhlcmUgLSB1c2UgLnN0eWxlIGlmIGl0c1xyXG4gICAgICAgICAgICAgICAgLy8gYXZhaWxhYmxlIGFuZCB1c2UgcGxhaW4gcHJvcGVydGllcyB3aGVyZSBhdmFpbGFibGVcclxuICAgICAgICAgICAgICAgIGlmIChqUXVlcnkuZnguc3RlcFt0d2Vlbi5wcm9wXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5meC5zdGVwW3R3ZWVuLnByb3BdKHR3ZWVuKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHdlZW4uZWxlbS5zdHlsZSAmJiAodHdlZW4uZWxlbS5zdHlsZVtqUXVlcnkuY3NzUHJvcHNbdHdlZW4ucHJvcF1dICE9IG51bGwgfHwgalF1ZXJ5LmNzc0hvb2tzW3R3ZWVuLnByb3BdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5zdHlsZSh0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCB0d2Vlbi5ub3cgKyB0d2Vlbi51bml0KTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHdlZW4uZWxlbVt0d2Vlbi5wcm9wXSA9IHR3ZWVuLm5vdztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLy8gU3VwcG9ydDogSUU5XHJcbiAgICAvLyBQYW5pYyBiYXNlZCBhcHByb2FjaCB0byBzZXR0aW5nIHRoaW5ncyBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcclxuXHJcbiAgICBUd2Vlbi5wcm9wSG9va3Muc2Nyb2xsVG9wID0gVHdlZW4ucHJvcEhvb2tzLnNjcm9sbExlZnQgPSB7XHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbih0d2Vlbikge1xyXG4gICAgICAgICAgICBpZiAodHdlZW4uZWxlbS5ub2RlVHlwZSAmJiB0d2Vlbi5lbGVtLnBhcmVudE5vZGUpIHtcclxuICAgICAgICAgICAgICAgIHR3ZWVuLmVsZW1bdHdlZW4ucHJvcF0gPSB0d2Vlbi5ub3c7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGpRdWVyeS5lYXNpbmcgPSB7XHJcbiAgICAgICAgbGluZWFyOiBmdW5jdGlvbihwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc3dpbmc6IGZ1bmN0aW9uKHApIHtcclxuICAgICAgICAgICAgcmV0dXJuIDAuNSAtIE1hdGguY29zKHAgKiBNYXRoLlBJKSAvIDI7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBqUXVlcnkuZnggPSBUd2Vlbi5wcm90b3R5cGUuaW5pdDtcclxuXHJcbiAgICAvLyBCYWNrIENvbXBhdCA8MS44IGV4dGVuc2lvbiBwb2ludFxyXG4gICAgalF1ZXJ5LmZ4LnN0ZXAgPSB7fTtcclxuXHJcblxyXG5cclxuXHJcbiAgICB2YXJcclxuICAgICAgICBmeE5vdywgdGltZXJJZCxcclxuICAgICAgICByZnh0eXBlcyA9IC9eKD86dG9nZ2xlfHNob3d8aGlkZSkkLyxcclxuICAgICAgICByZnhudW0gPSBuZXcgUmVnRXhwKFwiXig/OihbKy1dKT18KShcIiArIHBudW0gKyBcIikoW2EteiVdKikkXCIsIFwiaVwiKSxcclxuICAgICAgICBycnVuID0gL3F1ZXVlSG9va3MkLyxcclxuICAgICAgICBhbmltYXRpb25QcmVmaWx0ZXJzID0gW2RlZmF1bHRQcmVmaWx0ZXJdLFxyXG4gICAgICAgIHR3ZWVuZXJzID0ge1xyXG4gICAgICAgICAgICBcIipcIjogW2Z1bmN0aW9uKHByb3AsIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdHdlZW4gPSB0aGlzLmNyZWF0ZVR3ZWVuKHByb3AsIHZhbHVlKSxcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSB0d2Vlbi5jdXIoKSxcclxuICAgICAgICAgICAgICAgICAgICBwYXJ0cyA9IHJmeG51bS5leGVjKHZhbHVlKSxcclxuICAgICAgICAgICAgICAgICAgICB1bml0ID0gcGFydHMgJiYgcGFydHNbM10gfHwgKGpRdWVyeS5jc3NOdW1iZXJbcHJvcF0gPyBcIlwiIDogXCJweFwiKSxcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU3RhcnRpbmcgdmFsdWUgY29tcHV0YXRpb24gaXMgcmVxdWlyZWQgZm9yIHBvdGVudGlhbCB1bml0IG1pc21hdGNoZXNcclxuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IChqUXVlcnkuY3NzTnVtYmVyW3Byb3BdIHx8IHVuaXQgIT09IFwicHhcIiAmJiArdGFyZ2V0KSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHJmeG51bS5leGVjKGpRdWVyeS5jc3ModHdlZW4uZWxlbSwgcHJvcCkpLFxyXG4gICAgICAgICAgICAgICAgICAgIHNjYWxlID0gMSxcclxuICAgICAgICAgICAgICAgICAgICBtYXhJdGVyYXRpb25zID0gMjA7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0ICYmIHN0YXJ0WzNdICE9PSB1bml0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVHJ1c3QgdW5pdHMgcmVwb3J0ZWQgYnkgalF1ZXJ5LmNzc1xyXG4gICAgICAgICAgICAgICAgICAgIHVuaXQgPSB1bml0IHx8IHN0YXJ0WzNdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgd2UgdXBkYXRlIHRoZSB0d2VlbiBwcm9wZXJ0aWVzIGxhdGVyIG9uXHJcbiAgICAgICAgICAgICAgICAgICAgcGFydHMgPSBwYXJ0cyB8fCBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSXRlcmF0aXZlbHkgYXBwcm94aW1hdGUgZnJvbSBhIG5vbnplcm8gc3RhcnRpbmcgcG9pbnRcclxuICAgICAgICAgICAgICAgICAgICBzdGFydCA9ICt0YXJnZXQgfHwgMTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBwcmV2aW91cyBpdGVyYXRpb24gemVyb2VkIG91dCwgZG91YmxlIHVudGlsIHdlIGdldCAqc29tZXRoaW5nKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2UgYSBzdHJpbmcgZm9yIGRvdWJsaW5nIGZhY3RvciBzbyB3ZSBkb24ndCBhY2NpZGVudGFsbHkgc2VlIHNjYWxlIGFzIHVuY2hhbmdlZCBiZWxvd1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzY2FsZSA9IHNjYWxlIHx8IFwiLjVcIjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkanVzdCBhbmQgYXBwbHlcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBzdGFydCAvIHNjYWxlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuc3R5bGUodHdlZW4uZWxlbSwgcHJvcCwgc3RhcnQgKyB1bml0KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBzY2FsZSwgdG9sZXJhdGluZyB6ZXJvIG9yIE5hTiBmcm9tIHR3ZWVuLmN1cigpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFuZCBicmVha2luZyB0aGUgbG9vcCBpZiBzY2FsZSBpcyB1bmNoYW5nZWQgb3IgcGVyZmVjdCwgb3IgaWYgd2UndmUganVzdCBoYWQgZW5vdWdoXHJcbiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoc2NhbGUgIT09IChzY2FsZSA9IHR3ZWVuLmN1cigpIC8gdGFyZ2V0KSAmJiBzY2FsZSAhPT0gMSAmJiAtLW1heEl0ZXJhdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0d2VlbiBwcm9wZXJ0aWVzXHJcbiAgICAgICAgICAgICAgICBpZiAocGFydHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IHR3ZWVuLnN0YXJ0ID0gK3N0YXJ0IHx8ICt0YXJnZXQgfHwgMDtcclxuICAgICAgICAgICAgICAgICAgICB0d2Vlbi51bml0ID0gdW5pdDtcclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBhICs9Ly09IHRva2VuIHdhcyBwcm92aWRlZCwgd2UncmUgZG9pbmcgYSByZWxhdGl2ZSBhbmltYXRpb25cclxuICAgICAgICAgICAgICAgICAgICB0d2Vlbi5lbmQgPSBwYXJ0c1sxXSA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ICsgKHBhcnRzWzFdICsgMSkgKiBwYXJ0c1syXSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICtwYXJ0c1syXTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHdlZW47XHJcbiAgICAgICAgICAgIH1dXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAvLyBBbmltYXRpb25zIGNyZWF0ZWQgc3luY2hyb25vdXNseSB3aWxsIHJ1biBzeW5jaHJvbm91c2x5XHJcbiAgICBmdW5jdGlvbiBjcmVhdGVGeE5vdygpIHtcclxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBmeE5vdyA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gKGZ4Tm93ID0galF1ZXJ5Lm5vdygpKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBHZW5lcmF0ZSBwYXJhbWV0ZXJzIHRvIGNyZWF0ZSBhIHN0YW5kYXJkIGFuaW1hdGlvblxyXG4gICAgZnVuY3Rpb24gZ2VuRngodHlwZSwgaW5jbHVkZVdpZHRoKSB7XHJcbiAgICAgICAgdmFyIHdoaWNoLFxyXG4gICAgICAgICAgICBpID0gMCxcclxuICAgICAgICAgICAgYXR0cnMgPSB7IGhlaWdodDogdHlwZSB9O1xyXG5cclxuICAgICAgICAvLyBpZiB3ZSBpbmNsdWRlIHdpZHRoLCBzdGVwIHZhbHVlIGlzIDEgdG8gZG8gYWxsIGNzc0V4cGFuZCB2YWx1ZXMsXHJcbiAgICAgICAgLy8gaWYgd2UgZG9uJ3QgaW5jbHVkZSB3aWR0aCwgc3RlcCB2YWx1ZSBpcyAyIHRvIHNraXAgb3ZlciBMZWZ0IGFuZCBSaWdodFxyXG4gICAgICAgIGluY2x1ZGVXaWR0aCA9IGluY2x1ZGVXaWR0aCA/IDEgOiAwO1xyXG4gICAgICAgIGZvciAoOyBpIDwgNDsgaSArPSAyIC0gaW5jbHVkZVdpZHRoKSB7XHJcbiAgICAgICAgICAgIHdoaWNoID0gY3NzRXhwYW5kW2ldO1xyXG4gICAgICAgICAgICBhdHRyc1tcIm1hcmdpblwiICsgd2hpY2hdID0gYXR0cnNbXCJwYWRkaW5nXCIgKyB3aGljaF0gPSB0eXBlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGluY2x1ZGVXaWR0aCkge1xyXG4gICAgICAgICAgICBhdHRycy5vcGFjaXR5ID0gYXR0cnMud2lkdGggPSB0eXBlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGF0dHJzO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZVR3ZWVuKHZhbHVlLCBwcm9wLCBhbmltYXRpb24pIHtcclxuICAgICAgICB2YXIgdHdlZW4sXHJcbiAgICAgICAgICAgIGNvbGxlY3Rpb24gPSAodHdlZW5lcnNbcHJvcF0gfHwgW10pLmNvbmNhdCh0d2VlbmVyc1tcIipcIl0pLFxyXG4gICAgICAgICAgICBpbmRleCA9IDAsXHJcbiAgICAgICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xyXG4gICAgICAgIGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICAgICAgICBpZiAoKHR3ZWVuID0gY29sbGVjdGlvbltpbmRleF0uY2FsbChhbmltYXRpb24sIHByb3AsIHZhbHVlKSkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyB3ZSdyZSBkb25lIHdpdGggdGhpcyBwcm9wZXJ0eVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHR3ZWVuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRlZmF1bHRQcmVmaWx0ZXIoZWxlbSwgcHJvcHMsIG9wdHMpIHtcclxuICAgICAgICAvKiBqc2hpbnQgdmFsaWR0aGlzOiB0cnVlICovXHJcbiAgICAgICAgdmFyIHByb3AsIHZhbHVlLCB0b2dnbGUsIHR3ZWVuLCBob29rcywgb2xkZmlyZSwgZGlzcGxheSwgY2hlY2tEaXNwbGF5LFxyXG4gICAgICAgICAgICBhbmltID0gdGhpcyxcclxuICAgICAgICAgICAgb3JpZyA9IHt9LFxyXG4gICAgICAgICAgICBzdHlsZSA9IGVsZW0uc3R5bGUsXHJcbiAgICAgICAgICAgIGhpZGRlbiA9IGVsZW0ubm9kZVR5cGUgJiYgaXNIaWRkZW4oZWxlbSksXHJcbiAgICAgICAgICAgIGRhdGFTaG93ID0gZGF0YV9wcml2LmdldChlbGVtLCBcImZ4c2hvd1wiKTtcclxuXHJcbiAgICAgICAgLy8gaGFuZGxlIHF1ZXVlOiBmYWxzZSBwcm9taXNlc1xyXG4gICAgICAgIGlmICghb3B0cy5xdWV1ZSkge1xyXG4gICAgICAgICAgICBob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyhlbGVtLCBcImZ4XCIpO1xyXG4gICAgICAgICAgICBpZiAoaG9va3MudW5xdWV1ZWQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgaG9va3MudW5xdWV1ZWQgPSAwO1xyXG4gICAgICAgICAgICAgICAgb2xkZmlyZSA9IGhvb2tzLmVtcHR5LmZpcmU7XHJcbiAgICAgICAgICAgICAgICBob29rcy5lbXB0eS5maXJlID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFob29rcy51bnF1ZXVlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbGRmaXJlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBob29rcy51bnF1ZXVlZCsrO1xyXG5cclxuICAgICAgICAgICAgYW5pbS5hbHdheXMoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBkb2luZyB0aGlzIG1ha2VzIHN1cmUgdGhhdCB0aGUgY29tcGxldGUgaGFuZGxlciB3aWxsIGJlIGNhbGxlZFxyXG4gICAgICAgICAgICAgICAgLy8gYmVmb3JlIHRoaXMgY29tcGxldGVzXHJcbiAgICAgICAgICAgICAgICBhbmltLmFsd2F5cyhmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICBob29rcy51bnF1ZXVlZC0tO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghalF1ZXJ5LnF1ZXVlKGVsZW0sIFwiZnhcIikubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvb2tzLmVtcHR5LmZpcmUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBoZWlnaHQvd2lkdGggb3ZlcmZsb3cgcGFzc1xyXG4gICAgICAgIGlmIChlbGVtLm5vZGVUeXBlID09PSAxICYmIChcImhlaWdodFwiIGluIHByb3BzIHx8IFwid2lkdGhcIiBpbiBwcm9wcykpIHtcclxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgbm90aGluZyBzbmVha3Mgb3V0XHJcbiAgICAgICAgICAgIC8vIFJlY29yZCBhbGwgMyBvdmVyZmxvdyBhdHRyaWJ1dGVzIGJlY2F1c2UgSUU5LTEwIGRvIG5vdFxyXG4gICAgICAgICAgICAvLyBjaGFuZ2UgdGhlIG92ZXJmbG93IGF0dHJpYnV0ZSB3aGVuIG92ZXJmbG93WCBhbmRcclxuICAgICAgICAgICAgLy8gb3ZlcmZsb3dZIGFyZSBzZXQgdG8gdGhlIHNhbWUgdmFsdWVcclxuICAgICAgICAgICAgb3B0cy5vdmVyZmxvdyA9IFtzdHlsZS5vdmVyZmxvdywgc3R5bGUub3ZlcmZsb3dYLCBzdHlsZS5vdmVyZmxvd1ldO1xyXG5cclxuICAgICAgICAgICAgLy8gU2V0IGRpc3BsYXkgcHJvcGVydHkgdG8gaW5saW5lLWJsb2NrIGZvciBoZWlnaHQvd2lkdGhcclxuICAgICAgICAgICAgLy8gYW5pbWF0aW9ucyBvbiBpbmxpbmUgZWxlbWVudHMgdGhhdCBhcmUgaGF2aW5nIHdpZHRoL2hlaWdodCBhbmltYXRlZFxyXG4gICAgICAgICAgICBkaXNwbGF5ID0galF1ZXJ5LmNzcyhlbGVtLCBcImRpc3BsYXlcIik7XHJcblxyXG4gICAgICAgICAgICAvLyBUZXN0IGRlZmF1bHQgZGlzcGxheSBpZiBkaXNwbGF5IGlzIGN1cnJlbnRseSBcIm5vbmVcIlxyXG4gICAgICAgICAgICBjaGVja0Rpc3BsYXkgPSBkaXNwbGF5ID09PSBcIm5vbmVcIiA/XHJcbiAgICAgICAgICAgICAgICBkYXRhX3ByaXYuZ2V0KGVsZW0sIFwib2xkZGlzcGxheVwiKSB8fCBkZWZhdWx0RGlzcGxheShlbGVtLm5vZGVOYW1lKSA6IGRpc3BsYXk7XHJcblxyXG4gICAgICAgICAgICBpZiAoY2hlY2tEaXNwbGF5ID09PSBcImlubGluZVwiICYmIGpRdWVyeS5jc3MoZWxlbSwgXCJmbG9hdFwiKSA9PT0gXCJub25lXCIpIHtcclxuICAgICAgICAgICAgICAgIHN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAob3B0cy5vdmVyZmxvdykge1xyXG4gICAgICAgICAgICBzdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XHJcbiAgICAgICAgICAgIGFuaW0uYWx3YXlzKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgc3R5bGUub3ZlcmZsb3cgPSBvcHRzLm92ZXJmbG93WzBdO1xyXG4gICAgICAgICAgICAgICAgc3R5bGUub3ZlcmZsb3dYID0gb3B0cy5vdmVyZmxvd1sxXTtcclxuICAgICAgICAgICAgICAgIHN0eWxlLm92ZXJmbG93WSA9IG9wdHMub3ZlcmZsb3dbMl07XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gc2hvdy9oaWRlIHBhc3NcclxuICAgICAgICBmb3IgKHByb3AgaW4gcHJvcHMpIHtcclxuICAgICAgICAgICAgdmFsdWUgPSBwcm9wc1twcm9wXTtcclxuICAgICAgICAgICAgaWYgKHJmeHR5cGVzLmV4ZWModmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgcHJvcHNbcHJvcF07XHJcbiAgICAgICAgICAgICAgICB0b2dnbGUgPSB0b2dnbGUgfHwgdmFsdWUgPT09IFwidG9nZ2xlXCI7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IChoaWRkZW4gPyBcImhpZGVcIiA6IFwic2hvd1wiKSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBkYXRhU2hvdyBsZWZ0IG92ZXIgZnJvbSBhIHN0b3BwZWQgaGlkZSBvciBzaG93IGFuZCB3ZSBhcmUgZ29pbmcgdG8gcHJvY2VlZCB3aXRoIHNob3csIHdlIHNob3VsZCBwcmV0ZW5kIHRvIGJlIGhpZGRlblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gXCJzaG93XCIgJiYgZGF0YVNob3cgJiYgZGF0YVNob3dbcHJvcF0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoaWRkZW4gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG9yaWdbcHJvcF0gPSBkYXRhU2hvdyAmJiBkYXRhU2hvd1twcm9wXSB8fCBqUXVlcnkuc3R5bGUoZWxlbSwgcHJvcCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQW55IG5vbi1meCB2YWx1ZSBzdG9wcyB1cyBmcm9tIHJlc3RvcmluZyB0aGUgb3JpZ2luYWwgZGlzcGxheSB2YWx1ZVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZGlzcGxheSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFqUXVlcnkuaXNFbXB0eU9iamVjdChvcmlnKSkge1xyXG4gICAgICAgICAgICBpZiAoZGF0YVNob3cpIHtcclxuICAgICAgICAgICAgICAgIGlmIChcImhpZGRlblwiIGluIGRhdGFTaG93KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGlkZGVuID0gZGF0YVNob3cuaGlkZGVuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZGF0YVNob3cgPSBkYXRhX3ByaXYuYWNjZXNzKGVsZW0sIFwiZnhzaG93XCIsIHt9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gc3RvcmUgc3RhdGUgaWYgaXRzIHRvZ2dsZSAtIGVuYWJsZXMgLnN0b3AoKS50b2dnbGUoKSB0byBcInJldmVyc2VcIlxyXG4gICAgICAgICAgICBpZiAodG9nZ2xlKSB7XHJcbiAgICAgICAgICAgICAgICBkYXRhU2hvdy5oaWRkZW4gPSAhaGlkZGVuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChoaWRkZW4pIHtcclxuICAgICAgICAgICAgICAgIGpRdWVyeShlbGVtKS5zaG93KCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBhbmltLmRvbmUoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KGVsZW0pLmhpZGUoKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFuaW0uZG9uZShmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwcm9wO1xyXG5cclxuICAgICAgICAgICAgICAgIGRhdGFfcHJpdi5yZW1vdmUoZWxlbSwgXCJmeHNob3dcIik7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHByb3AgaW4gb3JpZykge1xyXG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5zdHlsZShlbGVtLCBwcm9wLCBvcmlnW3Byb3BdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGZvciAocHJvcCBpbiBvcmlnKSB7XHJcbiAgICAgICAgICAgICAgICB0d2VlbiA9IGNyZWF0ZVR3ZWVuKGhpZGRlbiA/IGRhdGFTaG93W3Byb3BdIDogMCwgcHJvcCwgYW5pbSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCEocHJvcCBpbiBkYXRhU2hvdykpIHtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhU2hvd1twcm9wXSA9IHR3ZWVuLnN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChoaWRkZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHdlZW4uZW5kID0gdHdlZW4uc3RhcnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR3ZWVuLnN0YXJ0ID0gcHJvcCA9PT0gXCJ3aWR0aFwiIHx8IHByb3AgPT09IFwiaGVpZ2h0XCIgPyAxIDogMDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgYSBub29wIGxpa2UgLmhpZGUoKS5oaWRlKCksIHJlc3RvcmUgYW4gb3ZlcndyaXR0ZW4gZGlzcGxheSB2YWx1ZVxyXG4gICAgICAgIH0gZWxzZSBpZiAoKGRpc3BsYXkgPT09IFwibm9uZVwiID8gZGVmYXVsdERpc3BsYXkoZWxlbS5ub2RlTmFtZSkgOiBkaXNwbGF5KSA9PT0gXCJpbmxpbmVcIikge1xyXG4gICAgICAgICAgICBzdHlsZS5kaXNwbGF5ID0gZGlzcGxheTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcHJvcEZpbHRlcihwcm9wcywgc3BlY2lhbEVhc2luZykge1xyXG4gICAgICAgIHZhciBpbmRleCwgbmFtZSwgZWFzaW5nLCB2YWx1ZSwgaG9va3M7XHJcblxyXG4gICAgICAgIC8vIGNhbWVsQ2FzZSwgc3BlY2lhbEVhc2luZyBhbmQgZXhwYW5kIGNzc0hvb2sgcGFzc1xyXG4gICAgICAgIGZvciAoaW5kZXggaW4gcHJvcHMpIHtcclxuICAgICAgICAgICAgbmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoaW5kZXgpO1xyXG4gICAgICAgICAgICBlYXNpbmcgPSBzcGVjaWFsRWFzaW5nW25hbWVdO1xyXG4gICAgICAgICAgICB2YWx1ZSA9IHByb3BzW2luZGV4XTtcclxuICAgICAgICAgICAgaWYgKGpRdWVyeS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgZWFzaW5nID0gdmFsdWVbMV07XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHByb3BzW2luZGV4XSA9IHZhbHVlWzBdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IG5hbWUpIHtcclxuICAgICAgICAgICAgICAgIHByb3BzW25hbWVdID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgcHJvcHNbaW5kZXhdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBob29rcyA9IGpRdWVyeS5jc3NIb29rc1tuYW1lXTtcclxuICAgICAgICAgICAgaWYgKGhvb2tzICYmIFwiZXhwYW5kXCIgaW4gaG9va3MpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gaG9va3MuZXhwYW5kKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBwcm9wc1tuYW1lXTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBub3QgcXVpdGUgJC5leHRlbmQsIHRoaXMgd29udCBvdmVyd3JpdGUga2V5cyBhbHJlYWR5IHByZXNlbnQuXHJcbiAgICAgICAgICAgICAgICAvLyBhbHNvIC0gcmV1c2luZyAnaW5kZXgnIGZyb20gYWJvdmUgYmVjYXVzZSB3ZSBoYXZlIHRoZSBjb3JyZWN0IFwibmFtZVwiXHJcbiAgICAgICAgICAgICAgICBmb3IgKGluZGV4IGluIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoaW5kZXggaW4gcHJvcHMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzW2luZGV4XSA9IHZhbHVlW2luZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3BlY2lhbEVhc2luZ1tpbmRleF0gPSBlYXNpbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc3BlY2lhbEVhc2luZ1tuYW1lXSA9IGVhc2luZztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBBbmltYXRpb24oZWxlbSwgcHJvcGVydGllcywgb3B0aW9ucykge1xyXG4gICAgICAgIHZhciByZXN1bHQsXHJcbiAgICAgICAgICAgIHN0b3BwZWQsXHJcbiAgICAgICAgICAgIGluZGV4ID0gMCxcclxuICAgICAgICAgICAgbGVuZ3RoID0gYW5pbWF0aW9uUHJlZmlsdGVycy5sZW5ndGgsXHJcbiAgICAgICAgICAgIGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCkuYWx3YXlzKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgLy8gZG9uJ3QgbWF0Y2ggZWxlbSBpbiB0aGUgOmFuaW1hdGVkIHNlbGVjdG9yXHJcbiAgICAgICAgICAgICAgICBkZWxldGUgdGljay5lbGVtO1xyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgdGljayA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0b3BwZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudFRpbWUgPSBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxyXG4gICAgICAgICAgICAgICAgICAgIHJlbWFpbmluZyA9IE1hdGgubWF4KDAsIGFuaW1hdGlvbi5zdGFydFRpbWUgKyBhbmltYXRpb24uZHVyYXRpb24gLSBjdXJyZW50VGltZSksXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYXJjaGFpYyBjcmFzaCBidWcgd29uJ3QgYWxsb3cgdXMgdG8gdXNlIDEgLSAoIDAuNSB8fCAwICkgKCMxMjQ5NylcclxuICAgICAgICAgICAgICAgICAgICB0ZW1wID0gcmVtYWluaW5nIC8gYW5pbWF0aW9uLmR1cmF0aW9uIHx8IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgcGVyY2VudCA9IDEgLSB0ZW1wLFxyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gMCxcclxuICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSBhbmltYXRpb24udHdlZW5zLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcclxuICAgICAgICAgICAgICAgICAgICBhbmltYXRpb24udHdlZW5zW2luZGV4XS5ydW4ocGVyY2VudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZGVmZXJyZWQubm90aWZ5V2l0aChlbGVtLCBbYW5pbWF0aW9uLCBwZXJjZW50LCByZW1haW5pbmddKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAocGVyY2VudCA8IDEgJiYgbGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbWFpbmluZztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZVdpdGgoZWxlbSwgW2FuaW1hdGlvbl0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYW5pbWF0aW9uID0gZGVmZXJyZWQucHJvbWlzZSh7XHJcbiAgICAgICAgICAgICAgICBlbGVtOiBlbGVtLFxyXG4gICAgICAgICAgICAgICAgcHJvcHM6IGpRdWVyeS5leHRlbmQoe30sIHByb3BlcnRpZXMpLFxyXG4gICAgICAgICAgICAgICAgb3B0czogalF1ZXJ5LmV4dGVuZCh0cnVlLCB7IHNwZWNpYWxFYXNpbmc6IHt9IH0sIG9wdGlvbnMpLFxyXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxQcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLFxyXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxPcHRpb25zOiBvcHRpb25zLFxyXG4gICAgICAgICAgICAgICAgc3RhcnRUaW1lOiBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxyXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb24sXHJcbiAgICAgICAgICAgICAgICB0d2VlbnM6IFtdLFxyXG4gICAgICAgICAgICAgICAgY3JlYXRlVHdlZW46IGZ1bmN0aW9uKHByb3AsIGVuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0d2VlbiA9IGpRdWVyeS5Ud2VlbihlbGVtLCBhbmltYXRpb24ub3B0cywgcHJvcCwgZW5kLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nW3Byb3BdIHx8IGFuaW1hdGlvbi5vcHRzLmVhc2luZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uLnR3ZWVucy5wdXNoKHR3ZWVuKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHdlZW47XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgc3RvcDogZnVuY3Rpb24oZ290b0VuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlIGFyZSBnb2luZyB0byB0aGUgZW5kLCB3ZSB3YW50IHRvIHJ1biBhbGwgdGhlIHR3ZWVuc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2Ugd2Ugc2tpcCB0aGlzIHBhcnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gZ290b0VuZCA/IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoIDogMDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RvcHBlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgc3RvcHBlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbi50d2VlbnNbaW5kZXhdLnJ1bigxKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlc29sdmUgd2hlbiB3ZSBwbGF5ZWQgdGhlIGxhc3QgZnJhbWVcclxuICAgICAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UsIHJlamVjdFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChnb3RvRW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmVXaXRoKGVsZW0sIFthbmltYXRpb24sIGdvdG9FbmRdKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3RXaXRoKGVsZW0sIFthbmltYXRpb24sIGdvdG9FbmRdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICBwcm9wcyA9IGFuaW1hdGlvbi5wcm9wcztcclxuXHJcbiAgICAgICAgcHJvcEZpbHRlcihwcm9wcywgYW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZyk7XHJcblxyXG4gICAgICAgIGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICAgICAgICByZXN1bHQgPSBhbmltYXRpb25QcmVmaWx0ZXJzW2luZGV4XS5jYWxsKGFuaW1hdGlvbiwgZWxlbSwgcHJvcHMsIGFuaW1hdGlvbi5vcHRzKTtcclxuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgalF1ZXJ5Lm1hcChwcm9wcywgY3JlYXRlVHdlZW4sIGFuaW1hdGlvbik7XHJcblxyXG4gICAgICAgIGlmIChqUXVlcnkuaXNGdW5jdGlvbihhbmltYXRpb24ub3B0cy5zdGFydCkpIHtcclxuICAgICAgICAgICAgYW5pbWF0aW9uLm9wdHMuc3RhcnQuY2FsbChlbGVtLCBhbmltYXRpb24pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgalF1ZXJ5LmZ4LnRpbWVyKFxyXG4gICAgICAgICAgICBqUXVlcnkuZXh0ZW5kKHRpY2ssIHtcclxuICAgICAgICAgICAgICAgIGVsZW06IGVsZW0sXHJcbiAgICAgICAgICAgICAgICBhbmltOiBhbmltYXRpb24sXHJcbiAgICAgICAgICAgICAgICBxdWV1ZTogYW5pbWF0aW9uLm9wdHMucXVldWVcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICAvLyBhdHRhY2ggY2FsbGJhY2tzIGZyb20gb3B0aW9uc1xyXG4gICAgICAgIHJldHVybiBhbmltYXRpb24ucHJvZ3Jlc3MoYW5pbWF0aW9uLm9wdHMucHJvZ3Jlc3MpXHJcbiAgICAgICAgICAgIC5kb25lKGFuaW1hdGlvbi5vcHRzLmRvbmUsIGFuaW1hdGlvbi5vcHRzLmNvbXBsZXRlKVxyXG4gICAgICAgICAgICAuZmFpbChhbmltYXRpb24ub3B0cy5mYWlsKVxyXG4gICAgICAgICAgICAuYWx3YXlzKGFuaW1hdGlvbi5vcHRzLmFsd2F5cyk7XHJcbiAgICB9XHJcblxyXG4gICAgalF1ZXJ5LkFuaW1hdGlvbiA9IGpRdWVyeS5leHRlbmQoQW5pbWF0aW9uLCB7XHJcblxyXG4gICAgICAgIHR3ZWVuZXI6IGZ1bmN0aW9uKHByb3BzLCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICBpZiAoalF1ZXJ5LmlzRnVuY3Rpb24ocHJvcHMpKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IHByb3BzO1xyXG4gICAgICAgICAgICAgICAgcHJvcHMgPSBbXCIqXCJdO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcHJvcHMgPSBwcm9wcy5zcGxpdChcIiBcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBwcm9wLFxyXG4gICAgICAgICAgICAgICAgaW5kZXggPSAwLFxyXG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgZm9yICg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgICAgICAgICAgICBwcm9wID0gcHJvcHNbaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgdHdlZW5lcnNbcHJvcF0gPSB0d2VlbmVyc1twcm9wXSB8fCBbXTtcclxuICAgICAgICAgICAgICAgIHR3ZWVuZXJzW3Byb3BdLnVuc2hpZnQoY2FsbGJhY2spO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgcHJlZmlsdGVyOiBmdW5jdGlvbihjYWxsYmFjaywgcHJlcGVuZCkge1xyXG4gICAgICAgICAgICBpZiAocHJlcGVuZCkge1xyXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uUHJlZmlsdGVycy51bnNoaWZ0KGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGFuaW1hdGlvblByZWZpbHRlcnMucHVzaChjYWxsYmFjayk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBqUXVlcnkuc3BlZWQgPSBmdW5jdGlvbihzcGVlZCwgZWFzaW5nLCBmbikge1xyXG4gICAgICAgIHZhciBvcHQgPSBzcGVlZCAmJiB0eXBlb2Ygc3BlZWQgPT09IFwib2JqZWN0XCIgPyBqUXVlcnkuZXh0ZW5kKHt9LCBzcGVlZCkgOiB7XHJcbiAgICAgICAgICAgIGNvbXBsZXRlOiBmbiB8fCAhZm4gJiYgZWFzaW5nIHx8XHJcbiAgICAgICAgICAgICAgICBqUXVlcnkuaXNGdW5jdGlvbihzcGVlZCkgJiYgc3BlZWQsXHJcbiAgICAgICAgICAgIGR1cmF0aW9uOiBzcGVlZCxcclxuICAgICAgICAgICAgZWFzaW5nOiBmbiAmJiBlYXNpbmcgfHwgZWFzaW5nICYmICFqUXVlcnkuaXNGdW5jdGlvbihlYXNpbmcpICYmIGVhc2luZ1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5vZmYgPyAwIDogdHlwZW9mIG9wdC5kdXJhdGlvbiA9PT0gXCJudW1iZXJcIiA/IG9wdC5kdXJhdGlvbiA6XHJcbiAgICAgICAgICAgIG9wdC5kdXJhdGlvbiBpbiBqUXVlcnkuZnguc3BlZWRzID8galF1ZXJ5LmZ4LnNwZWVkc1tvcHQuZHVyYXRpb25dIDogalF1ZXJ5LmZ4LnNwZWVkcy5fZGVmYXVsdDtcclxuXHJcbiAgICAgICAgLy8gbm9ybWFsaXplIG9wdC5xdWV1ZSAtIHRydWUvdW5kZWZpbmVkL251bGwgLT4gXCJmeFwiXHJcbiAgICAgICAgaWYgKG9wdC5xdWV1ZSA9PSBudWxsIHx8IG9wdC5xdWV1ZSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICBvcHQucXVldWUgPSBcImZ4XCI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBRdWV1ZWluZ1xyXG4gICAgICAgIG9wdC5vbGQgPSBvcHQuY29tcGxldGU7XHJcblxyXG4gICAgICAgIG9wdC5jb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiAoalF1ZXJ5LmlzRnVuY3Rpb24ob3B0Lm9sZCkpIHtcclxuICAgICAgICAgICAgICAgIG9wdC5vbGQuY2FsbCh0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKG9wdC5xdWV1ZSkge1xyXG4gICAgICAgICAgICAgICAgalF1ZXJ5LmRlcXVldWUodGhpcywgb3B0LnF1ZXVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHJldHVybiBvcHQ7XHJcbiAgICB9O1xyXG5cclxuICAgIGpRdWVyeS5mbi5leHRlbmQoe1xyXG4gICAgICAgIGZhZGVUbzogZnVuY3Rpb24oc3BlZWQsIHRvLCBlYXNpbmcsIGNhbGxiYWNrKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBzaG93IGFueSBoaWRkZW4gZWxlbWVudHMgYWZ0ZXIgc2V0dGluZyBvcGFjaXR5IHRvIDBcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKGlzSGlkZGVuKS5jc3MoXCJvcGFjaXR5XCIsIDApLnNob3coKVxyXG5cclxuICAgICAgICAgICAgLy8gYW5pbWF0ZSB0byB0aGUgdmFsdWUgc3BlY2lmaWVkXHJcbiAgICAgICAgICAgIC5lbmQoKS5hbmltYXRlKHsgb3BhY2l0eTogdG8gfSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2spO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYW5pbWF0ZTogZnVuY3Rpb24ocHJvcCwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgdmFyIGVtcHR5ID0galF1ZXJ5LmlzRW1wdHlPYmplY3QocHJvcCksXHJcbiAgICAgICAgICAgICAgICBvcHRhbGwgPSBqUXVlcnkuc3BlZWQoc3BlZWQsIGVhc2luZywgY2FsbGJhY2spLFxyXG4gICAgICAgICAgICAgICAgZG9BbmltYXRpb24gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBPcGVyYXRlIG9uIGEgY29weSBvZiBwcm9wIHNvIHBlci1wcm9wZXJ0eSBlYXNpbmcgd29uJ3QgYmUgbG9zdFxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhbmltID0gQW5pbWF0aW9uKHRoaXMsIGpRdWVyeS5leHRlbmQoe30sIHByb3ApLCBvcHRhbGwpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBFbXB0eSBhbmltYXRpb25zLCBvciBmaW5pc2hpbmcgcmVzb2x2ZXMgaW1tZWRpYXRlbHlcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZW1wdHkgfHwgZGF0YV9wcml2LmdldCh0aGlzLCBcImZpbmlzaFwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmltLnN0b3AodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgZG9BbmltYXRpb24uZmluaXNoID0gZG9BbmltYXRpb247XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZW1wdHkgfHwgb3B0YWxsLnF1ZXVlID09PSBmYWxzZSA/XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVhY2goZG9BbmltYXRpb24pIDpcclxuICAgICAgICAgICAgICAgIHRoaXMucXVldWUob3B0YWxsLnF1ZXVlLCBkb0FuaW1hdGlvbik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzdG9wOiBmdW5jdGlvbih0eXBlLCBjbGVhclF1ZXVlLCBnb3RvRW5kKSB7XHJcbiAgICAgICAgICAgIHZhciBzdG9wUXVldWUgPSBmdW5jdGlvbihob29rcykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0b3AgPSBob29rcy5zdG9wO1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIGhvb2tzLnN0b3A7XHJcbiAgICAgICAgICAgICAgICBzdG9wKGdvdG9FbmQpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgICAgICBnb3RvRW5kID0gY2xlYXJRdWV1ZTtcclxuICAgICAgICAgICAgICAgIGNsZWFyUXVldWUgPSB0eXBlO1xyXG4gICAgICAgICAgICAgICAgdHlwZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY2xlYXJRdWV1ZSAmJiB0eXBlICE9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5xdWV1ZSh0eXBlIHx8IFwiZnhcIiwgW10pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRlcXVldWUgPSB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gdHlwZSAhPSBudWxsICYmIHR5cGUgKyBcInF1ZXVlSG9va3NcIixcclxuICAgICAgICAgICAgICAgICAgICB0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhX3ByaXYuZ2V0KHRoaXMpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhW2luZGV4XSAmJiBkYXRhW2luZGV4XS5zdG9wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3BRdWV1ZShkYXRhW2luZGV4XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGluZGV4IGluIGRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFbaW5kZXhdICYmIGRhdGFbaW5kZXhdLnN0b3AgJiYgcnJ1bi50ZXN0KGluZGV4KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcFF1ZXVlKGRhdGFbaW5kZXhdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGluZGV4ID0gdGltZXJzLmxlbmd0aDsgaW5kZXgtLTspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGltZXJzW2luZGV4XS5lbGVtID09PSB0aGlzICYmICh0eXBlID09IG51bGwgfHwgdGltZXJzW2luZGV4XS5xdWV1ZSA9PT0gdHlwZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZXJzW2luZGV4XS5hbmltLnN0b3AoZ290b0VuZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcXVldWUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZXJzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIHN0YXJ0IHRoZSBuZXh0IGluIHRoZSBxdWV1ZSBpZiB0aGUgbGFzdCBzdGVwIHdhc24ndCBmb3JjZWRcclxuICAgICAgICAgICAgICAgIC8vIHRpbWVycyBjdXJyZW50bHkgd2lsbCBjYWxsIHRoZWlyIGNvbXBsZXRlIGNhbGxiYWNrcywgd2hpY2ggd2lsbCBkZXF1ZXVlXHJcbiAgICAgICAgICAgICAgICAvLyBidXQgb25seSBpZiB0aGV5IHdlcmUgZ290b0VuZFxyXG4gICAgICAgICAgICAgICAgaWYgKGRlcXVldWUgfHwgIWdvdG9FbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZGVxdWV1ZSh0aGlzLCB0eXBlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBmaW5pc2g6IGZ1bmN0aW9uKHR5cGUpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGUgIT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICB0eXBlID0gdHlwZSB8fCBcImZ4XCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpbmRleCxcclxuICAgICAgICAgICAgICAgICAgICBkYXRhID0gZGF0YV9wcml2LmdldCh0aGlzKSxcclxuICAgICAgICAgICAgICAgICAgICBxdWV1ZSA9IGRhdGFbdHlwZSArIFwicXVldWVcIl0sXHJcbiAgICAgICAgICAgICAgICAgICAgaG9va3MgPSBkYXRhW3R5cGUgKyBcInF1ZXVlSG9va3NcIl0sXHJcbiAgICAgICAgICAgICAgICAgICAgdGltZXJzID0galF1ZXJ5LnRpbWVycyxcclxuICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSBxdWV1ZSA/IHF1ZXVlLmxlbmd0aCA6IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gZW5hYmxlIGZpbmlzaGluZyBmbGFnIG9uIHByaXZhdGUgZGF0YVxyXG4gICAgICAgICAgICAgICAgZGF0YS5maW5pc2ggPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGVtcHR5IHRoZSBxdWV1ZSBmaXJzdFxyXG4gICAgICAgICAgICAgICAgalF1ZXJ5LnF1ZXVlKHRoaXMsIHR5cGUsIFtdKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoaG9va3MgJiYgaG9va3Muc3RvcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGhvb2tzLnN0b3AuY2FsbCh0aGlzLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBsb29rIGZvciBhbnkgYWN0aXZlIGFuaW1hdGlvbnMsIGFuZCBmaW5pc2ggdGhlbVxyXG4gICAgICAgICAgICAgICAgZm9yIChpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVyc1tpbmRleF0uZWxlbSA9PT0gdGhpcyAmJiB0aW1lcnNbaW5kZXhdLnF1ZXVlID09PSB0eXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVyc1tpbmRleF0uYW5pbS5zdG9wKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lcnMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gbG9vayBmb3IgYW55IGFuaW1hdGlvbnMgaW4gdGhlIG9sZCBxdWV1ZSBhbmQgZmluaXNoIHRoZW1cclxuICAgICAgICAgICAgICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChxdWV1ZVtpbmRleF0gJiYgcXVldWVbaW5kZXhdLmZpbmlzaCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZVtpbmRleF0uZmluaXNoLmNhbGwodGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIHR1cm4gb2ZmIGZpbmlzaGluZyBmbGFnXHJcbiAgICAgICAgICAgICAgICBkZWxldGUgZGF0YS5maW5pc2g7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGpRdWVyeS5lYWNoKFtcInRvZ2dsZVwiLCBcInNob3dcIiwgXCJoaWRlXCJdLCBmdW5jdGlvbihpLCBuYW1lKSB7XHJcbiAgICAgICAgdmFyIGNzc0ZuID0galF1ZXJ5LmZuW25hbWVdO1xyXG4gICAgICAgIGpRdWVyeS5mbltuYW1lXSA9IGZ1bmN0aW9uKHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzcGVlZCA9PSBudWxsIHx8IHR5cGVvZiBzcGVlZCA9PT0gXCJib29sZWFuXCIgP1xyXG4gICAgICAgICAgICAgICAgY3NzRm4uYXBwbHkodGhpcywgYXJndW1lbnRzKSA6XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGUoZ2VuRngobmFtZSwgdHJ1ZSksIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrKTtcclxuICAgICAgICB9O1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gR2VuZXJhdGUgc2hvcnRjdXRzIGZvciBjdXN0b20gYW5pbWF0aW9uc1xyXG4gICAgalF1ZXJ5LmVhY2goe1xyXG4gICAgICAgIHNsaWRlRG93bjogZ2VuRngoXCJzaG93XCIpLFxyXG4gICAgICAgIHNsaWRlVXA6IGdlbkZ4KFwiaGlkZVwiKSxcclxuICAgICAgICBzbGlkZVRvZ2dsZTogZ2VuRngoXCJ0b2dnbGVcIiksXHJcbiAgICAgICAgZmFkZUluOiB7IG9wYWNpdHk6IFwic2hvd1wiIH0sXHJcbiAgICAgICAgZmFkZU91dDogeyBvcGFjaXR5OiBcImhpZGVcIiB9LFxyXG4gICAgICAgIGZhZGVUb2dnbGU6IHsgb3BhY2l0eTogXCJ0b2dnbGVcIiB9XHJcbiAgICB9LCBmdW5jdGlvbihuYW1lLCBwcm9wcykge1xyXG4gICAgICAgIGpRdWVyeS5mbltuYW1lXSA9IGZ1bmN0aW9uKHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFuaW1hdGUocHJvcHMsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrKTtcclxuICAgICAgICB9O1xyXG4gICAgfSk7XHJcblxyXG4gICAgalF1ZXJ5LnRpbWVycyA9IFtdO1xyXG4gICAgalF1ZXJ5LmZ4LnRpY2sgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgdGltZXIsXHJcbiAgICAgICAgICAgIGkgPSAwLFxyXG4gICAgICAgICAgICB0aW1lcnMgPSBqUXVlcnkudGltZXJzO1xyXG5cclxuICAgICAgICBmeE5vdyA9IGpRdWVyeS5ub3coKTtcclxuXHJcbiAgICAgICAgZm9yICg7IGkgPCB0aW1lcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGltZXIgPSB0aW1lcnNbaV07XHJcbiAgICAgICAgICAgIC8vIENoZWNrcyB0aGUgdGltZXIgaGFzIG5vdCBhbHJlYWR5IGJlZW4gcmVtb3ZlZFxyXG4gICAgICAgICAgICBpZiAoIXRpbWVyKCkgJiYgdGltZXJzW2ldID09PSB0aW1lcikge1xyXG4gICAgICAgICAgICAgICAgdGltZXJzLnNwbGljZShpLS0sIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIXRpbWVycy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgalF1ZXJ5LmZ4LnN0b3AoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnhOb3cgPSB1bmRlZmluZWQ7XHJcbiAgICB9O1xyXG5cclxuICAgIGpRdWVyeS5meC50aW1lciA9IGZ1bmN0aW9uKHRpbWVyKSB7XHJcbiAgICAgICAgalF1ZXJ5LnRpbWVycy5wdXNoKHRpbWVyKTtcclxuICAgICAgICBpZiAodGltZXIoKSkge1xyXG4gICAgICAgICAgICBqUXVlcnkuZnguc3RhcnQoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBqUXVlcnkudGltZXJzLnBvcCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgalF1ZXJ5LmZ4LmludGVydmFsID0gMTM7XHJcblxyXG4gICAgalF1ZXJ5LmZ4LnN0YXJ0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKCF0aW1lcklkKSB7XHJcbiAgICAgICAgICAgIHRpbWVySWQgPSBzZXRJbnRlcnZhbChqUXVlcnkuZngudGljaywgalF1ZXJ5LmZ4LmludGVydmFsKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGpRdWVyeS5meC5zdG9wID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aW1lcklkKTtcclxuICAgICAgICB0aW1lcklkID0gbnVsbDtcclxuICAgIH07XHJcblxyXG4gICAgalF1ZXJ5LmZ4LnNwZWVkcyA9IHtcclxuICAgICAgICBzbG93OiA2MDAsXHJcbiAgICAgICAgZmFzdDogMjAwLFxyXG4gICAgICAgIC8vIERlZmF1bHQgc3BlZWRcclxuICAgICAgICBfZGVmYXVsdDogNDAwXHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvLyBCYXNlZCBvZmYgb2YgdGhlIHBsdWdpbiBieSBDbGludCBIZWxmZXJzLCB3aXRoIHBlcm1pc3Npb24uXHJcbiAgICAvLyBodHRwOi8vYmxpbmRzaWduYWxzLmNvbS9pbmRleC5waHAvMjAwOS8wNy9qcXVlcnktZGVsYXkvXHJcbiAgICBqUXVlcnkuZm4uZGVsYXkgPSBmdW5jdGlvbih0aW1lLCB0eXBlKSB7XHJcbiAgICAgICAgdGltZSA9IGpRdWVyeS5meCA/IGpRdWVyeS5meC5zcGVlZHNbdGltZV0gfHwgdGltZSA6IHRpbWU7XHJcbiAgICAgICAgdHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZSh0eXBlLCBmdW5jdGlvbihuZXh0LCBob29rcykge1xyXG4gICAgICAgICAgICB2YXIgdGltZW91dCA9IHNldFRpbWVvdXQobmV4dCwgdGltZSk7XHJcbiAgICAgICAgICAgIGhvb2tzLnN0b3AgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIChmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIiksXHJcbiAgICAgICAgICAgIHNlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzZWxlY3RcIiksXHJcbiAgICAgICAgICAgIG9wdCA9IHNlbGVjdC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpKTtcclxuXHJcbiAgICAgICAgaW5wdXQudHlwZSA9IFwiY2hlY2tib3hcIjtcclxuXHJcbiAgICAgICAgLy8gU3VwcG9ydDogaU9TIDUuMSwgQW5kcm9pZCA0LngsIEFuZHJvaWQgMi4zXHJcbiAgICAgICAgLy8gQ2hlY2sgdGhlIGRlZmF1bHQgY2hlY2tib3gvcmFkaW8gdmFsdWUgKFwiXCIgb24gb2xkIFdlYktpdDsgXCJvblwiIGVsc2V3aGVyZSlcclxuICAgICAgICBzdXBwb3J0LmNoZWNrT24gPSBpbnB1dC52YWx1ZSAhPT0gXCJcIjtcclxuXHJcbiAgICAgICAgLy8gTXVzdCBhY2Nlc3MgdGhlIHBhcmVudCB0byBtYWtlIGFuIG9wdGlvbiBzZWxlY3QgcHJvcGVybHlcclxuICAgICAgICAvLyBTdXBwb3J0OiBJRTksIElFMTBcclxuICAgICAgICBzdXBwb3J0Lm9wdFNlbGVjdGVkID0gb3B0LnNlbGVjdGVkO1xyXG5cclxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgb3B0aW9ucyBpbnNpZGUgZGlzYWJsZWQgc2VsZWN0cyBhcmVuJ3QgbWFya2VkIGFzIGRpc2FibGVkXHJcbiAgICAgICAgLy8gKFdlYktpdCBtYXJrcyB0aGVtIGFzIGRpc2FibGVkKVxyXG4gICAgICAgIHNlbGVjdC5kaXNhYmxlZCA9IHRydWU7XHJcbiAgICAgICAgc3VwcG9ydC5vcHREaXNhYmxlZCA9ICFvcHQuZGlzYWJsZWQ7XHJcblxyXG4gICAgICAgIC8vIENoZWNrIGlmIGFuIGlucHV0IG1haW50YWlucyBpdHMgdmFsdWUgYWZ0ZXIgYmVjb21pbmcgYSByYWRpb1xyXG4gICAgICAgIC8vIFN1cHBvcnQ6IElFOSwgSUUxMFxyXG4gICAgICAgIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xyXG4gICAgICAgIGlucHV0LnZhbHVlID0gXCJ0XCI7XHJcbiAgICAgICAgaW5wdXQudHlwZSA9IFwicmFkaW9cIjtcclxuICAgICAgICBzdXBwb3J0LnJhZGlvVmFsdWUgPSBpbnB1dC52YWx1ZSA9PT0gXCJ0XCI7XHJcbiAgICB9KSgpO1xyXG5cclxuXHJcbiAgICB2YXIgbm9kZUhvb2ssIGJvb2xIb29rLFxyXG4gICAgICAgIGF0dHJIYW5kbGUgPSBqUXVlcnkuZXhwci5hdHRySGFuZGxlO1xyXG5cclxuICAgIGpRdWVyeS5mbi5leHRlbmQoe1xyXG4gICAgICAgIGF0dHI6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhY2Nlc3ModGhpcywgalF1ZXJ5LmF0dHIsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgcmVtb3ZlQXR0cjogZnVuY3Rpb24obmFtZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgalF1ZXJ5LnJlbW92ZUF0dHIodGhpcywgbmFtZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGpRdWVyeS5leHRlbmQoe1xyXG4gICAgICAgIGF0dHI6IGZ1bmN0aW9uKGVsZW0sIG5hbWUsIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhciBob29rcywgcmV0LFxyXG4gICAgICAgICAgICAgICAgblR5cGUgPSBlbGVtLm5vZGVUeXBlO1xyXG5cclxuICAgICAgICAgICAgLy8gZG9uJ3QgZ2V0L3NldCBhdHRyaWJ1dGVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xyXG4gICAgICAgICAgICBpZiAoIWVsZW0gfHwgblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRmFsbGJhY2sgdG8gcHJvcCB3aGVuIGF0dHJpYnV0ZXMgYXJlIG5vdCBzdXBwb3J0ZWRcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSA9PT0gc3RydW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4galF1ZXJ5LnByb3AoZWxlbSwgbmFtZSwgdmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBBbGwgYXR0cmlidXRlcyBhcmUgbG93ZXJjYXNlXHJcbiAgICAgICAgICAgIC8vIEdyYWIgbmVjZXNzYXJ5IGhvb2sgaWYgb25lIGlzIGRlZmluZWRcclxuICAgICAgICAgICAgaWYgKG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoZWxlbSkpIHtcclxuICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgICAgICBob29rcyA9IGpRdWVyeS5hdHRySG9va3NbbmFtZV0gfHxcclxuICAgICAgICAgICAgICAgICAgICAoalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC50ZXN0KG5hbWUpID8gYm9vbEhvb2sgOiBub2RlSG9vayk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LnJlbW92ZUF0dHIoZWxlbSwgbmFtZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChob29rcyAmJiBcInNldFwiIGluIGhvb2tzICYmIChyZXQgPSBob29rcy5zZXQoZWxlbSwgdmFsdWUsIG5hbWUpKSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZW0uc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlICsgXCJcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfSBlbHNlIGlmIChob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmIChyZXQgPSBob29rcy5nZXQoZWxlbSwgbmFtZSkpICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldCA9IGpRdWVyeS5maW5kLmF0dHIoZWxlbSwgbmFtZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gTm9uLWV4aXN0ZW50IGF0dHJpYnV0ZXMgcmV0dXJuIG51bGwsIHdlIG5vcm1hbGl6ZSB0byB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXQgPT0gbnVsbCA/XHJcbiAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkIDpcclxuICAgICAgICAgICAgICAgICAgICByZXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICByZW1vdmVBdHRyOiBmdW5jdGlvbihlbGVtLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICB2YXIgbmFtZSwgcHJvcE5hbWUsXHJcbiAgICAgICAgICAgICAgICBpID0gMCxcclxuICAgICAgICAgICAgICAgIGF0dHJOYW1lcyA9IHZhbHVlICYmIHZhbHVlLm1hdGNoKHJub3R3aGl0ZSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoYXR0ck5hbWVzICYmIGVsZW0ubm9kZVR5cGUgPT09IDEpIHtcclxuICAgICAgICAgICAgICAgIHdoaWxlICgobmFtZSA9IGF0dHJOYW1lc1tpKytdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb3BOYW1lID0galF1ZXJ5LnByb3BGaXhbbmFtZV0gfHwgbmFtZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQm9vbGVhbiBhdHRyaWJ1dGVzIGdldCBzcGVjaWFsIHRyZWF0bWVudCAoIzEwODcwKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChqUXVlcnkuZXhwci5tYXRjaC5ib29sLnRlc3QobmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2V0IGNvcnJlc3BvbmRpbmcgcHJvcGVydHkgdG8gZmFsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbVtwcm9wTmFtZV0gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGVsZW0ucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgYXR0ckhvb2tzOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IHtcclxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24oZWxlbSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXN1cHBvcnQucmFkaW9WYWx1ZSAmJiB2YWx1ZSA9PT0gXCJyYWRpb1wiICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5ub2RlTmFtZShlbGVtLCBcImlucHV0XCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNldHRpbmcgdGhlIHR5cGUgb24gYSByYWRpbyBidXR0b24gYWZ0ZXIgdGhlIHZhbHVlIHJlc2V0cyB0aGUgdmFsdWUgaW4gSUU2LTlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgdmFsdWUgdG8gZGVmYXVsdCBpbiBjYXNlIHR5cGUgaXMgc2V0IGFmdGVyIHZhbHVlIGR1cmluZyBjcmVhdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gZWxlbS52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS52YWx1ZSA9IHZhbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gSG9va3MgZm9yIGJvb2xlYW4gYXR0cmlidXRlc1xyXG4gICAgYm9vbEhvb2sgPSB7XHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbihlbGVtLCB2YWx1ZSwgbmFtZSkge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgYm9vbGVhbiBhdHRyaWJ1dGVzIHdoZW4gc2V0IHRvIGZhbHNlXHJcbiAgICAgICAgICAgICAgICBqUXVlcnkucmVtb3ZlQXR0cihlbGVtLCBuYW1lKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGVsZW0uc2V0QXR0cmlidXRlKG5hbWUsIG5hbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBuYW1lO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBqUXVlcnkuZWFjaChqUXVlcnkuZXhwci5tYXRjaC5ib29sLnNvdXJjZS5tYXRjaCgvXFx3Ky9nKSwgZnVuY3Rpb24oaSwgbmFtZSkge1xyXG4gICAgICAgIHZhciBnZXR0ZXIgPSBhdHRySGFuZGxlW25hbWVdIHx8IGpRdWVyeS5maW5kLmF0dHI7XHJcblxyXG4gICAgICAgIGF0dHJIYW5kbGVbbmFtZV0gPSBmdW5jdGlvbihlbGVtLCBuYW1lLCBpc1hNTCkge1xyXG4gICAgICAgICAgICB2YXIgcmV0LCBoYW5kbGU7XHJcbiAgICAgICAgICAgIGlmICghaXNYTUwpIHtcclxuICAgICAgICAgICAgICAgIC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3AgYnkgdGVtcG9yYXJpbHkgcmVtb3ZpbmcgdGhpcyBmdW5jdGlvbiBmcm9tIHRoZSBnZXR0ZXJcclxuICAgICAgICAgICAgICAgIGhhbmRsZSA9IGF0dHJIYW5kbGVbbmFtZV07XHJcbiAgICAgICAgICAgICAgICBhdHRySGFuZGxlW25hbWVdID0gcmV0O1xyXG4gICAgICAgICAgICAgICAgcmV0ID0gZ2V0dGVyKGVsZW0sIG5hbWUsIGlzWE1MKSAhPSBudWxsID9cclxuICAgICAgICAgICAgICAgICAgICBuYW1lLnRvTG93ZXJDYXNlKCkgOlxyXG4gICAgICAgICAgICAgICAgICAgIG51bGw7XHJcbiAgICAgICAgICAgICAgICBhdHRySGFuZGxlW25hbWVdID0gaGFuZGxlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXQ7XHJcbiAgICAgICAgfTtcclxuICAgIH0pO1xyXG5cclxuXHJcblxyXG5cclxuICAgIHZhciByZm9jdXNhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaTtcclxuXHJcbiAgICBqUXVlcnkuZm4uZXh0ZW5kKHtcclxuICAgICAgICBwcm9wOiBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYWNjZXNzKHRoaXMsIGpRdWVyeS5wcm9wLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHJlbW92ZVByb3A6IGZ1bmN0aW9uKG5hbWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzW2pRdWVyeS5wcm9wRml4W25hbWVdIHx8IG5hbWVdO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBqUXVlcnkuZXh0ZW5kKHtcclxuICAgICAgICBwcm9wRml4OiB7XHJcbiAgICAgICAgICAgIFwiZm9yXCI6IFwiaHRtbEZvclwiLFxyXG4gICAgICAgICAgICBcImNsYXNzXCI6IFwiY2xhc3NOYW1lXCJcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBwcm9wOiBmdW5jdGlvbihlbGVtLCBuYW1lLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICB2YXIgcmV0LCBob29rcywgbm90eG1sLFxyXG4gICAgICAgICAgICAgICAgblR5cGUgPSBlbGVtLm5vZGVUeXBlO1xyXG5cclxuICAgICAgICAgICAgLy8gZG9uJ3QgZ2V0L3NldCBwcm9wZXJ0aWVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xyXG4gICAgICAgICAgICBpZiAoIWVsZW0gfHwgblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbm90eG1sID0gblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyhlbGVtKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChub3R4bWwpIHtcclxuICAgICAgICAgICAgICAgIC8vIEZpeCBuYW1lIGFuZCBhdHRhY2ggaG9va3NcclxuICAgICAgICAgICAgICAgIG5hbWUgPSBqUXVlcnkucHJvcEZpeFtuYW1lXSB8fCBuYW1lO1xyXG4gICAgICAgICAgICAgICAgaG9va3MgPSBqUXVlcnkucHJvcEhvb2tzW25hbWVdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhvb2tzICYmIFwic2V0XCIgaW4gaG9va3MgJiYgKHJldCA9IGhvb2tzLnNldChlbGVtLCB2YWx1ZSwgbmFtZSkpICE9PSB1bmRlZmluZWQgP1xyXG4gICAgICAgICAgICAgICAgICAgIHJldCA6XHJcbiAgICAgICAgICAgICAgICAgICAgKGVsZW1bbmFtZV0gPSB2YWx1ZSk7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKHJldCA9IGhvb2tzLmdldChlbGVtLCBuYW1lKSkgIT09IG51bGwgP1xyXG4gICAgICAgICAgICAgICAgICAgIHJldCA6XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbVtuYW1lXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHByb3BIb29rczoge1xyXG4gICAgICAgICAgICB0YWJJbmRleDoge1xyXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbihlbGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0uaGFzQXR0cmlidXRlKFwidGFiaW5kZXhcIikgfHwgcmZvY3VzYWJsZS50ZXN0KGVsZW0ubm9kZU5hbWUpIHx8IGVsZW0uaHJlZiA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0udGFiSW5kZXggOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAtMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIFN1cHBvcnQ6IElFOStcclxuICAgIC8vIFNlbGVjdGVkbmVzcyBmb3IgYW4gb3B0aW9uIGluIGFuIG9wdGdyb3VwIGNhbiBiZSBpbmFjY3VyYXRlXHJcbiAgICBpZiAoIXN1cHBvcnQub3B0U2VsZWN0ZWQpIHtcclxuICAgICAgICBqUXVlcnkucHJvcEhvb2tzLnNlbGVjdGVkID0ge1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKGVsZW0pIHtcclxuICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XHJcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50ICYmIHBhcmVudC5wYXJlbnROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBqUXVlcnkuZWFjaChbXHJcbiAgICAgICAgXCJ0YWJJbmRleFwiLFxyXG4gICAgICAgIFwicmVhZE9ubHlcIixcclxuICAgICAgICBcIm1heExlbmd0aFwiLFxyXG4gICAgICAgIFwiY2VsbFNwYWNpbmdcIixcclxuICAgICAgICBcImNlbGxQYWRkaW5nXCIsXHJcbiAgICAgICAgXCJyb3dTcGFuXCIsXHJcbiAgICAgICAgXCJjb2xTcGFuXCIsXHJcbiAgICAgICAgXCJ1c2VNYXBcIixcclxuICAgICAgICBcImZyYW1lQm9yZGVyXCIsXHJcbiAgICAgICAgXCJjb250ZW50RWRpdGFibGVcIlxyXG4gICAgXSwgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgalF1ZXJ5LnByb3BGaXhbdGhpcy50b0xvd2VyQ2FzZSgpXSA9IHRoaXM7XHJcbiAgICB9KTtcclxuXHJcblxyXG5cclxuXHJcbiAgICB2YXIgcmNsYXNzID0gL1tcXHRcXHJcXG5cXGZdL2c7XHJcblxyXG4gICAgalF1ZXJ5LmZuLmV4dGVuZCh7XHJcbiAgICAgICAgYWRkQ2xhc3M6IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGNsYXp6LCBqLCBmaW5hbFZhbHVlLFxyXG4gICAgICAgICAgICAgICAgcHJvY2VlZCA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZSxcclxuICAgICAgICAgICAgICAgIGkgPSAwLFxyXG4gICAgICAgICAgICAgICAgbGVuID0gdGhpcy5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICBpZiAoalF1ZXJ5LmlzRnVuY3Rpb24odmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGopIHtcclxuICAgICAgICAgICAgICAgICAgICBqUXVlcnkodGhpcykuYWRkQ2xhc3ModmFsdWUuY2FsbCh0aGlzLCBqLCB0aGlzLmNsYXNzTmFtZSkpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChwcm9jZWVkKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgZGlzanVuY3Rpb24gaGVyZSBpcyBmb3IgYmV0dGVyIGNvbXByZXNzaWJpbGl0eSAoc2VlIHJlbW92ZUNsYXNzKVxyXG4gICAgICAgICAgICAgICAgY2xhc3NlcyA9ICh2YWx1ZSB8fCBcIlwiKS5tYXRjaChybm90d2hpdGUpIHx8IFtdO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtID0gdGhpc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBjdXIgPSBlbGVtLm5vZGVUeXBlID09PSAxICYmIChlbGVtLmNsYXNzTmFtZSA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChcIiBcIiArIGVsZW0uY2xhc3NOYW1lICsgXCIgXCIpLnJlcGxhY2UocmNsYXNzLCBcIiBcIikgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiBcIlxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaiA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgoY2xhenogPSBjbGFzc2VzW2orK10pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyLmluZGV4T2YoXCIgXCIgKyBjbGF6eiArIFwiIFwiKSA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXIgKz0gY2xhenogKyBcIiBcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxWYWx1ZSA9IGpRdWVyeS50cmltKGN1cik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtLmNsYXNzTmFtZSAhPT0gZmluYWxWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5jbGFzc05hbWUgPSBmaW5hbFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICByZW1vdmVDbGFzczogZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICAgICAgdmFyIGNsYXNzZXMsIGVsZW0sIGN1ciwgY2xhenosIGosIGZpbmFsVmFsdWUsXHJcbiAgICAgICAgICAgICAgICBwcm9jZWVkID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gMCB8fCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUsXHJcbiAgICAgICAgICAgICAgICBpID0gMCxcclxuICAgICAgICAgICAgICAgIGxlbiA9IHRoaXMubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgaWYgKGpRdWVyeS5pc0Z1bmN0aW9uKHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KHRoaXMpLnJlbW92ZUNsYXNzKHZhbHVlLmNhbGwodGhpcywgaiwgdGhpcy5jbGFzc05hbWUpKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwcm9jZWVkKSB7XHJcbiAgICAgICAgICAgICAgICBjbGFzc2VzID0gKHZhbHVlIHx8IFwiXCIpLm1hdGNoKHJub3R3aGl0ZSkgfHwgW107XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZW0gPSB0aGlzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgZXhwcmVzc2lvbiBpcyBoZXJlIGZvciBiZXR0ZXIgY29tcHJlc3NpYmlsaXR5IChzZWUgYWRkQ2xhc3MpXHJcbiAgICAgICAgICAgICAgICAgICAgY3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoZWxlbS5jbGFzc05hbWUgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAoXCIgXCIgKyBlbGVtLmNsYXNzTmFtZSArIFwiIFwiKS5yZXBsYWNlKHJjbGFzcywgXCIgXCIpIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCJcIlxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaiA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgoY2xhenogPSBjbGFzc2VzW2orK10pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgKmFsbCogaW5zdGFuY2VzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY3VyLmluZGV4T2YoXCIgXCIgKyBjbGF6eiArIFwiIFwiKSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyID0gY3VyLnJlcGxhY2UoXCIgXCIgKyBjbGF6eiArIFwiIFwiLCBcIiBcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsVmFsdWUgPSB2YWx1ZSA/IGpRdWVyeS50cmltKGN1cikgOiBcIlwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbS5jbGFzc05hbWUgIT09IGZpbmFsVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uY2xhc3NOYW1lID0gZmluYWxWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgdG9nZ2xlQ2xhc3M6IGZ1bmN0aW9uKHZhbHVlLCBzdGF0ZVZhbCkge1xyXG4gICAgICAgICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RhdGVWYWwgPT09IFwiYm9vbGVhblwiICYmIHR5cGUgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZVZhbCA/IHRoaXMuYWRkQ2xhc3ModmFsdWUpIDogdGhpcy5yZW1vdmVDbGFzcyh2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChqUXVlcnkuaXNGdW5jdGlvbih2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oaSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeSh0aGlzKS50b2dnbGVDbGFzcyh2YWx1ZS5jYWxsKHRoaXMsIGksIHRoaXMuY2xhc3NOYW1lLCBzdGF0ZVZhbCksIHN0YXRlVmFsKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyB0b2dnbGUgaW5kaXZpZHVhbCBjbGFzcyBuYW1lc1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjbGFzc05hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmID0galF1ZXJ5KHRoaXMpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWVzID0gdmFsdWUubWF0Y2gocm5vdHdoaXRlKSB8fCBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChjbGFzc05hbWUgPSBjbGFzc05hbWVzW2krK10pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGVhY2ggY2xhc3NOYW1lIGdpdmVuLCBzcGFjZSBzZXBhcmF0ZWQgbGlzdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5oYXNDbGFzcyhjbGFzc05hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnJlbW92ZUNsYXNzKGNsYXNzTmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmFkZENsYXNzKGNsYXNzTmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRvZ2dsZSB3aG9sZSBjbGFzcyBuYW1lXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IHN0cnVuZGVmaW5lZCB8fCB0eXBlID09PSBcImJvb2xlYW5cIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNsYXNzTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzdG9yZSBjbGFzc05hbWUgaWYgc2V0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFfcHJpdi5zZXQodGhpcywgXCJfX2NsYXNzTmFtZV9fXCIsIHRoaXMuY2xhc3NOYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBlbGVtZW50IGhhcyBhIGNsYXNzIG5hbWUgb3IgaWYgd2UncmUgcGFzc2VkIFwiZmFsc2VcIixcclxuICAgICAgICAgICAgICAgICAgICAvLyB0aGVuIHJlbW92ZSB0aGUgd2hvbGUgY2xhc3NuYW1lIChpZiB0aGVyZSB3YXMgb25lLCB0aGUgYWJvdmUgc2F2ZWQgaXQpLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSBicmluZyBiYWNrIHdoYXRldmVyIHdhcyBwcmV2aW91c2x5IHNhdmVkIChpZiBhbnl0aGluZyksXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZmFsbGluZyBiYWNrIHRvIHRoZSBlbXB0eSBzdHJpbmcgaWYgbm90aGluZyB3YXMgc3RvcmVkLlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gdGhpcy5jbGFzc05hbWUgfHwgdmFsdWUgPT09IGZhbHNlID8gXCJcIiA6IGRhdGFfcHJpdi5nZXQodGhpcywgXCJfX2NsYXNzTmFtZV9fXCIpIHx8IFwiXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGhhc0NsYXNzOiBmdW5jdGlvbihzZWxlY3Rvcikge1xyXG4gICAgICAgICAgICB2YXIgY2xhc3NOYW1lID0gXCIgXCIgKyBzZWxlY3RvciArIFwiIFwiLFxyXG4gICAgICAgICAgICAgICAgaSA9IDAsXHJcbiAgICAgICAgICAgICAgICBsID0gdGhpcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpc1tpXS5ub2RlVHlwZSA9PT0gMSAmJiAoXCIgXCIgKyB0aGlzW2ldLmNsYXNzTmFtZSArIFwiIFwiKS5yZXBsYWNlKHJjbGFzcywgXCIgXCIpLmluZGV4T2YoY2xhc3NOYW1lKSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcblxyXG5cclxuXHJcbiAgICB2YXIgcnJldHVybiA9IC9cXHIvZztcclxuXHJcbiAgICBqUXVlcnkuZm4uZXh0ZW5kKHtcclxuICAgICAgICB2YWw6IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhciBob29rcywgcmV0LCBpc0Z1bmN0aW9uLFxyXG4gICAgICAgICAgICAgICAgZWxlbSA9IHRoaXNbMF07XHJcblxyXG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlbGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaG9va3MgPSBqUXVlcnkudmFsSG9va3NbZWxlbS50eXBlXSB8fCBqUXVlcnkudmFsSG9va3NbZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKHJldCA9IGhvb2tzLmdldChlbGVtLCBcInZhbHVlXCIpKSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXQgPSBlbGVtLnZhbHVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIHJldCA9PT0gXCJzdHJpbmdcIiA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBtb3N0IGNvbW1vbiBzdHJpbmcgY2FzZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0LnJlcGxhY2UocnJldHVybiwgXCJcIikgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBoYW5kbGUgY2FzZXMgd2hlcmUgdmFsdWUgaXMgbnVsbC91bmRlZiBvciBudW1iZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0ID09IG51bGwgPyBcIlwiIDogcmV0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaXNGdW5jdGlvbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKHZhbHVlKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oaSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHZhbDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ub2RlVHlwZSAhPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IHZhbHVlLmNhbGwodGhpcywgaSwgalF1ZXJ5KHRoaXMpLnZhbCgpKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVHJlYXQgbnVsbC91bmRlZmluZWQgYXMgXCJcIjsgY29udmVydCBudW1iZXJzIHRvIHN0cmluZ1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gXCJcIjtcclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWwgKz0gXCJcIjtcclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGpRdWVyeS5pc0FycmF5KHZhbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWwgPSBqUXVlcnkubWFwKHZhbCwgZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKyBcIlwiO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzW3RoaXMudHlwZV0gfHwgalF1ZXJ5LnZhbEhvb2tzW3RoaXMubm9kZU5hbWUudG9Mb3dlckNhc2UoKV07XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSWYgc2V0IHJldHVybnMgdW5kZWZpbmVkLCBmYWxsIGJhY2sgdG8gbm9ybWFsIHNldHRpbmdcclxuICAgICAgICAgICAgICAgIGlmICghaG9va3MgfHwgIShcInNldFwiIGluIGhvb2tzKSB8fCBob29rcy5zZXQodGhpcywgdmFsLCBcInZhbHVlXCIpID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBqUXVlcnkuZXh0ZW5kKHtcclxuICAgICAgICB2YWxIb29rczoge1xyXG4gICAgICAgICAgICBvcHRpb246IHtcclxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oZWxlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSBqUXVlcnkuZmluZC5hdHRyKGVsZW0sIFwidmFsdWVcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbCAhPSBudWxsID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydDogSUUxMC0xMStcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3B0aW9uLnRleHQgdGhyb3dzIGV4Y2VwdGlvbnMgKCMxNDY4NiwgIzE0ODU4KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkudHJpbShqUXVlcnkudGV4dChlbGVtKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNlbGVjdDoge1xyXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbihlbGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlLCBvcHRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gZWxlbS5zZWxlY3RlZEluZGV4LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbmUgPSBlbGVtLnR5cGUgPT09IFwic2VsZWN0LW9uZVwiIHx8IGluZGV4IDwgMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzID0gb25lID8gbnVsbCA6IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXggPSBvbmUgPyBpbmRleCArIDEgOiBvcHRpb25zLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaSA9IGluZGV4IDwgMCA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heCA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uZSA/IGluZGV4IDogMDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTG9vcCB0aHJvdWdoIGFsbCB0aGUgc2VsZWN0ZWQgb3B0aW9uc1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgbWF4OyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uID0gb3B0aW9uc1tpXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElFNi05IGRvZXNuJ3QgdXBkYXRlIHNlbGVjdGVkIGFmdGVyIGZvcm0gcmVzZXQgKCMyNTUxKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKG9wdGlvbi5zZWxlY3RlZCB8fCBpID09PSBpbmRleCkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvbid0IHJldHVybiBvcHRpb25zIHRoYXQgYXJlIGRpc2FibGVkIG9yIGluIGEgZGlzYWJsZWQgb3B0Z3JvdXBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzdXBwb3J0Lm9wdERpc2FibGVkID8gIW9wdGlvbi5kaXNhYmxlZCA6IG9wdGlvbi5nZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSA9PT0gbnVsbCkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICghb3B0aW9uLnBhcmVudE5vZGUuZGlzYWJsZWQgfHwgIWpRdWVyeS5ub2RlTmFtZShvcHRpb24ucGFyZW50Tm9kZSwgXCJvcHRncm91cFwiKSkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHNwZWNpZmljIHZhbHVlIGZvciB0aGUgb3B0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGpRdWVyeShvcHRpb24pLnZhbCgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IG5lZWQgYW4gYXJyYXkgZm9yIG9uZSBzZWxlY3RzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob25lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE11bHRpLVNlbGVjdHMgcmV0dXJuIGFuIGFycmF5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZXM7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24oZWxlbSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb3B0aW9uU2V0LCBvcHRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcyA9IGpRdWVyeS5tYWtlQXJyYXkodmFsdWUpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gb3B0aW9ucy5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uID0gb3B0aW9uc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChvcHRpb24uc2VsZWN0ZWQgPSBqUXVlcnkuaW5BcnJheShvcHRpb24udmFsdWUsIHZhbHVlcykgPj0gMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvblNldCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGZvcmNlIGJyb3dzZXJzIHRvIGJlaGF2ZSBjb25zaXN0ZW50bHkgd2hlbiBub24tbWF0Y2hpbmcgdmFsdWUgaXMgc2V0XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvcHRpb25TZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5zZWxlY3RlZEluZGV4ID0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZXM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBSYWRpb3MgYW5kIGNoZWNrYm94ZXMgZ2V0dGVyL3NldHRlclxyXG4gICAgalF1ZXJ5LmVhY2goW1wicmFkaW9cIiwgXCJjaGVja2JveFwiXSwgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgalF1ZXJ5LnZhbEhvb2tzW3RoaXNdID0ge1xyXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKGVsZW0sIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoalF1ZXJ5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChlbGVtLmNoZWNrZWQgPSBqUXVlcnkuaW5BcnJheShqUXVlcnkoZWxlbSkudmFsKCksIHZhbHVlKSA+PSAwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKCFzdXBwb3J0LmNoZWNrT24pIHtcclxuICAgICAgICAgICAgalF1ZXJ5LnZhbEhvb2tzW3RoaXNdLmdldCA9IGZ1bmN0aW9uKGVsZW0pIHtcclxuICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IFdlYmtpdFxyXG4gICAgICAgICAgICAgICAgLy8gXCJcIiBpcyByZXR1cm5lZCBpbnN0ZWFkIG9mIFwib25cIiBpZiBhIHZhbHVlIGlzbid0IHNwZWNpZmllZFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKFwidmFsdWVcIikgPT09IG51bGwgPyBcIm9uXCIgOiBlbGVtLnZhbHVlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuXHJcblxyXG5cclxuICAgIC8vIFJldHVybiBqUXVlcnkgZm9yIGF0dHJpYnV0ZXMtb25seSBpbmNsdXNpb25cclxuXHJcblxyXG4gICAgalF1ZXJ5LmVhY2goKFwiYmx1ciBmb2N1cyBmb2N1c2luIGZvY3Vzb3V0IGxvYWQgcmVzaXplIHNjcm9sbCB1bmxvYWQgY2xpY2sgZGJsY2xpY2sgXCIgK1xyXG4gICAgICAgIFwibW91c2Vkb3duIG1vdXNldXAgbW91c2Vtb3ZlIG1vdXNlb3ZlciBtb3VzZW91dCBtb3VzZWVudGVyIG1vdXNlbGVhdmUgXCIgK1xyXG4gICAgICAgIFwiY2hhbmdlIHNlbGVjdCBzdWJtaXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBlcnJvciBjb250ZXh0bWVudVwiKS5zcGxpdChcIiBcIiksIGZ1bmN0aW9uKGksIG5hbWUpIHtcclxuXHJcbiAgICAgICAgLy8gSGFuZGxlIGV2ZW50IGJpbmRpbmdcclxuICAgICAgICBqUXVlcnkuZm5bbmFtZV0gPSBmdW5jdGlvbihkYXRhLCBmbikge1xyXG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDAgP1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vbihuYW1lLCBudWxsLCBkYXRhLCBmbikgOlxyXG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKG5hbWUpO1xyXG4gICAgICAgIH07XHJcbiAgICB9KTtcclxuXHJcbiAgICBqUXVlcnkuZm4uZXh0ZW5kKHtcclxuICAgICAgICBob3ZlcjogZnVuY3Rpb24oZm5PdmVyLCBmbk91dCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tb3VzZWVudGVyKGZuT3ZlcikubW91c2VsZWF2ZShmbk91dCB8fCBmbk92ZXIpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGJpbmQ6IGZ1bmN0aW9uKHR5cGVzLCBkYXRhLCBmbikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vbih0eXBlcywgbnVsbCwgZGF0YSwgZm4pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdW5iaW5kOiBmdW5jdGlvbih0eXBlcywgZm4pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub2ZmKHR5cGVzLCBudWxsLCBmbik7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZGVsZWdhdGU6IGZ1bmN0aW9uKHNlbGVjdG9yLCB0eXBlcywgZGF0YSwgZm4pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub24odHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB1bmRlbGVnYXRlOiBmdW5jdGlvbihzZWxlY3RvciwgdHlwZXMsIGZuKSB7XHJcbiAgICAgICAgICAgIC8vICggbmFtZXNwYWNlICkgb3IgKCBzZWxlY3RvciwgdHlwZXMgWywgZm5dIClcclxuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyB0aGlzLm9mZihzZWxlY3RvciwgXCIqKlwiKSA6IHRoaXMub2ZmKHR5cGVzLCBzZWxlY3RvciB8fCBcIioqXCIsIGZuKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcblxyXG4gICAgdmFyIG5vbmNlID0galF1ZXJ5Lm5vdygpO1xyXG5cclxuICAgIHZhciBycXVlcnkgPSAoL1xcPy8pO1xyXG5cclxuXHJcblxyXG4gICAgLy8gU3VwcG9ydDogQW5kcm9pZCAyLjNcclxuICAgIC8vIFdvcmthcm91bmQgZmFpbHVyZSB0byBzdHJpbmctY2FzdCBudWxsIGlucHV0XHJcbiAgICBqUXVlcnkucGFyc2VKU09OID0gZnVuY3Rpb24oZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKGRhdGEgKyBcIlwiKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8vIENyb3NzLWJyb3dzZXIgeG1sIHBhcnNpbmdcclxuICAgIGpRdWVyeS5wYXJzZVhNTCA9IGZ1bmN0aW9uKGRhdGEpIHtcclxuICAgICAgICB2YXIgeG1sLCB0bXA7XHJcbiAgICAgICAgaWYgKCFkYXRhIHx8IHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU3VwcG9ydDogSUU5XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdG1wID0gbmV3IERPTVBhcnNlcigpO1xyXG4gICAgICAgICAgICB4bWwgPSB0bXAucGFyc2VGcm9tU3RyaW5nKGRhdGEsIFwidGV4dC94bWxcIik7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICB4bWwgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIXhtbCB8fCB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJwYXJzZXJlcnJvclwiKS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgalF1ZXJ5LmVycm9yKFwiSW52YWxpZCBYTUw6IFwiICsgZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB4bWw7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICB2YXJcclxuICAgIC8vIERvY3VtZW50IGxvY2F0aW9uXHJcbiAgICAgICAgYWpheExvY1BhcnRzLFxyXG4gICAgICAgIGFqYXhMb2NhdGlvbixcclxuXHJcbiAgICAgICAgcmhhc2ggPSAvIy4qJC8sXHJcbiAgICAgICAgcnRzID0gLyhbPyZdKV89W14mXSovLFxyXG4gICAgICAgIHJoZWFkZXJzID0gL14oLio/KTpbIFxcdF0qKFteXFxyXFxuXSopJC9tZyxcclxuICAgICAgICAvLyAjNzY1MywgIzgxMjUsICM4MTUyOiBsb2NhbCBwcm90b2NvbCBkZXRlY3Rpb25cclxuICAgICAgICBybG9jYWxQcm90b2NvbCA9IC9eKD86YWJvdXR8YXBwfGFwcC1zdG9yYWdlfC4rLWV4dGVuc2lvbnxmaWxlfHJlc3x3aWRnZXQpOiQvLFxyXG4gICAgICAgIHJub0NvbnRlbnQgPSAvXig/OkdFVHxIRUFEKSQvLFxyXG4gICAgICAgIHJwcm90b2NvbCA9IC9eXFwvXFwvLyxcclxuICAgICAgICBydXJsID0gL14oW1xcdy4rLV0rOikoPzpcXC9cXC8oPzpbXlxcLz8jXSpAfCkoW15cXC8/IzpdKikoPzo6KFxcZCspfCl8KS8sXHJcblxyXG4gICAgICAgIC8qIFByZWZpbHRlcnNcclxuICAgICAgICAgKiAxKSBUaGV5IGFyZSB1c2VmdWwgdG8gaW50cm9kdWNlIGN1c3RvbSBkYXRhVHlwZXMgKHNlZSBhamF4L2pzb25wLmpzIGZvciBhbiBleGFtcGxlKVxyXG4gICAgICAgICAqIDIpIFRoZXNlIGFyZSBjYWxsZWQ6XHJcbiAgICAgICAgICogICAgLSBCRUZPUkUgYXNraW5nIGZvciBhIHRyYW5zcG9ydFxyXG4gICAgICAgICAqICAgIC0gQUZURVIgcGFyYW0gc2VyaWFsaXphdGlvbiAocy5kYXRhIGlzIGEgc3RyaW5nIGlmIHMucHJvY2Vzc0RhdGEgaXMgdHJ1ZSlcclxuICAgICAgICAgKiAzKSBrZXkgaXMgdGhlIGRhdGFUeXBlXHJcbiAgICAgICAgICogNCkgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxyXG4gICAgICAgICAqIDUpIGV4ZWN1dGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGNvbnRpbnVlIGRvd24gdG8gXCIqXCIgaWYgbmVlZGVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcHJlZmlsdGVycyA9IHt9LFxyXG5cclxuICAgICAgICAvKiBUcmFuc3BvcnRzIGJpbmRpbmdzXHJcbiAgICAgICAgICogMSkga2V5IGlzIHRoZSBkYXRhVHlwZVxyXG4gICAgICAgICAqIDIpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcclxuICAgICAgICAgKiAzKSBzZWxlY3Rpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBnbyB0byBcIipcIiBpZiBuZWVkZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICB0cmFuc3BvcnRzID0ge30sXHJcblxyXG4gICAgICAgIC8vIEF2b2lkIGNvbW1lbnQtcHJvbG9nIGNoYXIgc2VxdWVuY2UgKCMxMDA5OCk7IG11c3QgYXBwZWFzZSBsaW50IGFuZCBldmFkZSBjb21wcmVzc2lvblxyXG4gICAgICAgIGFsbFR5cGVzID0gXCIqL1wiLmNvbmNhdChcIipcIik7XHJcblxyXG4gICAgLy8gIzgxMzgsIElFIG1heSB0aHJvdyBhbiBleGNlcHRpb24gd2hlbiBhY2Nlc3NpbmdcclxuICAgIC8vIGEgZmllbGQgZnJvbSB3aW5kb3cubG9jYXRpb24gaWYgZG9jdW1lbnQuZG9tYWluIGhhcyBiZWVuIHNldFxyXG4gICAgdHJ5IHtcclxuICAgICAgICBhamF4TG9jYXRpb24gPSBsb2NhdGlvbi5ocmVmO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIC8vIFVzZSB0aGUgaHJlZiBhdHRyaWJ1dGUgb2YgYW4gQSBlbGVtZW50XHJcbiAgICAgICAgLy8gc2luY2UgSUUgd2lsbCBtb2RpZnkgaXQgZ2l2ZW4gZG9jdW1lbnQubG9jYXRpb25cclxuICAgICAgICBhamF4TG9jYXRpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcclxuICAgICAgICBhamF4TG9jYXRpb24uaHJlZiA9IFwiXCI7XHJcbiAgICAgICAgYWpheExvY2F0aW9uID0gYWpheExvY2F0aW9uLmhyZWY7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU2VnbWVudCBsb2NhdGlvbiBpbnRvIHBhcnRzXHJcbiAgICBhamF4TG9jUGFydHMgPSBydXJsLmV4ZWMoYWpheExvY2F0aW9uLnRvTG93ZXJDYXNlKCkpIHx8IFtdO1xyXG5cclxuICAgIC8vIEJhc2UgXCJjb25zdHJ1Y3RvclwiIGZvciBqUXVlcnkuYWpheFByZWZpbHRlciBhbmQgalF1ZXJ5LmFqYXhUcmFuc3BvcnRcclxuICAgIGZ1bmN0aW9uIGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyhzdHJ1Y3R1cmUpIHtcclxuXHJcbiAgICAgICAgLy8gZGF0YVR5cGVFeHByZXNzaW9uIGlzIG9wdGlvbmFsIGFuZCBkZWZhdWx0cyB0byBcIipcIlxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbihkYXRhVHlwZUV4cHJlc3Npb24sIGZ1bmMpIHtcclxuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YVR5cGVFeHByZXNzaW9uICE9PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgICAgICBmdW5jID0gZGF0YVR5cGVFeHByZXNzaW9uO1xyXG4gICAgICAgICAgICAgICAgZGF0YVR5cGVFeHByZXNzaW9uID0gXCIqXCI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBkYXRhVHlwZSxcclxuICAgICAgICAgICAgICAgIGkgPSAwLFxyXG4gICAgICAgICAgICAgICAgZGF0YVR5cGVzID0gZGF0YVR5cGVFeHByZXNzaW9uLnRvTG93ZXJDYXNlKCkubWF0Y2gocm5vdHdoaXRlKSB8fCBbXTtcclxuXHJcbiAgICAgICAgICAgIGlmIChqUXVlcnkuaXNGdW5jdGlvbihmdW5jKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gRm9yIGVhY2ggZGF0YVR5cGUgaW4gdGhlIGRhdGFUeXBlRXhwcmVzc2lvblxyXG4gICAgICAgICAgICAgICAgd2hpbGUgKChkYXRhVHlwZSA9IGRhdGFUeXBlc1tpKytdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFByZXBlbmQgaWYgcmVxdWVzdGVkXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFUeXBlWzBdID09PSBcIitcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhVHlwZSA9IGRhdGFUeXBlLnNsaWNlKDEpIHx8IFwiKlwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAoc3RydWN0dXJlW2RhdGFUeXBlXSA9IHN0cnVjdHVyZVtkYXRhVHlwZV0gfHwgW10pLnVuc2hpZnQoZnVuYyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UgYXBwZW5kXHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgKHN0cnVjdHVyZVtkYXRhVHlwZV0gPSBzdHJ1Y3R1cmVbZGF0YVR5cGVdIHx8IFtdKS5wdXNoKGZ1bmMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQmFzZSBpbnNwZWN0aW9uIGZ1bmN0aW9uIGZvciBwcmVmaWx0ZXJzIGFuZCB0cmFuc3BvcnRzXHJcbiAgICBmdW5jdGlvbiBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyhzdHJ1Y3R1cmUsIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIpIHtcclxuXHJcbiAgICAgICAgdmFyIGluc3BlY3RlZCA9IHt9LFxyXG4gICAgICAgICAgICBzZWVraW5nVHJhbnNwb3J0ID0gKHN0cnVjdHVyZSA9PT0gdHJhbnNwb3J0cyk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGluc3BlY3QoZGF0YVR5cGUpIHtcclxuICAgICAgICAgICAgdmFyIHNlbGVjdGVkO1xyXG4gICAgICAgICAgICBpbnNwZWN0ZWRbZGF0YVR5cGVdID0gdHJ1ZTtcclxuICAgICAgICAgICAgalF1ZXJ5LmVhY2goc3RydWN0dXJlW2RhdGFUeXBlXSB8fCBbXSwgZnVuY3Rpb24oXywgcHJlZmlsdGVyT3JGYWN0b3J5KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGF0YVR5cGVPclRyYW5zcG9ydCA9IHByZWZpbHRlck9yRmFjdG9yeShvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSKTtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YVR5cGVPclRyYW5zcG9ydCA9PT0gXCJzdHJpbmdcIiAmJiAhc2Vla2luZ1RyYW5zcG9ydCAmJiAhaW5zcGVjdGVkW2RhdGFUeXBlT3JUcmFuc3BvcnRdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhVHlwZXMudW5zaGlmdChkYXRhVHlwZU9yVHJhbnNwb3J0KTtcclxuICAgICAgICAgICAgICAgICAgICBpbnNwZWN0KGRhdGFUeXBlT3JUcmFuc3BvcnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2Vla2luZ1RyYW5zcG9ydCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhKHNlbGVjdGVkID0gZGF0YVR5cGVPclRyYW5zcG9ydCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gc2VsZWN0ZWQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gaW5zcGVjdChvcHRpb25zLmRhdGFUeXBlc1swXSkgfHwgIWluc3BlY3RlZFtcIipcIl0gJiYgaW5zcGVjdChcIipcIik7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQSBzcGVjaWFsIGV4dGVuZCBmb3IgYWpheCBvcHRpb25zXHJcbiAgICAvLyB0aGF0IHRha2VzIFwiZmxhdFwiIG9wdGlvbnMgKG5vdCB0byBiZSBkZWVwIGV4dGVuZGVkKVxyXG4gICAgLy8gRml4ZXMgIzk4ODdcclxuICAgIGZ1bmN0aW9uIGFqYXhFeHRlbmQodGFyZ2V0LCBzcmMpIHtcclxuICAgICAgICB2YXIga2V5LCBkZWVwLFxyXG4gICAgICAgICAgICBmbGF0T3B0aW9ucyA9IGpRdWVyeS5hamF4U2V0dGluZ3MuZmxhdE9wdGlvbnMgfHwge307XHJcblxyXG4gICAgICAgIGZvciAoa2V5IGluIHNyYykge1xyXG4gICAgICAgICAgICBpZiAoc3JjW2tleV0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgKGZsYXRPcHRpb25zW2tleV0gPyB0YXJnZXQgOiAoZGVlcCB8fCAoZGVlcCA9IHt9KSkpW2tleV0gPSBzcmNba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGVlcCkge1xyXG4gICAgICAgICAgICBqUXVlcnkuZXh0ZW5kKHRydWUsIHRhcmdldCwgZGVlcCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qIEhhbmRsZXMgcmVzcG9uc2VzIHRvIGFuIGFqYXggcmVxdWVzdDpcclxuICAgICAqIC0gZmluZHMgdGhlIHJpZ2h0IGRhdGFUeXBlIChtZWRpYXRlcyBiZXR3ZWVuIGNvbnRlbnQtdHlwZSBhbmQgZXhwZWN0ZWQgZGF0YVR5cGUpXHJcbiAgICAgKiAtIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2VcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYWpheEhhbmRsZVJlc3BvbnNlcyhzLCBqcVhIUiwgcmVzcG9uc2VzKSB7XHJcblxyXG4gICAgICAgIHZhciBjdCwgdHlwZSwgZmluYWxEYXRhVHlwZSwgZmlyc3REYXRhVHlwZSxcclxuICAgICAgICAgICAgY29udGVudHMgPSBzLmNvbnRlbnRzLFxyXG4gICAgICAgICAgICBkYXRhVHlwZXMgPSBzLmRhdGFUeXBlcztcclxuXHJcbiAgICAgICAgLy8gUmVtb3ZlIGF1dG8gZGF0YVR5cGUgYW5kIGdldCBjb250ZW50LXR5cGUgaW4gdGhlIHByb2Nlc3NcclxuICAgICAgICB3aGlsZSAoZGF0YVR5cGVzWzBdID09PSBcIipcIikge1xyXG4gICAgICAgICAgICBkYXRhVHlwZXMuc2hpZnQoKTtcclxuICAgICAgICAgICAgaWYgKGN0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGN0ID0gcy5taW1lVHlwZSB8fCBqcVhIUi5nZXRSZXNwb25zZUhlYWRlcihcIkNvbnRlbnQtVHlwZVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgd2UncmUgZGVhbGluZyB3aXRoIGEga25vd24gY29udGVudC10eXBlXHJcbiAgICAgICAgaWYgKGN0KSB7XHJcbiAgICAgICAgICAgIGZvciAodHlwZSBpbiBjb250ZW50cykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRzW3R5cGVdICYmIGNvbnRlbnRzW3R5cGVdLnRlc3QoY3QpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YVR5cGVzLnVuc2hpZnQodHlwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIGEgcmVzcG9uc2UgZm9yIHRoZSBleHBlY3RlZCBkYXRhVHlwZVxyXG4gICAgICAgIGlmIChkYXRhVHlwZXNbMF0gaW4gcmVzcG9uc2VzKSB7XHJcbiAgICAgICAgICAgIGZpbmFsRGF0YVR5cGUgPSBkYXRhVHlwZXNbMF07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gVHJ5IGNvbnZlcnRpYmxlIGRhdGFUeXBlc1xyXG4gICAgICAgICAgICBmb3IgKHR5cGUgaW4gcmVzcG9uc2VzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWRhdGFUeXBlc1swXSB8fCBzLmNvbnZlcnRlcnNbdHlwZSArIFwiIFwiICsgZGF0YVR5cGVzWzBdXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbmFsRGF0YVR5cGUgPSB0eXBlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFmaXJzdERhdGFUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlyc3REYXRhVHlwZSA9IHR5cGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gT3IganVzdCB1c2UgZmlyc3Qgb25lXHJcbiAgICAgICAgICAgIGZpbmFsRGF0YVR5cGUgPSBmaW5hbERhdGFUeXBlIHx8IGZpcnN0RGF0YVR5cGU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJZiB3ZSBmb3VuZCBhIGRhdGFUeXBlXHJcbiAgICAgICAgLy8gV2UgYWRkIHRoZSBkYXRhVHlwZSB0byB0aGUgbGlzdCBpZiBuZWVkZWRcclxuICAgICAgICAvLyBhbmQgcmV0dXJuIHRoZSBjb3JyZXNwb25kaW5nIHJlc3BvbnNlXHJcbiAgICAgICAgaWYgKGZpbmFsRGF0YVR5cGUpIHtcclxuICAgICAgICAgICAgaWYgKGZpbmFsRGF0YVR5cGUgIT09IGRhdGFUeXBlc1swXSkge1xyXG4gICAgICAgICAgICAgICAgZGF0YVR5cGVzLnVuc2hpZnQoZmluYWxEYXRhVHlwZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlc1tmaW5hbERhdGFUeXBlXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyogQ2hhaW4gY29udmVyc2lvbnMgZ2l2ZW4gdGhlIHJlcXVlc3QgYW5kIHRoZSBvcmlnaW5hbCByZXNwb25zZVxyXG4gICAgICogQWxzbyBzZXRzIHRoZSByZXNwb25zZVhYWCBmaWVsZHMgb24gdGhlIGpxWEhSIGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGFqYXhDb252ZXJ0KHMsIHJlc3BvbnNlLCBqcVhIUiwgaXNTdWNjZXNzKSB7XHJcbiAgICAgICAgdmFyIGNvbnYyLCBjdXJyZW50LCBjb252LCB0bXAsIHByZXYsXHJcbiAgICAgICAgICAgIGNvbnZlcnRlcnMgPSB7fSxcclxuICAgICAgICAgICAgLy8gV29yayB3aXRoIGEgY29weSBvZiBkYXRhVHlwZXMgaW4gY2FzZSB3ZSBuZWVkIHRvIG1vZGlmeSBpdCBmb3IgY29udmVyc2lvblxyXG4gICAgICAgICAgICBkYXRhVHlwZXMgPSBzLmRhdGFUeXBlcy5zbGljZSgpO1xyXG5cclxuICAgICAgICAvLyBDcmVhdGUgY29udmVydGVycyBtYXAgd2l0aCBsb3dlcmNhc2VkIGtleXNcclxuICAgICAgICBpZiAoZGF0YVR5cGVzWzFdKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29udiBpbiBzLmNvbnZlcnRlcnMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnZlcnRlcnNbY29udi50b0xvd2VyQ2FzZSgpXSA9IHMuY29udmVydGVyc1tjb252XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xyXG5cclxuICAgICAgICAvLyBDb252ZXJ0IHRvIGVhY2ggc2VxdWVudGlhbCBkYXRhVHlwZVxyXG4gICAgICAgIHdoaWxlIChjdXJyZW50KSB7XHJcblxyXG4gICAgICAgICAgICBpZiAocy5yZXNwb25zZUZpZWxkc1tjdXJyZW50XSkge1xyXG4gICAgICAgICAgICAgICAganFYSFJbcy5yZXNwb25zZUZpZWxkc1tjdXJyZW50XV0gPSByZXNwb25zZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQXBwbHkgdGhlIGRhdGFGaWx0ZXIgaWYgcHJvdmlkZWRcclxuICAgICAgICAgICAgaWYgKCFwcmV2ICYmIGlzU3VjY2VzcyAmJiBzLmRhdGFGaWx0ZXIpIHtcclxuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gcy5kYXRhRmlsdGVyKHJlc3BvbnNlLCBzLmRhdGFUeXBlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcHJldiA9IGN1cnJlbnQ7XHJcbiAgICAgICAgICAgIGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50KSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVGhlcmUncyBvbmx5IHdvcmsgdG8gZG8gaWYgY3VycmVudCBkYXRhVHlwZSBpcyBub24tYXV0b1xyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQgPT09IFwiKlwiKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBwcmV2O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IHJlc3BvbnNlIGlmIHByZXYgZGF0YVR5cGUgaXMgbm9uLWF1dG8gYW5kIGRpZmZlcnMgZnJvbSBjdXJyZW50XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHByZXYgIT09IFwiKlwiICYmIHByZXYgIT09IGN1cnJlbnQpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU2VlayBhIGRpcmVjdCBjb252ZXJ0ZXJcclxuICAgICAgICAgICAgICAgICAgICBjb252ID0gY29udmVydGVyc1twcmV2ICsgXCIgXCIgKyBjdXJyZW50XSB8fCBjb252ZXJ0ZXJzW1wiKiBcIiArIGN1cnJlbnRdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBub25lIGZvdW5kLCBzZWVrIGEgcGFpclxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghY29udikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnYyIGluIGNvbnZlcnRlcnMpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBjb252MiBvdXRwdXRzIGN1cnJlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcCA9IGNvbnYyLnNwbGl0KFwiIFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0bXBbMV0gPT09IGN1cnJlbnQpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgcHJldiBjYW4gYmUgY29udmVydGVkIHRvIGFjY2VwdGVkIGlucHV0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udiA9IGNvbnZlcnRlcnNbcHJldiArIFwiIFwiICsgdG1wWzBdXSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb252ZXJ0ZXJzW1wiKiBcIiArIHRtcFswXV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29uZGVuc2UgZXF1aXZhbGVuY2UgY29udmVydGVyc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udiA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udiA9IGNvbnZlcnRlcnNbY29udjJdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgaW5zZXJ0IHRoZSBpbnRlcm1lZGlhdGUgZGF0YVR5cGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb252ZXJ0ZXJzW2NvbnYyXSAhPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IHRtcFswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFUeXBlcy51bnNoaWZ0KHRtcFsxXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBjb252ZXJ0ZXIgKGlmIG5vdCBhbiBlcXVpdmFsZW5jZSlcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29udiAhPT0gdHJ1ZSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVW5sZXNzIGVycm9ycyBhcmUgYWxsb3dlZCB0byBidWJibGUsIGNhdGNoIGFuZCByZXR1cm4gdGhlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udiAmJiBzW1widGhyb3dzXCJdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IGNvbnYocmVzcG9uc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IGNvbnYocmVzcG9uc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHN0YXRlOiBcInBhcnNlcmVycm9yXCIsIGVycm9yOiBjb252ID8gZSA6IFwiTm8gY29udmVyc2lvbiBmcm9tIFwiICsgcHJldiArIFwiIHRvIFwiICsgY3VycmVudCB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4geyBzdGF0ZTogXCJzdWNjZXNzXCIsIGRhdGE6IHJlc3BvbnNlIH07XHJcbiAgICB9XHJcblxyXG4gICAgalF1ZXJ5LmV4dGVuZCh7XHJcblxyXG4gICAgICAgIC8vIENvdW50ZXIgZm9yIGhvbGRpbmcgdGhlIG51bWJlciBvZiBhY3RpdmUgcXVlcmllc1xyXG4gICAgICAgIGFjdGl2ZTogMCxcclxuXHJcbiAgICAgICAgLy8gTGFzdC1Nb2RpZmllZCBoZWFkZXIgY2FjaGUgZm9yIG5leHQgcmVxdWVzdFxyXG4gICAgICAgIGxhc3RNb2RpZmllZDoge30sXHJcbiAgICAgICAgZXRhZzoge30sXHJcblxyXG4gICAgICAgIGFqYXhTZXR0aW5nczoge1xyXG4gICAgICAgICAgICB1cmw6IGFqYXhMb2NhdGlvbixcclxuICAgICAgICAgICAgdHlwZTogXCJHRVRcIixcclxuICAgICAgICAgICAgaXNMb2NhbDogcmxvY2FsUHJvdG9jb2wudGVzdChhamF4TG9jUGFydHNbMV0pLFxyXG4gICAgICAgICAgICBnbG9iYWw6IHRydWUsXHJcbiAgICAgICAgICAgIHByb2Nlc3NEYXRhOiB0cnVlLFxyXG4gICAgICAgICAgICBhc3luYzogdHJ1ZSxcclxuICAgICAgICAgICAgY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04XCIsXHJcbiAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgIHRpbWVvdXQ6IDAsXHJcbiAgICAgICAgICAgIGRhdGE6IG51bGwsXHJcbiAgICAgICAgICAgIGRhdGFUeXBlOiBudWxsLFxyXG4gICAgICAgICAgICB1c2VybmFtZTogbnVsbCxcclxuICAgICAgICAgICAgcGFzc3dvcmQ6IG51bGwsXHJcbiAgICAgICAgICAgIGNhY2hlOiBudWxsLFxyXG4gICAgICAgICAgICB0aHJvd3M6IGZhbHNlLFxyXG4gICAgICAgICAgICB0cmFkaXRpb25hbDogZmFsc2UsXHJcbiAgICAgICAgICAgIGhlYWRlcnM6IHt9LFxyXG4gICAgICAgICAgICAqL1xyXG5cclxuICAgICAgICAgICAgYWNjZXB0czoge1xyXG4gICAgICAgICAgICAgICAgXCIqXCI6IGFsbFR5cGVzLFxyXG4gICAgICAgICAgICAgICAgdGV4dDogXCJ0ZXh0L3BsYWluXCIsXHJcbiAgICAgICAgICAgICAgICBodG1sOiBcInRleHQvaHRtbFwiLFxyXG4gICAgICAgICAgICAgICAgeG1sOiBcImFwcGxpY2F0aW9uL3htbCwgdGV4dC94bWxcIixcclxuICAgICAgICAgICAgICAgIGpzb246IFwiYXBwbGljYXRpb24vanNvbiwgdGV4dC9qYXZhc2NyaXB0XCJcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIGNvbnRlbnRzOiB7XHJcbiAgICAgICAgICAgICAgICB4bWw6IC94bWwvLFxyXG4gICAgICAgICAgICAgICAgaHRtbDogL2h0bWwvLFxyXG4gICAgICAgICAgICAgICAganNvbjogL2pzb24vXHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICByZXNwb25zZUZpZWxkczoge1xyXG4gICAgICAgICAgICAgICAgeG1sOiBcInJlc3BvbnNlWE1MXCIsXHJcbiAgICAgICAgICAgICAgICB0ZXh0OiBcInJlc3BvbnNlVGV4dFwiLFxyXG4gICAgICAgICAgICAgICAganNvbjogXCJyZXNwb25zZUpTT05cIlxyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgLy8gRGF0YSBjb252ZXJ0ZXJzXHJcbiAgICAgICAgICAgIC8vIEtleXMgc2VwYXJhdGUgc291cmNlIChvciBjYXRjaGFsbCBcIipcIikgYW5kIGRlc3RpbmF0aW9uIHR5cGVzIHdpdGggYSBzaW5nbGUgc3BhY2VcclxuICAgICAgICAgICAgY29udmVydGVyczoge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgYW55dGhpbmcgdG8gdGV4dFxyXG4gICAgICAgICAgICAgICAgXCIqIHRleHRcIjogU3RyaW5nLFxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFRleHQgdG8gaHRtbCAodHJ1ZSA9IG5vIHRyYW5zZm9ybWF0aW9uKVxyXG4gICAgICAgICAgICAgICAgXCJ0ZXh0IGh0bWxcIjogdHJ1ZSxcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBFdmFsdWF0ZSB0ZXh0IGFzIGEganNvbiBleHByZXNzaW9uXHJcbiAgICAgICAgICAgICAgICBcInRleHQganNvblwiOiBqUXVlcnkucGFyc2VKU09OLFxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRleHQgYXMgeG1sXHJcbiAgICAgICAgICAgICAgICBcInRleHQgeG1sXCI6IGpRdWVyeS5wYXJzZVhNTFxyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgLy8gRm9yIG9wdGlvbnMgdGhhdCBzaG91bGRuJ3QgYmUgZGVlcCBleHRlbmRlZDpcclxuICAgICAgICAgICAgLy8geW91IGNhbiBhZGQgeW91ciBvd24gY3VzdG9tIG9wdGlvbnMgaGVyZSBpZlxyXG4gICAgICAgICAgICAvLyBhbmQgd2hlbiB5b3UgY3JlYXRlIG9uZSB0aGF0IHNob3VsZG4ndCBiZVxyXG4gICAgICAgICAgICAvLyBkZWVwIGV4dGVuZGVkIChzZWUgYWpheEV4dGVuZClcclxuICAgICAgICAgICAgZmxhdE9wdGlvbnM6IHtcclxuICAgICAgICAgICAgICAgIHVybDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHRydWVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8vIENyZWF0ZXMgYSBmdWxsIGZsZWRnZWQgc2V0dGluZ3Mgb2JqZWN0IGludG8gdGFyZ2V0XHJcbiAgICAgICAgLy8gd2l0aCBib3RoIGFqYXhTZXR0aW5ncyBhbmQgc2V0dGluZ3MgZmllbGRzLlxyXG4gICAgICAgIC8vIElmIHRhcmdldCBpcyBvbWl0dGVkLCB3cml0ZXMgaW50byBhamF4U2V0dGluZ3MuXHJcbiAgICAgICAgYWpheFNldHVwOiBmdW5jdGlvbih0YXJnZXQsIHNldHRpbmdzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzZXR0aW5ncyA/XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQnVpbGRpbmcgYSBzZXR0aW5ncyBvYmplY3RcclxuICAgICAgICAgICAgICAgIGFqYXhFeHRlbmQoYWpheEV4dGVuZCh0YXJnZXQsIGpRdWVyeS5hamF4U2V0dGluZ3MpLCBzZXR0aW5ncykgOlxyXG5cclxuICAgICAgICAgICAgICAgIC8vIEV4dGVuZGluZyBhamF4U2V0dGluZ3NcclxuICAgICAgICAgICAgICAgIGFqYXhFeHRlbmQoalF1ZXJ5LmFqYXhTZXR0aW5ncywgdGFyZ2V0KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBhamF4UHJlZmlsdGVyOiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMocHJlZmlsdGVycyksXHJcbiAgICAgICAgYWpheFRyYW5zcG9ydDogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKHRyYW5zcG9ydHMpLFxyXG5cclxuICAgICAgICAvLyBNYWluIG1ldGhvZFxyXG4gICAgICAgIGFqYXg6IGZ1bmN0aW9uKHVybCwgb3B0aW9ucykge1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgdXJsIGlzIGFuIG9iamVjdCwgc2ltdWxhdGUgcHJlLTEuNSBzaWduYXR1cmVcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB1cmwgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB1cmw7XHJcbiAgICAgICAgICAgICAgICB1cmwgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEZvcmNlIG9wdGlvbnMgdG8gYmUgYW4gb2JqZWN0XHJcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuICAgICAgICAgICAgdmFyIHRyYW5zcG9ydCxcclxuICAgICAgICAgICAgICAgIC8vIFVSTCB3aXRob3V0IGFudGktY2FjaGUgcGFyYW1cclxuICAgICAgICAgICAgICAgIGNhY2hlVVJMLFxyXG4gICAgICAgICAgICAgICAgLy8gUmVzcG9uc2UgaGVhZGVyc1xyXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VIZWFkZXJzU3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VIZWFkZXJzLFxyXG4gICAgICAgICAgICAgICAgLy8gdGltZW91dCBoYW5kbGVcclxuICAgICAgICAgICAgICAgIHRpbWVvdXRUaW1lcixcclxuICAgICAgICAgICAgICAgIC8vIENyb3NzLWRvbWFpbiBkZXRlY3Rpb24gdmFyc1xyXG4gICAgICAgICAgICAgICAgcGFydHMsXHJcbiAgICAgICAgICAgICAgICAvLyBUbyBrbm93IGlmIGdsb2JhbCBldmVudHMgYXJlIHRvIGJlIGRpc3BhdGNoZWRcclxuICAgICAgICAgICAgICAgIGZpcmVHbG9iYWxzLFxyXG4gICAgICAgICAgICAgICAgLy8gTG9vcCB2YXJpYWJsZVxyXG4gICAgICAgICAgICAgICAgaSxcclxuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSB0aGUgZmluYWwgb3B0aW9ucyBvYmplY3RcclxuICAgICAgICAgICAgICAgIHMgPSBqUXVlcnkuYWpheFNldHVwKHt9LCBvcHRpb25zKSxcclxuICAgICAgICAgICAgICAgIC8vIENhbGxiYWNrcyBjb250ZXh0XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFja0NvbnRleHQgPSBzLmNvbnRleHQgfHwgcyxcclxuICAgICAgICAgICAgICAgIC8vIENvbnRleHQgZm9yIGdsb2JhbCBldmVudHMgaXMgY2FsbGJhY2tDb250ZXh0IGlmIGl0IGlzIGEgRE9NIG5vZGUgb3IgalF1ZXJ5IGNvbGxlY3Rpb25cclxuICAgICAgICAgICAgICAgIGdsb2JhbEV2ZW50Q29udGV4dCA9IHMuY29udGV4dCAmJiAoY2FsbGJhY2tDb250ZXh0Lm5vZGVUeXBlIHx8IGNhbGxiYWNrQ29udGV4dC5qcXVlcnkpID9cclxuICAgICAgICAgICAgICAgIGpRdWVyeShjYWxsYmFja0NvbnRleHQpIDpcclxuICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudCxcclxuICAgICAgICAgICAgICAgIC8vIERlZmVycmVkc1xyXG4gICAgICAgICAgICAgICAgZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKSxcclxuICAgICAgICAgICAgICAgIGNvbXBsZXRlRGVmZXJyZWQgPSBqUXVlcnkuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIiksXHJcbiAgICAgICAgICAgICAgICAvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xyXG4gICAgICAgICAgICAgICAgc3RhdHVzQ29kZSA9IHMuc3RhdHVzQ29kZSB8fCB7fSxcclxuICAgICAgICAgICAgICAgIC8vIEhlYWRlcnMgKHRoZXkgYXJlIHNlbnQgYWxsIGF0IG9uY2UpXHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0SGVhZGVycyA9IHt9LFxyXG4gICAgICAgICAgICAgICAgcmVxdWVzdEhlYWRlcnNOYW1lcyA9IHt9LFxyXG4gICAgICAgICAgICAgICAgLy8gVGhlIGpxWEhSIHN0YXRlXHJcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IDAsXHJcbiAgICAgICAgICAgICAgICAvLyBEZWZhdWx0IGFib3J0IG1lc3NhZ2VcclxuICAgICAgICAgICAgICAgIHN0ckFib3J0ID0gXCJjYW5jZWxlZFwiLFxyXG4gICAgICAgICAgICAgICAgLy8gRmFrZSB4aHJcclxuICAgICAgICAgICAgICAgIGpxWEhSID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlYWR5U3RhdGU6IDAsXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEJ1aWxkcyBoZWFkZXJzIGhhc2h0YWJsZSBpZiBuZWVkZWRcclxuICAgICAgICAgICAgICAgICAgICBnZXRSZXNwb25zZUhlYWRlcjogZnVuY3Rpb24oa2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXRjaDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlID09PSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc3BvbnNlSGVhZGVycykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlSGVhZGVycyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgobWF0Y2ggPSByaGVhZGVycy5leGVjKHJlc3BvbnNlSGVhZGVyc1N0cmluZykpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlSGVhZGVyc1ttYXRjaFsxXS50b0xvd2VyQ2FzZSgpXSA9IG1hdGNoWzJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoID0gcmVzcG9uc2VIZWFkZXJzW2tleS50b0xvd2VyQ2FzZSgpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2ggPT0gbnVsbCA/IG51bGwgOiBtYXRjaDtcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBSYXcgc3RyaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgZ2V0QWxsUmVzcG9uc2VIZWFkZXJzOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlID09PSAyID8gcmVzcG9uc2VIZWFkZXJzU3RyaW5nIDogbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBDYWNoZXMgdGhlIGhlYWRlclxyXG4gICAgICAgICAgICAgICAgICAgIHNldFJlcXVlc3RIZWFkZXI6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IHJlcXVlc3RIZWFkZXJzTmFtZXNbbG5hbWVdID0gcmVxdWVzdEhlYWRlcnNOYW1lc1tsbmFtZV0gfHwgbmFtZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RIZWFkZXJzW25hbWVdID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gT3ZlcnJpZGVzIHJlc3BvbnNlIGNvbnRlbnQtdHlwZSBoZWFkZXJcclxuICAgICAgICAgICAgICAgICAgICBvdmVycmlkZU1pbWVUeXBlOiBmdW5jdGlvbih0eXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc3RhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMubWltZVR5cGUgPSB0eXBlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzQ29kZTogZnVuY3Rpb24obWFwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUgPCAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb2RlIGluIG1hcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMYXp5LWFkZCB0aGUgbmV3IGNhbGxiYWNrIGluIGEgd2F5IHRoYXQgcHJlc2VydmVzIG9sZCBvbmVzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1c0NvZGVbY29kZV0gPSBbc3RhdHVzQ29kZVtjb2RlXSwgbWFwW2NvZGVdXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4ZWN1dGUgdGhlIGFwcHJvcHJpYXRlIGNhbGxiYWNrc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpxWEhSLmFsd2F5cyhtYXBbanFYSFIuc3RhdHVzXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FuY2VsIHRoZSByZXF1ZXN0XHJcbiAgICAgICAgICAgICAgICAgICAgYWJvcnQ6IGZ1bmN0aW9uKHN0YXR1c1RleHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpbmFsVGV4dCA9IHN0YXR1c1RleHQgfHwgc3RyQWJvcnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0cmFuc3BvcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5hYm9ydChmaW5hbFRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoMCwgZmluYWxUZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8vIEF0dGFjaCBkZWZlcnJlZHNcclxuICAgICAgICAgICAgZGVmZXJyZWQucHJvbWlzZShqcVhIUikuY29tcGxldGUgPSBjb21wbGV0ZURlZmVycmVkLmFkZDtcclxuICAgICAgICAgICAganFYSFIuc3VjY2VzcyA9IGpxWEhSLmRvbmU7XHJcbiAgICAgICAgICAgIGpxWEhSLmVycm9yID0ganFYSFIuZmFpbDtcclxuXHJcbiAgICAgICAgICAgIC8vIFJlbW92ZSBoYXNoIGNoYXJhY3RlciAoIzc1MzE6IGFuZCBzdHJpbmcgcHJvbW90aW9uKVxyXG4gICAgICAgICAgICAvLyBBZGQgcHJvdG9jb2wgaWYgbm90IHByb3ZpZGVkIChwcmVmaWx0ZXJzIG1pZ2h0IGV4cGVjdCBpdClcclxuICAgICAgICAgICAgLy8gSGFuZGxlIGZhbHN5IHVybCBpbiB0aGUgc2V0dGluZ3Mgb2JqZWN0ICgjMTAwOTM6IGNvbnNpc3RlbmN5IHdpdGggb2xkIHNpZ25hdHVyZSlcclxuICAgICAgICAgICAgLy8gV2UgYWxzbyB1c2UgdGhlIHVybCBwYXJhbWV0ZXIgaWYgYXZhaWxhYmxlXHJcbiAgICAgICAgICAgIHMudXJsID0gKCh1cmwgfHwgcy51cmwgfHwgYWpheExvY2F0aW9uKSArIFwiXCIpLnJlcGxhY2Uocmhhc2gsIFwiXCIpXHJcbiAgICAgICAgICAgICAgICAucmVwbGFjZShycHJvdG9jb2wsIGFqYXhMb2NQYXJ0c1sxXSArIFwiLy9cIik7XHJcblxyXG4gICAgICAgICAgICAvLyBBbGlhcyBtZXRob2Qgb3B0aW9uIHRvIHR5cGUgYXMgcGVyIHRpY2tldCAjMTIwMDRcclxuICAgICAgICAgICAgcy50eXBlID0gb3B0aW9ucy5tZXRob2QgfHwgb3B0aW9ucy50eXBlIHx8IHMubWV0aG9kIHx8IHMudHlwZTtcclxuXHJcbiAgICAgICAgICAgIC8vIEV4dHJhY3QgZGF0YVR5cGVzIGxpc3RcclxuICAgICAgICAgICAgcy5kYXRhVHlwZXMgPSBqUXVlcnkudHJpbShzLmRhdGFUeXBlIHx8IFwiKlwiKS50b0xvd2VyQ2FzZSgpLm1hdGNoKHJub3R3aGl0ZSkgfHwgW1wiXCJdO1xyXG5cclxuICAgICAgICAgICAgLy8gQSBjcm9zcy1kb21haW4gcmVxdWVzdCBpcyBpbiBvcmRlciB3aGVuIHdlIGhhdmUgYSBwcm90b2NvbDpob3N0OnBvcnQgbWlzbWF0Y2hcclxuICAgICAgICAgICAgaWYgKHMuY3Jvc3NEb21haW4gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcGFydHMgPSBydXJsLmV4ZWMocy51cmwudG9Mb3dlckNhc2UoKSk7XHJcbiAgICAgICAgICAgICAgICBzLmNyb3NzRG9tYWluID0gISEocGFydHMgJiZcclxuICAgICAgICAgICAgICAgICAgICAocGFydHNbMV0gIT09IGFqYXhMb2NQYXJ0c1sxXSB8fCBwYXJ0c1syXSAhPT0gYWpheExvY1BhcnRzWzJdIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChwYXJ0c1szXSB8fCAocGFydHNbMV0gPT09IFwiaHR0cDpcIiA/IFwiODBcIiA6IFwiNDQzXCIpKSAhPT1cclxuICAgICAgICAgICAgICAgICAgICAgICAgKGFqYXhMb2NQYXJ0c1szXSB8fCAoYWpheExvY1BhcnRzWzFdID09PSBcImh0dHA6XCIgPyBcIjgwXCIgOiBcIjQ0M1wiKSkpXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBDb252ZXJ0IGRhdGEgaWYgbm90IGFscmVhZHkgYSBzdHJpbmdcclxuICAgICAgICAgICAgaWYgKHMuZGF0YSAmJiBzLnByb2Nlc3NEYXRhICYmIHR5cGVvZiBzLmRhdGEgIT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgICAgIHMuZGF0YSA9IGpRdWVyeS5wYXJhbShzLmRhdGEsIHMudHJhZGl0aW9uYWwpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBBcHBseSBwcmVmaWx0ZXJzXHJcbiAgICAgICAgICAgIGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKHByZWZpbHRlcnMsIHMsIG9wdGlvbnMsIGpxWEhSKTtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGEgcHJlZmlsdGVyLCBzdG9wIHRoZXJlXHJcbiAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gMikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGpxWEhSO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBXZSBjYW4gZmlyZSBnbG9iYWwgZXZlbnRzIGFzIG9mIG5vdyBpZiBhc2tlZCB0b1xyXG4gICAgICAgICAgICBmaXJlR2xvYmFscyA9IHMuZ2xvYmFsO1xyXG5cclxuICAgICAgICAgICAgLy8gV2F0Y2ggZm9yIGEgbmV3IHNldCBvZiByZXF1ZXN0c1xyXG4gICAgICAgICAgICBpZiAoZmlyZUdsb2JhbHMgJiYgalF1ZXJ5LmFjdGl2ZSsrID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBqUXVlcnkuZXZlbnQudHJpZ2dlcihcImFqYXhTdGFydFwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gVXBwZXJjYXNlIHRoZSB0eXBlXHJcbiAgICAgICAgICAgIHMudHlwZSA9IHMudHlwZS50b1VwcGVyQ2FzZSgpO1xyXG5cclxuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIGlmIHJlcXVlc3QgaGFzIGNvbnRlbnRcclxuICAgICAgICAgICAgcy5oYXNDb250ZW50ID0gIXJub0NvbnRlbnQudGVzdChzLnR5cGUpO1xyXG5cclxuICAgICAgICAgICAgLy8gU2F2ZSB0aGUgVVJMIGluIGNhc2Ugd2UncmUgdG95aW5nIHdpdGggdGhlIElmLU1vZGlmaWVkLVNpbmNlXHJcbiAgICAgICAgICAgIC8vIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciBsYXRlciBvblxyXG4gICAgICAgICAgICBjYWNoZVVSTCA9IHMudXJsO1xyXG5cclxuICAgICAgICAgICAgLy8gTW9yZSBvcHRpb25zIGhhbmRsaW5nIGZvciByZXF1ZXN0cyB3aXRoIG5vIGNvbnRlbnRcclxuICAgICAgICAgICAgaWYgKCFzLmhhc0NvbnRlbnQpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiBkYXRhIGlzIGF2YWlsYWJsZSwgYXBwZW5kIGRhdGEgdG8gdXJsXHJcbiAgICAgICAgICAgICAgICBpZiAocy5kYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVVUkwgPSAocy51cmwgKz0gKHJxdWVyeS50ZXN0KGNhY2hlVVJMKSA/IFwiJlwiIDogXCI/XCIpICsgcy5kYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyAjOTY4MjogcmVtb3ZlIGRhdGEgc28gdGhhdCBpdCdzIG5vdCB1c2VkIGluIGFuIGV2ZW50dWFsIHJldHJ5XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHMuZGF0YTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBBZGQgYW50aS1jYWNoZSBpbiB1cmwgaWYgbmVlZGVkXHJcbiAgICAgICAgICAgICAgICBpZiAocy5jYWNoZSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBzLnVybCA9IHJ0cy50ZXN0KGNhY2hlVVJMKSA/XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhbHJlYWR5IGEgJ18nIHBhcmFtZXRlciwgc2V0IGl0cyB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZVVSTC5yZXBsYWNlKHJ0cywgXCIkMV89XCIgKyBub25jZSsrKSA6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UgYWRkIG9uZSB0byB0aGUgZW5kXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlVVJMICsgKHJxdWVyeS50ZXN0KGNhY2hlVVJMKSA/IFwiJlwiIDogXCI/XCIpICsgXCJfPVwiICsgbm9uY2UrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cclxuICAgICAgICAgICAgaWYgKHMuaWZNb2RpZmllZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGpRdWVyeS5sYXN0TW9kaWZpZWRbY2FjaGVVUkxdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAganFYSFIuc2V0UmVxdWVzdEhlYWRlcihcIklmLU1vZGlmaWVkLVNpbmNlXCIsIGpRdWVyeS5sYXN0TW9kaWZpZWRbY2FjaGVVUkxdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChqUXVlcnkuZXRhZ1tjYWNoZVVSTF0pIHtcclxuICAgICAgICAgICAgICAgICAgICBqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKFwiSWYtTm9uZS1NYXRjaFwiLCBqUXVlcnkuZXRhZ1tjYWNoZVVSTF0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBTZXQgdGhlIGNvcnJlY3QgaGVhZGVyLCBpZiBkYXRhIGlzIGJlaW5nIHNlbnRcclxuICAgICAgICAgICAgaWYgKHMuZGF0YSAmJiBzLmhhc0NvbnRlbnQgJiYgcy5jb250ZW50VHlwZSAhPT0gZmFsc2UgfHwgb3B0aW9ucy5jb250ZW50VHlwZSkge1xyXG4gICAgICAgICAgICAgICAganFYSFIuc2V0UmVxdWVzdEhlYWRlcihcIkNvbnRlbnQtVHlwZVwiLCBzLmNvbnRlbnRUeXBlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gU2V0IHRoZSBBY2NlcHRzIGhlYWRlciBmb3IgdGhlIHNlcnZlciwgZGVwZW5kaW5nIG9uIHRoZSBkYXRhVHlwZVxyXG4gICAgICAgICAgICBqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKFxyXG4gICAgICAgICAgICAgICAgXCJBY2NlcHRcIixcclxuICAgICAgICAgICAgICAgIHMuZGF0YVR5cGVzWzBdICYmIHMuYWNjZXB0c1tzLmRhdGFUeXBlc1swXV0gP1xyXG4gICAgICAgICAgICAgICAgcy5hY2NlcHRzW3MuZGF0YVR5cGVzWzBdXSArIChzLmRhdGFUeXBlc1swXSAhPT0gXCIqXCIgPyBcIiwgXCIgKyBhbGxUeXBlcyArIFwiOyBxPTAuMDFcIiA6IFwiXCIpIDpcclxuICAgICAgICAgICAgICAgIHMuYWNjZXB0c1tcIipcIl1cclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBoZWFkZXJzIG9wdGlvblxyXG4gICAgICAgICAgICBmb3IgKGkgaW4gcy5oZWFkZXJzKSB7XHJcbiAgICAgICAgICAgICAgICBqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKGksIHMuaGVhZGVyc1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEFsbG93IGN1c3RvbSBoZWFkZXJzL21pbWV0eXBlcyBhbmQgZWFybHkgYWJvcnRcclxuICAgICAgICAgICAgaWYgKHMuYmVmb3JlU2VuZCAmJiAocy5iZWZvcmVTZW5kLmNhbGwoY2FsbGJhY2tDb250ZXh0LCBqcVhIUiwgcykgPT09IGZhbHNlIHx8IHN0YXRlID09PSAyKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gQWJvcnQgaWYgbm90IGRvbmUgYWxyZWFkeSBhbmQgcmV0dXJuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4ganFYSFIuYWJvcnQoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gYWJvcnRpbmcgaXMgbm8gbG9uZ2VyIGEgY2FuY2VsbGF0aW9uXHJcbiAgICAgICAgICAgIHN0ckFib3J0ID0gXCJhYm9ydFwiO1xyXG5cclxuICAgICAgICAgICAgLy8gSW5zdGFsbCBjYWxsYmFja3Mgb24gZGVmZXJyZWRzXHJcbiAgICAgICAgICAgIGZvciAoaSBpbiB7IHN1Y2Nlc3M6IDEsIGVycm9yOiAxLCBjb21wbGV0ZTogMSB9KSB7XHJcbiAgICAgICAgICAgICAgICBqcVhIUltpXShzW2ldKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gR2V0IHRyYW5zcG9ydFxyXG4gICAgICAgICAgICB0cmFuc3BvcnQgPSBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyh0cmFuc3BvcnRzLCBzLCBvcHRpb25zLCBqcVhIUik7XHJcblxyXG4gICAgICAgICAgICAvLyBJZiBubyB0cmFuc3BvcnQsIHdlIGF1dG8tYWJvcnRcclxuICAgICAgICAgICAgaWYgKCF0cmFuc3BvcnQpIHtcclxuICAgICAgICAgICAgICAgIGRvbmUoLTEsIFwiTm8gVHJhbnNwb3J0XCIpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAganFYSFIucmVhZHlTdGF0ZSA9IDE7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU2VuZCBnbG9iYWwgZXZlbnRcclxuICAgICAgICAgICAgICAgIGlmIChmaXJlR2xvYmFscykge1xyXG4gICAgICAgICAgICAgICAgICAgIGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKFwiYWpheFNlbmRcIiwgW2pxWEhSLCBzXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBUaW1lb3V0XHJcbiAgICAgICAgICAgICAgICBpZiAocy5hc3luYyAmJiBzLnRpbWVvdXQgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGltZW91dFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAganFYSFIuYWJvcnQoXCJ0aW1lb3V0XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sIHMudGltZW91dCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0LnNlbmQocmVxdWVzdEhlYWRlcnMsIGRvbmUpO1xyXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFByb3BhZ2F0ZSBleGNlcHRpb24gYXMgZXJyb3IgaWYgbm90IGRvbmVcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUgPCAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoLTEsIGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTaW1wbHkgcmV0aHJvdyBvdGhlcndpc2VcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQ2FsbGJhY2sgZm9yIHdoZW4gZXZlcnl0aGluZyBpcyBkb25lXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGRvbmUoc3RhdHVzLCBuYXRpdmVTdGF0dXNUZXh0LCByZXNwb25zZXMsIGhlYWRlcnMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpc1N1Y2Nlc3MsIHN1Y2Nlc3MsIGVycm9yLCByZXNwb25zZSwgbW9kaWZpZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzVGV4dCA9IG5hdGl2ZVN0YXR1c1RleHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ2FsbGVkIG9uY2VcclxuICAgICAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTdGF0ZSBpcyBcImRvbmVcIiBub3dcclxuICAgICAgICAgICAgICAgIHN0YXRlID0gMjtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDbGVhciB0aW1lb3V0IGlmIGl0IGV4aXN0c1xyXG4gICAgICAgICAgICAgICAgaWYgKHRpbWVvdXRUaW1lcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0VGltZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIERlcmVmZXJlbmNlIHRyYW5zcG9ydCBmb3IgZWFybHkgZ2FyYmFnZSBjb2xsZWN0aW9uXHJcbiAgICAgICAgICAgICAgICAvLyAobm8gbWF0dGVyIGhvdyBsb25nIHRoZSBqcVhIUiBvYmplY3Qgd2lsbCBiZSB1c2VkKVxyXG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0ID0gdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENhY2hlIHJlc3BvbnNlIGhlYWRlcnNcclxuICAgICAgICAgICAgICAgIHJlc3BvbnNlSGVhZGVyc1N0cmluZyA9IGhlYWRlcnMgfHwgXCJcIjtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTZXQgcmVhZHlTdGF0ZVxyXG4gICAgICAgICAgICAgICAganFYSFIucmVhZHlTdGF0ZSA9IHN0YXR1cyA+IDAgPyA0IDogMDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBEZXRlcm1pbmUgaWYgc3VjY2Vzc2Z1bFxyXG4gICAgICAgICAgICAgICAgaXNTdWNjZXNzID0gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDAgfHwgc3RhdHVzID09PSAzMDQ7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gR2V0IHJlc3BvbnNlIGRhdGFcclxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IGFqYXhIYW5kbGVSZXNwb25zZXMocywganFYSFIsIHJlc3BvbnNlcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ29udmVydCBubyBtYXR0ZXIgd2hhdCAodGhhdCB3YXkgcmVzcG9uc2VYWFggZmllbGRzIGFyZSBhbHdheXMgc2V0KVxyXG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBhamF4Q29udmVydChzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2Vzcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSWYgc3VjY2Vzc2Z1bCwgaGFuZGxlIHR5cGUgY2hhaW5pbmdcclxuICAgICAgICAgICAgICAgIGlmIChpc1N1Y2Nlc3MpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cclxuICAgICAgICAgICAgICAgICAgICBpZiAocy5pZk1vZGlmaWVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoXCJMYXN0LU1vZGlmaWVkXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobW9kaWZpZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5sYXN0TW9kaWZpZWRbY2FjaGVVUkxdID0gbW9kaWZpZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlcihcImV0YWdcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb2RpZmllZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmV0YWdbY2FjaGVVUkxdID0gbW9kaWZpZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIG5vIGNvbnRlbnRcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHVzID09PSAyMDQgfHwgcy50eXBlID09PSBcIkhFQURcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXNUZXh0ID0gXCJub2NvbnRlbnRcIjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIG5vdCBtb2RpZmllZFxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdHVzID09PSAzMDQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzVGV4dCA9IFwibm90bW9kaWZpZWRcIjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgZGF0YSwgbGV0J3MgY29udmVydCBpdFxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1c1RleHQgPSByZXNwb25zZS5zdGF0ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VzcyA9IHJlc3BvbnNlLmRhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gcmVzcG9uc2UuZXJyb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzU3VjY2VzcyA9ICFlcnJvcjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGV4dHJhY3QgZXJyb3IgZnJvbSBzdGF0dXNUZXh0XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlbiBub3JtYWxpemUgc3RhdHVzVGV4dCBhbmQgc3RhdHVzIGZvciBub24tYWJvcnRzXHJcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBzdGF0dXNUZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXMgfHwgIXN0YXR1c1RleHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzVGV4dCA9IFwiZXJyb3JcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cyA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cyA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU2V0IGRhdGEgZm9yIHRoZSBmYWtlIHhociBvYmplY3RcclxuICAgICAgICAgICAgICAgIGpxWEhSLnN0YXR1cyA9IHN0YXR1cztcclxuICAgICAgICAgICAgICAgIGpxWEhSLnN0YXR1c1RleHQgPSAobmF0aXZlU3RhdHVzVGV4dCB8fCBzdGF0dXNUZXh0KSArIFwiXCI7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU3VjY2Vzcy9FcnJvclxyXG4gICAgICAgICAgICAgICAgaWYgKGlzU3VjY2Vzcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmVXaXRoKGNhbGxiYWNrQ29udGV4dCwgW3N1Y2Nlc3MsIHN0YXR1c1RleHQsIGpxWEhSXSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdFdpdGgoY2FsbGJhY2tDb250ZXh0LCBbanFYSFIsIHN0YXR1c1RleHQsIGVycm9yXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3NcclxuICAgICAgICAgICAgICAgIGpxWEhSLnN0YXR1c0NvZGUoc3RhdHVzQ29kZSk7XHJcbiAgICAgICAgICAgICAgICBzdGF0dXNDb2RlID0gdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChmaXJlR2xvYmFscykge1xyXG4gICAgICAgICAgICAgICAgICAgIGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKGlzU3VjY2VzcyA/IFwiYWpheFN1Y2Nlc3NcIiA6IFwiYWpheEVycm9yXCIsIFtqcVhIUiwgcywgaXNTdWNjZXNzID8gc3VjY2VzcyA6IGVycm9yXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ29tcGxldGVcclxuICAgICAgICAgICAgICAgIGNvbXBsZXRlRGVmZXJyZWQuZmlyZVdpdGgoY2FsbGJhY2tDb250ZXh0LCBbanFYSFIsIHN0YXR1c1RleHRdKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZmlyZUdsb2JhbHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlcihcImFqYXhDb21wbGV0ZVwiLCBbanFYSFIsIHNdKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgdGhlIGdsb2JhbCBBSkFYIGNvdW50ZXJcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISgtLWpRdWVyeS5hY3RpdmUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5ldmVudC50cmlnZ2VyKFwiYWpheFN0b3BcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4ganFYSFI7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZ2V0SlNPTjogZnVuY3Rpb24odXJsLCBkYXRhLCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5LmdldCh1cmwsIGRhdGEsIGNhbGxiYWNrLCBcImpzb25cIik7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZ2V0U2NyaXB0OiBmdW5jdGlvbih1cmwsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkuZ2V0KHVybCwgdW5kZWZpbmVkLCBjYWxsYmFjaywgXCJzY3JpcHRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgalF1ZXJ5LmVhY2goW1wiZ2V0XCIsIFwicG9zdFwiXSwgZnVuY3Rpb24oaSwgbWV0aG9kKSB7XHJcbiAgICAgICAgalF1ZXJ5W21ldGhvZF0gPSBmdW5jdGlvbih1cmwsIGRhdGEsIGNhbGxiYWNrLCB0eXBlKSB7XHJcbiAgICAgICAgICAgIC8vIHNoaWZ0IGFyZ3VtZW50cyBpZiBkYXRhIGFyZ3VtZW50IHdhcyBvbWl0dGVkXHJcbiAgICAgICAgICAgIGlmIChqUXVlcnkuaXNGdW5jdGlvbihkYXRhKSkge1xyXG4gICAgICAgICAgICAgICAgdHlwZSA9IHR5cGUgfHwgY2FsbGJhY2s7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGRhdGE7XHJcbiAgICAgICAgICAgICAgICBkYXRhID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5LmFqYXgoe1xyXG4gICAgICAgICAgICAgICAgdXJsOiB1cmwsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiBtZXRob2QsXHJcbiAgICAgICAgICAgICAgICBkYXRhVHlwZTogdHlwZSxcclxuICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEsXHJcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBjYWxsYmFja1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gQXR0YWNoIGEgYnVuY2ggb2YgZnVuY3Rpb25zIGZvciBoYW5kbGluZyBjb21tb24gQUpBWCBldmVudHNcclxuICAgIGpRdWVyeS5lYWNoKFtcImFqYXhTdGFydFwiLCBcImFqYXhTdG9wXCIsIFwiYWpheENvbXBsZXRlXCIsIFwiYWpheEVycm9yXCIsIFwiYWpheFN1Y2Nlc3NcIiwgXCJhamF4U2VuZFwiXSwgZnVuY3Rpb24oaSwgdHlwZSkge1xyXG4gICAgICAgIGpRdWVyeS5mblt0eXBlXSA9IGZ1bmN0aW9uKGZuKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9uKHR5cGUsIGZuKTtcclxuICAgICAgICB9O1xyXG4gICAgfSk7XHJcblxyXG5cclxuICAgIGpRdWVyeS5fZXZhbFVybCA9IGZ1bmN0aW9uKHVybCkge1xyXG4gICAgICAgIHJldHVybiBqUXVlcnkuYWpheCh7XHJcbiAgICAgICAgICAgIHVybDogdXJsLFxyXG4gICAgICAgICAgICB0eXBlOiBcIkdFVFwiLFxyXG4gICAgICAgICAgICBkYXRhVHlwZTogXCJzY3JpcHRcIixcclxuICAgICAgICAgICAgYXN5bmM6IGZhbHNlLFxyXG4gICAgICAgICAgICBnbG9iYWw6IGZhbHNlLFxyXG4gICAgICAgICAgICBcInRocm93c1wiOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICBqUXVlcnkuZm4uZXh0ZW5kKHtcclxuICAgICAgICB3cmFwQWxsOiBmdW5jdGlvbihodG1sKSB7XHJcbiAgICAgICAgICAgIHZhciB3cmFwO1xyXG5cclxuICAgICAgICAgICAgaWYgKGpRdWVyeS5pc0Z1bmN0aW9uKGh0bWwpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGkpIHtcclxuICAgICAgICAgICAgICAgICAgICBqUXVlcnkodGhpcykud3JhcEFsbChodG1sLmNhbGwodGhpcywgaSkpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzWzBdKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVGhlIGVsZW1lbnRzIHRvIHdyYXAgdGhlIHRhcmdldCBhcm91bmRcclxuICAgICAgICAgICAgICAgIHdyYXAgPSBqUXVlcnkoaHRtbCwgdGhpc1swXS5vd25lckRvY3VtZW50KS5lcSgwKS5jbG9uZSh0cnVlKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpc1swXS5wYXJlbnROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd3JhcC5pbnNlcnRCZWZvcmUodGhpc1swXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgd3JhcC5tYXAoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW0gPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZWxlbS5maXJzdEVsZW1lbnRDaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtID0gZWxlbS5maXJzdEVsZW1lbnRDaGlsZDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtO1xyXG4gICAgICAgICAgICAgICAgfSkuYXBwZW5kKHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICB3cmFwSW5uZXI6IGZ1bmN0aW9uKGh0bWwpIHtcclxuICAgICAgICAgICAgaWYgKGpRdWVyeS5pc0Z1bmN0aW9uKGh0bWwpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGkpIHtcclxuICAgICAgICAgICAgICAgICAgICBqUXVlcnkodGhpcykud3JhcElubmVyKGh0bWwuY2FsbCh0aGlzLCBpKSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzZWxmID0galF1ZXJ5KHRoaXMpLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRzID0gc2VsZi5jb250ZW50cygpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChjb250ZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZW50cy53cmFwQWxsKGh0bWwpO1xyXG5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5hcHBlbmQoaHRtbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHdyYXA6IGZ1bmN0aW9uKGh0bWwpIHtcclxuICAgICAgICAgICAgdmFyIGlzRnVuY3Rpb24gPSBqUXVlcnkuaXNGdW5jdGlvbihodG1sKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oaSkge1xyXG4gICAgICAgICAgICAgICAgalF1ZXJ5KHRoaXMpLndyYXBBbGwoaXNGdW5jdGlvbiA/IGh0bWwuY2FsbCh0aGlzLCBpKSA6IGh0bWwpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICB1bndyYXA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQoKS5lYWNoKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFqUXVlcnkubm9kZU5hbWUodGhpcywgXCJib2R5XCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KHRoaXMpLnJlcGxhY2VXaXRoKHRoaXMuY2hpbGROb2Rlcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pLmVuZCgpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuXHJcbiAgICBqUXVlcnkuZXhwci5maWx0ZXJzLmhpZGRlbiA9IGZ1bmN0aW9uKGVsZW0pIHtcclxuICAgICAgICAvLyBTdXBwb3J0OiBPcGVyYSA8PSAxMi4xMlxyXG4gICAgICAgIC8vIE9wZXJhIHJlcG9ydHMgb2Zmc2V0V2lkdGhzIGFuZCBvZmZzZXRIZWlnaHRzIGxlc3MgdGhhbiB6ZXJvIG9uIHNvbWUgZWxlbWVudHNcclxuICAgICAgICByZXR1cm4gZWxlbS5vZmZzZXRXaWR0aCA8PSAwICYmIGVsZW0ub2Zmc2V0SGVpZ2h0IDw9IDA7XHJcbiAgICB9O1xyXG4gICAgalF1ZXJ5LmV4cHIuZmlsdGVycy52aXNpYmxlID0gZnVuY3Rpb24oZWxlbSkge1xyXG4gICAgICAgIHJldHVybiAhalF1ZXJ5LmV4cHIuZmlsdGVycy5oaWRkZW4oZWxlbSk7XHJcbiAgICB9O1xyXG5cclxuXHJcblxyXG5cclxuICAgIHZhciByMjAgPSAvJTIwL2csXHJcbiAgICAgICAgcmJyYWNrZXQgPSAvXFxbXFxdJC8sXHJcbiAgICAgICAgckNSTEYgPSAvXFxyP1xcbi9nLFxyXG4gICAgICAgIHJzdWJtaXR0ZXJUeXBlcyA9IC9eKD86c3VibWl0fGJ1dHRvbnxpbWFnZXxyZXNldHxmaWxlKSQvaSxcclxuICAgICAgICByc3VibWl0dGFibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxrZXlnZW4pL2k7XHJcblxyXG4gICAgZnVuY3Rpb24gYnVpbGRQYXJhbXMocHJlZml4LCBvYmosIHRyYWRpdGlvbmFsLCBhZGQpIHtcclxuICAgICAgICB2YXIgbmFtZTtcclxuXHJcbiAgICAgICAgaWYgKGpRdWVyeS5pc0FycmF5KG9iaikpIHtcclxuICAgICAgICAgICAgLy8gU2VyaWFsaXplIGFycmF5IGl0ZW0uXHJcbiAgICAgICAgICAgIGpRdWVyeS5lYWNoKG9iaiwgZnVuY3Rpb24oaSwgdikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRyYWRpdGlvbmFsIHx8IHJicmFja2V0LnRlc3QocHJlZml4KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRyZWF0IGVhY2ggYXJyYXkgaXRlbSBhcyBhIHNjYWxhci5cclxuICAgICAgICAgICAgICAgICAgICBhZGQocHJlZml4LCB2KTtcclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEl0ZW0gaXMgbm9uLXNjYWxhciAoYXJyYXkgb3Igb2JqZWN0KSwgZW5jb2RlIGl0cyBudW1lcmljIGluZGV4LlxyXG4gICAgICAgICAgICAgICAgICAgIGJ1aWxkUGFyYW1zKHByZWZpeCArIFwiW1wiICsgKHR5cGVvZiB2ID09PSBcIm9iamVjdFwiID8gaSA6IFwiXCIpICsgXCJdXCIsIHYsIHRyYWRpdGlvbmFsLCBhZGQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgfSBlbHNlIGlmICghdHJhZGl0aW9uYWwgJiYgalF1ZXJ5LnR5cGUob2JqKSA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgICAgICAvLyBTZXJpYWxpemUgb2JqZWN0IGl0ZW0uXHJcbiAgICAgICAgICAgIGZvciAobmFtZSBpbiBvYmopIHtcclxuICAgICAgICAgICAgICAgIGJ1aWxkUGFyYW1zKHByZWZpeCArIFwiW1wiICsgbmFtZSArIFwiXVwiLCBvYmpbbmFtZV0sIHRyYWRpdGlvbmFsLCBhZGQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFNlcmlhbGl6ZSBzY2FsYXIgaXRlbS5cclxuICAgICAgICAgICAgYWRkKHByZWZpeCwgb2JqKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU2VyaWFsaXplIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMgb3IgYSBzZXQgb2ZcclxuICAgIC8vIGtleS92YWx1ZXMgaW50byBhIHF1ZXJ5IHN0cmluZ1xyXG4gICAgalF1ZXJ5LnBhcmFtID0gZnVuY3Rpb24oYSwgdHJhZGl0aW9uYWwpIHtcclxuICAgICAgICB2YXIgcHJlZml4LFxyXG4gICAgICAgICAgICBzID0gW10sXHJcbiAgICAgICAgICAgIGFkZCA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIC8vIElmIHZhbHVlIGlzIGEgZnVuY3Rpb24sIGludm9rZSBpdCBhbmQgcmV0dXJuIGl0cyB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBqUXVlcnkuaXNGdW5jdGlvbih2YWx1ZSkgPyB2YWx1ZSgpIDogKHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgc1tzLmxlbmd0aF0gPSBlbmNvZGVVUklDb21wb25lbnQoa2V5KSArIFwiPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gU2V0IHRyYWRpdGlvbmFsIHRvIHRydWUgZm9yIGpRdWVyeSA8PSAxLjMuMiBiZWhhdmlvci5cclxuICAgICAgICBpZiAodHJhZGl0aW9uYWwgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0cmFkaXRpb25hbCA9IGpRdWVyeS5hamF4U2V0dGluZ3MgJiYgalF1ZXJ5LmFqYXhTZXR0aW5ncy50cmFkaXRpb25hbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIElmIGFuIGFycmF5IHdhcyBwYXNzZWQgaW4sIGFzc3VtZSB0aGF0IGl0IGlzIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMuXHJcbiAgICAgICAgaWYgKGpRdWVyeS5pc0FycmF5KGEpIHx8IChhLmpxdWVyeSAmJiAhalF1ZXJ5LmlzUGxhaW5PYmplY3QoYSkpKSB7XHJcbiAgICAgICAgICAgIC8vIFNlcmlhbGl6ZSB0aGUgZm9ybSBlbGVtZW50c1xyXG4gICAgICAgICAgICBqUXVlcnkuZWFjaChhLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIGFkZCh0aGlzLm5hbWUsIHRoaXMudmFsdWUpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gSWYgdHJhZGl0aW9uYWwsIGVuY29kZSB0aGUgXCJvbGRcIiB3YXkgKHRoZSB3YXkgMS4zLjIgb3Igb2xkZXJcclxuICAgICAgICAgICAgLy8gZGlkIGl0KSwgb3RoZXJ3aXNlIGVuY29kZSBwYXJhbXMgcmVjdXJzaXZlbHkuXHJcbiAgICAgICAgICAgIGZvciAocHJlZml4IGluIGEpIHtcclxuICAgICAgICAgICAgICAgIGJ1aWxkUGFyYW1zKHByZWZpeCwgYVtwcmVmaXhdLCB0cmFkaXRpb25hbCwgYWRkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmV0dXJuIHRoZSByZXN1bHRpbmcgc2VyaWFsaXphdGlvblxyXG4gICAgICAgIHJldHVybiBzLmpvaW4oXCImXCIpLnJlcGxhY2UocjIwLCBcIitcIik7XHJcbiAgICB9O1xyXG5cclxuICAgIGpRdWVyeS5mbi5leHRlbmQoe1xyXG4gICAgICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkucGFyYW0odGhpcy5zZXJpYWxpemVBcnJheSgpKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNlcmlhbGl6ZUFycmF5OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIENhbiBhZGQgcHJvcEhvb2sgZm9yIFwiZWxlbWVudHNcIiB0byBmaWx0ZXIgb3IgYWRkIGZvcm0gZWxlbWVudHNcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbWVudHMgPSBqUXVlcnkucHJvcCh0aGlzLCBcImVsZW1lbnRzXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50cyA/IGpRdWVyeS5tYWtlQXJyYXkoZWxlbWVudHMpIDogdGhpcztcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0eXBlID0gdGhpcy50eXBlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBVc2UgLmlzKCBcIjpkaXNhYmxlZFwiICkgc28gdGhhdCBmaWVsZHNldFtkaXNhYmxlZF0gd29ya3NcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uYW1lICYmICFqUXVlcnkodGhpcykuaXMoXCI6ZGlzYWJsZWRcIikgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgcnN1Ym1pdHRhYmxlLnRlc3QodGhpcy5ub2RlTmFtZSkgJiYgIXJzdWJtaXR0ZXJUeXBlcy50ZXN0KHR5cGUpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLmNoZWNrZWQgfHwgIXJjaGVja2FibGVUeXBlLnRlc3QodHlwZSkpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24oaSwgZWxlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSBqUXVlcnkodGhpcykudmFsKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWwgPT0gbnVsbCA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bGwgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuaXNBcnJheSh2YWwpID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5Lm1hcCh2YWwsIGZ1bmN0aW9uKHZhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgbmFtZTogZWxlbS5uYW1lLCB2YWx1ZTogdmFsLnJlcGxhY2UockNSTEYsIFwiXFxyXFxuXCIpIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pIDogeyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZShyQ1JMRiwgXCJcXHJcXG5cIikgfTtcclxuICAgICAgICAgICAgICAgIH0pLmdldCgpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuXHJcbiAgICBqUXVlcnkuYWpheFNldHRpbmdzLnhociA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7fVxyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgeGhySWQgPSAwLFxyXG4gICAgICAgIHhockNhbGxiYWNrcyA9IHt9LFxyXG4gICAgICAgIHhoclN1Y2Nlc3NTdGF0dXMgPSB7XHJcbiAgICAgICAgICAgIC8vIGZpbGUgcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgY29kZSAwLCBhc3N1bWUgMjAwXHJcbiAgICAgICAgICAgIDA6IDIwMCxcclxuICAgICAgICAgICAgLy8gU3VwcG9ydDogSUU5XHJcbiAgICAgICAgICAgIC8vICMxNDUwOiBzb21ldGltZXMgSUUgcmV0dXJucyAxMjIzIHdoZW4gaXQgc2hvdWxkIGJlIDIwNFxyXG4gICAgICAgICAgICAxMjIzOiAyMDRcclxuICAgICAgICB9LFxyXG4gICAgICAgIHhoclN1cHBvcnRlZCA9IGpRdWVyeS5hamF4U2V0dGluZ3MueGhyKCk7XHJcblxyXG4gICAgLy8gU3VwcG9ydDogSUU5XHJcbiAgICAvLyBPcGVuIHJlcXVlc3RzIG11c3QgYmUgbWFudWFsbHkgYWJvcnRlZCBvbiB1bmxvYWQgKCM1MjgwKVxyXG4gICAgaWYgKHdpbmRvdy5BY3RpdmVYT2JqZWN0KSB7XHJcbiAgICAgICAgalF1ZXJ5KHdpbmRvdykub24oXCJ1bmxvYWRcIiwgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiB4aHJDYWxsYmFja3MpIHtcclxuICAgICAgICAgICAgICAgIHhockNhbGxiYWNrc1trZXldKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBzdXBwb3J0LmNvcnMgPSAhIXhoclN1cHBvcnRlZCAmJiAoXCJ3aXRoQ3JlZGVudGlhbHNcIiBpbiB4aHJTdXBwb3J0ZWQpO1xyXG4gICAgc3VwcG9ydC5hamF4ID0geGhyU3VwcG9ydGVkID0gISF4aHJTdXBwb3J0ZWQ7XHJcblxyXG4gICAgalF1ZXJ5LmFqYXhUcmFuc3BvcnQoZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgICAgIHZhciBjYWxsYmFjaztcclxuXHJcbiAgICAgICAgLy8gQ3Jvc3MgZG9tYWluIG9ubHkgYWxsb3dlZCBpZiBzdXBwb3J0ZWQgdGhyb3VnaCBYTUxIdHRwUmVxdWVzdFxyXG4gICAgICAgIGlmIChzdXBwb3J0LmNvcnMgfHwgeGhyU3VwcG9ydGVkICYmICFvcHRpb25zLmNyb3NzRG9tYWluKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBzZW5kOiBmdW5jdGlvbihoZWFkZXJzLCBjb21wbGV0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIgPSBvcHRpb25zLnhocigpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZCA9ICsreGhySWQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHhoci5vcGVuKG9wdGlvbnMudHlwZSwgb3B0aW9ucy51cmwsIG9wdGlvbnMuYXN5bmMsIG9wdGlvbnMudXNlcm5hbWUsIG9wdGlvbnMucGFzc3dvcmQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBjdXN0b20gZmllbGRzIGlmIHByb3ZpZGVkXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMueGhyRmllbGRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSBpbiBvcHRpb25zLnhockZpZWxkcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyW2ldID0gb3B0aW9ucy54aHJGaWVsZHNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE92ZXJyaWRlIG1pbWUgdHlwZSBpZiBuZWVkZWRcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5taW1lVHlwZSAmJiB4aHIub3ZlcnJpZGVNaW1lVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIub3ZlcnJpZGVNaW1lVHlwZShvcHRpb25zLm1pbWVUeXBlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFgtUmVxdWVzdGVkLVdpdGggaGVhZGVyXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGNyb3NzLWRvbWFpbiByZXF1ZXN0cywgc2VlaW5nIGFzIGNvbmRpdGlvbnMgZm9yIGEgcHJlZmxpZ2h0IGFyZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFraW4gdG8gYSBqaWdzYXcgcHV6emxlLCB3ZSBzaW1wbHkgbmV2ZXIgc2V0IGl0IHRvIGJlIHN1cmUuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gKGl0IGNhbiBhbHdheXMgYmUgc2V0IG9uIGEgcGVyLXJlcXVlc3QgYmFzaXMgb3IgZXZlbiB1c2luZyBhamF4U2V0dXApXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIHNhbWUtZG9tYWluIHJlcXVlc3RzLCB3b24ndCBjaGFuZ2UgaGVhZGVyIGlmIGFscmVhZHkgcHJvdmlkZWQuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLmNyb3NzRG9tYWluICYmICFoZWFkZXJzW1wiWC1SZXF1ZXN0ZWQtV2l0aFwiXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzW1wiWC1SZXF1ZXN0ZWQtV2l0aFwiXSA9IFwiWE1MSHR0cFJlcXVlc3RcIjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNldCBoZWFkZXJzXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpIGluIGhlYWRlcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoaSwgaGVhZGVyc1tpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBDYWxsYmFja1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24odHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgeGhyQ2FsbGJhY2tzW2lkXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9IHhoci5vbmxvYWQgPSB4aHIub25lcnJvciA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBcImFib3J0XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLmFib3J0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcImVycm9yXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGUoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmaWxlOiBwcm90b2NvbCBhbHdheXMgeWllbGRzIHN0YXR1cyAwOyBzZWUgIzg2MDUsICMxNDIwN1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLnN0YXR1cyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhoci5zdGF0dXNUZXh0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGUoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHJTdWNjZXNzU3RhdHVzW3hoci5zdGF0dXNdIHx8IHhoci5zdGF0dXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHIuc3RhdHVzVGV4dCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQ6IElFOVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWNjZXNzaW5nIGJpbmFyeS1kYXRhIHJlc3BvbnNlVGV4dCB0aHJvd3MgYW4gZXhjZXB0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAoIzExNDI2KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHhoci5yZXNwb25zZVRleHQgPT09IFwic3RyaW5nXCIgPyB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogeGhyLnJlc3BvbnNlVGV4dFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBMaXN0ZW4gdG8gZXZlbnRzXHJcbiAgICAgICAgICAgICAgICAgICAgeGhyLm9ubG9hZCA9IGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgeGhyLm9uZXJyb3IgPSBjYWxsYmFjayhcImVycm9yXCIpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgdGhlIGFib3J0IGNhbGxiYWNrXHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSB4aHJDYWxsYmFja3NbaWRdID0gY2FsbGJhY2soXCJhYm9ydFwiKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG8gc2VuZCB0aGUgcmVxdWVzdCAodGhpcyBtYXkgcmFpc2UgYW4gZXhjZXB0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIuc2VuZChvcHRpb25zLmhhc0NvbnRlbnQgJiYgb3B0aW9ucy5kYXRhIHx8IG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gIzE0NjgzOiBPbmx5IHJldGhyb3cgaWYgdGhpcyBoYXNuJ3QgYmVlbiBub3RpZmllZCBhcyBhbiBlcnJvciB5ZXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBhYm9ydDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuXHJcblxyXG5cclxuICAgIC8vIEluc3RhbGwgc2NyaXB0IGRhdGFUeXBlXHJcbiAgICBqUXVlcnkuYWpheFNldHVwKHtcclxuICAgICAgICBhY2NlcHRzOiB7XHJcbiAgICAgICAgICAgIHNjcmlwdDogXCJ0ZXh0L2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2VjbWFzY3JpcHQsIGFwcGxpY2F0aW9uL3gtZWNtYXNjcmlwdFwiXHJcbiAgICAgICAgfSxcclxuICAgICAgICBjb250ZW50czoge1xyXG4gICAgICAgICAgICBzY3JpcHQ6IC8oPzpqYXZhfGVjbWEpc2NyaXB0L1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY29udmVydGVyczoge1xyXG4gICAgICAgICAgICBcInRleHQgc2NyaXB0XCI6IGZ1bmN0aW9uKHRleHQpIHtcclxuICAgICAgICAgICAgICAgIGpRdWVyeS5nbG9iYWxFdmFsKHRleHQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRleHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBIYW5kbGUgY2FjaGUncyBzcGVjaWFsIGNhc2UgYW5kIGNyb3NzRG9tYWluXHJcbiAgICBqUXVlcnkuYWpheFByZWZpbHRlcihcInNjcmlwdFwiLCBmdW5jdGlvbihzKSB7XHJcbiAgICAgICAgaWYgKHMuY2FjaGUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBzLmNhY2hlID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzLmNyb3NzRG9tYWluKSB7XHJcbiAgICAgICAgICAgIHMudHlwZSA9IFwiR0VUXCI7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gQmluZCBzY3JpcHQgdGFnIGhhY2sgdHJhbnNwb3J0XHJcbiAgICBqUXVlcnkuYWpheFRyYW5zcG9ydChcInNjcmlwdFwiLCBmdW5jdGlvbihzKSB7XHJcbiAgICAgICAgLy8gVGhpcyB0cmFuc3BvcnQgb25seSBkZWFscyB3aXRoIGNyb3NzIGRvbWFpbiByZXF1ZXN0c1xyXG4gICAgICAgIGlmIChzLmNyb3NzRG9tYWluKSB7XHJcbiAgICAgICAgICAgIHZhciBzY3JpcHQsIGNhbGxiYWNrO1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgc2VuZDogZnVuY3Rpb24oXywgY29tcGxldGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBzY3JpcHQgPSBqUXVlcnkoXCI8c2NyaXB0PlwiKS5wcm9wKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXN5bmM6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJzZXQ6IHMuc2NyaXB0Q2hhcnNldCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3JjOiBzLnVybFxyXG4gICAgICAgICAgICAgICAgICAgIH0pLm9uKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcImxvYWQgZXJyb3JcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbihldnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcmlwdC5yZW1vdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZShldnQudHlwZSA9PT0gXCJlcnJvclwiID8gNDA0IDogMjAwLCBldnQudHlwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0WzBdKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBhYm9ydDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuXHJcblxyXG5cclxuICAgIHZhciBvbGRDYWxsYmFja3MgPSBbXSxcclxuICAgICAgICByanNvbnAgPSAvKD0pXFw/KD89JnwkKXxcXD9cXD8vO1xyXG5cclxuICAgIC8vIERlZmF1bHQganNvbnAgc2V0dGluZ3NcclxuICAgIGpRdWVyeS5hamF4U2V0dXAoe1xyXG4gICAgICAgIGpzb25wOiBcImNhbGxiYWNrXCIsXHJcbiAgICAgICAganNvbnBDYWxsYmFjazogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IG9sZENhbGxiYWNrcy5wb3AoKSB8fCAoalF1ZXJ5LmV4cGFuZG8gKyBcIl9cIiArIChub25jZSsrKSk7XHJcbiAgICAgICAgICAgIHRoaXNbY2FsbGJhY2tdID0gdHJ1ZTtcclxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIERldGVjdCwgbm9ybWFsaXplIG9wdGlvbnMgYW5kIGluc3RhbGwgY2FsbGJhY2tzIGZvciBqc29ucCByZXF1ZXN0c1xyXG4gICAgalF1ZXJ5LmFqYXhQcmVmaWx0ZXIoXCJqc29uIGpzb25wXCIsIGZ1bmN0aW9uKHMsIG9yaWdpbmFsU2V0dGluZ3MsIGpxWEhSKSB7XHJcblxyXG4gICAgICAgIHZhciBjYWxsYmFja05hbWUsIG92ZXJ3cml0dGVuLCByZXNwb25zZUNvbnRhaW5lcixcclxuICAgICAgICAgICAganNvblByb3AgPSBzLmpzb25wICE9PSBmYWxzZSAmJiAocmpzb25wLnRlc3Qocy51cmwpID9cclxuICAgICAgICAgICAgICAgIFwidXJsXCIgOlxyXG4gICAgICAgICAgICAgICAgdHlwZW9mIHMuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJiAhKHMuY29udGVudFR5cGUgfHwgXCJcIikuaW5kZXhPZihcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiKSAmJiByanNvbnAudGVzdChzLmRhdGEpICYmIFwiZGF0YVwiXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgIC8vIEhhbmRsZSBpZmYgdGhlIGV4cGVjdGVkIGRhdGEgdHlwZSBpcyBcImpzb25wXCIgb3Igd2UgaGF2ZSBhIHBhcmFtZXRlciB0byBzZXRcclxuICAgICAgICBpZiAoanNvblByb3AgfHwgcy5kYXRhVHlwZXNbMF0gPT09IFwianNvbnBcIikge1xyXG5cclxuICAgICAgICAgICAgLy8gR2V0IGNhbGxiYWNrIG5hbWUsIHJlbWVtYmVyaW5nIHByZWV4aXN0aW5nIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCBpdFxyXG4gICAgICAgICAgICBjYWxsYmFja05hbWUgPSBzLmpzb25wQ2FsbGJhY2sgPSBqUXVlcnkuaXNGdW5jdGlvbihzLmpzb25wQ2FsbGJhY2spID9cclxuICAgICAgICAgICAgICAgIHMuanNvbnBDYWxsYmFjaygpIDpcclxuICAgICAgICAgICAgICAgIHMuanNvbnBDYWxsYmFjaztcclxuXHJcbiAgICAgICAgICAgIC8vIEluc2VydCBjYWxsYmFjayBpbnRvIHVybCBvciBmb3JtIGRhdGFcclxuICAgICAgICAgICAgaWYgKGpzb25Qcm9wKSB7XHJcbiAgICAgICAgICAgICAgICBzW2pzb25Qcm9wXSA9IHNbanNvblByb3BdLnJlcGxhY2Uocmpzb25wLCBcIiQxXCIgKyBjYWxsYmFja05hbWUpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHMuanNvbnAgIT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICBzLnVybCArPSAocnF1ZXJ5LnRlc3Qocy51cmwpID8gXCImXCIgOiBcIj9cIikgKyBzLmpzb25wICsgXCI9XCIgKyBjYWxsYmFja05hbWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFVzZSBkYXRhIGNvbnZlcnRlciB0byByZXRyaWV2ZSBqc29uIGFmdGVyIHNjcmlwdCBleGVjdXRpb25cclxuICAgICAgICAgICAgcy5jb252ZXJ0ZXJzW1wic2NyaXB0IGpzb25cIl0gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIGlmICghcmVzcG9uc2VDb250YWluZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuZXJyb3IoY2FsbGJhY2tOYW1lICsgXCIgd2FzIG5vdCBjYWxsZWRcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2VDb250YWluZXJbMF07XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvLyBmb3JjZSBqc29uIGRhdGFUeXBlXHJcbiAgICAgICAgICAgIHMuZGF0YVR5cGVzWzBdID0gXCJqc29uXCI7XHJcblxyXG4gICAgICAgICAgICAvLyBJbnN0YWxsIGNhbGxiYWNrXHJcbiAgICAgICAgICAgIG92ZXJ3cml0dGVuID0gd2luZG93W2NhbGxiYWNrTmFtZV07XHJcbiAgICAgICAgICAgIHdpbmRvd1tjYWxsYmFja05hbWVdID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICByZXNwb25zZUNvbnRhaW5lciA9IGFyZ3VtZW50cztcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8vIENsZWFuLXVwIGZ1bmN0aW9uIChmaXJlcyBhZnRlciBjb252ZXJ0ZXJzKVxyXG4gICAgICAgICAgICBqcVhIUi5hbHdheXMoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBSZXN0b3JlIHByZWV4aXN0aW5nIHZhbHVlXHJcbiAgICAgICAgICAgICAgICB3aW5kb3dbY2FsbGJhY2tOYW1lXSA9IG92ZXJ3cml0dGVuO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFNhdmUgYmFjayBhcyBmcmVlXHJcbiAgICAgICAgICAgICAgICBpZiAoc1tjYWxsYmFja05hbWVdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHRoYXQgcmUtdXNpbmcgdGhlIG9wdGlvbnMgZG9lc24ndCBzY3JldyB0aGluZ3MgYXJvdW5kXHJcbiAgICAgICAgICAgICAgICAgICAgcy5qc29ucENhbGxiYWNrID0gb3JpZ2luYWxTZXR0aW5ncy5qc29ucENhbGxiYWNrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBzYXZlIHRoZSBjYWxsYmFjayBuYW1lIGZvciBmdXR1cmUgdXNlXHJcbiAgICAgICAgICAgICAgICAgICAgb2xkQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2tOYW1lKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDYWxsIGlmIGl0IHdhcyBhIGZ1bmN0aW9uIGFuZCB3ZSBoYXZlIGEgcmVzcG9uc2VcclxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZUNvbnRhaW5lciAmJiBqUXVlcnkuaXNGdW5jdGlvbihvdmVyd3JpdHRlbikpIHtcclxuICAgICAgICAgICAgICAgICAgICBvdmVyd3JpdHRlbihyZXNwb25zZUNvbnRhaW5lclswXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VDb250YWluZXIgPSBvdmVyd3JpdHRlbiA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAvLyBEZWxlZ2F0ZSB0byBzY3JpcHRcclxuICAgICAgICAgICAgcmV0dXJuIFwic2NyaXB0XCI7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG5cclxuXHJcblxyXG4gICAgLy8gZGF0YTogc3RyaW5nIG9mIGh0bWxcclxuICAgIC8vIGNvbnRleHQgKG9wdGlvbmFsKTogSWYgc3BlY2lmaWVkLCB0aGUgZnJhZ21lbnQgd2lsbCBiZSBjcmVhdGVkIGluIHRoaXMgY29udGV4dCwgZGVmYXVsdHMgdG8gZG9jdW1lbnRcclxuICAgIC8vIGtlZXBTY3JpcHRzIChvcHRpb25hbCk6IElmIHRydWUsIHdpbGwgaW5jbHVkZSBzY3JpcHRzIHBhc3NlZCBpbiB0aGUgaHRtbCBzdHJpbmdcclxuICAgIGpRdWVyeS5wYXJzZUhUTUwgPSBmdW5jdGlvbihkYXRhLCBjb250ZXh0LCBrZWVwU2NyaXB0cykge1xyXG4gICAgICAgIGlmICghZGF0YSB8fCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiBjb250ZXh0ID09PSBcImJvb2xlYW5cIikge1xyXG4gICAgICAgICAgICBrZWVwU2NyaXB0cyA9IGNvbnRleHQ7XHJcbiAgICAgICAgICAgIGNvbnRleHQgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29udGV4dCA9IGNvbnRleHQgfHwgZG9jdW1lbnQ7XHJcblxyXG4gICAgICAgIHZhciBwYXJzZWQgPSByc2luZ2xlVGFnLmV4ZWMoZGF0YSksXHJcbiAgICAgICAgICAgIHNjcmlwdHMgPSAha2VlcFNjcmlwdHMgJiYgW107XHJcblxyXG4gICAgICAgIC8vIFNpbmdsZSB0YWdcclxuICAgICAgICBpZiAocGFyc2VkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbY29udGV4dC5jcmVhdGVFbGVtZW50KHBhcnNlZFsxXSldO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcGFyc2VkID0galF1ZXJ5LmJ1aWxkRnJhZ21lbnQoW2RhdGFdLCBjb250ZXh0LCBzY3JpcHRzKTtcclxuXHJcbiAgICAgICAgaWYgKHNjcmlwdHMgJiYgc2NyaXB0cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgalF1ZXJ5KHNjcmlwdHMpLnJlbW92ZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGpRdWVyeS5tZXJnZShbXSwgcGFyc2VkLmNoaWxkTm9kZXMpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLy8gS2VlcCBhIGNvcHkgb2YgdGhlIG9sZCBsb2FkIG1ldGhvZFxyXG4gICAgdmFyIF9sb2FkID0galF1ZXJ5LmZuLmxvYWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2FkIGEgdXJsIGludG8gYSBwYWdlXHJcbiAgICAgKi9cclxuICAgIGpRdWVyeS5mbi5sb2FkID0gZnVuY3Rpb24odXJsLCBwYXJhbXMsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB1cmwgIT09IFwic3RyaW5nXCIgJiYgX2xvYWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9sb2FkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgc2VsZWN0b3IsIHR5cGUsIHJlc3BvbnNlLFxyXG4gICAgICAgICAgICBzZWxmID0gdGhpcyxcclxuICAgICAgICAgICAgb2ZmID0gdXJsLmluZGV4T2YoXCIgXCIpO1xyXG5cclxuICAgICAgICBpZiAob2ZmID49IDApIHtcclxuICAgICAgICAgICAgc2VsZWN0b3IgPSBqUXVlcnkudHJpbSh1cmwuc2xpY2Uob2ZmKSk7XHJcbiAgICAgICAgICAgIHVybCA9IHVybC5zbGljZSgwLCBvZmYpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSWYgaXQncyBhIGZ1bmN0aW9uXHJcbiAgICAgICAgaWYgKGpRdWVyeS5pc0Z1bmN0aW9uKHBhcmFtcykpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIFdlIGFzc3VtZSB0aGF0IGl0J3MgdGhlIGNhbGxiYWNrXHJcbiAgICAgICAgICAgIGNhbGxiYWNrID0gcGFyYW1zO1xyXG4gICAgICAgICAgICBwYXJhbXMgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIGJ1aWxkIGEgcGFyYW0gc3RyaW5nXHJcbiAgICAgICAgfSBlbHNlIGlmIChwYXJhbXMgJiYgdHlwZW9mIHBhcmFtcyA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgICAgICB0eXBlID0gXCJQT1NUXCI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJZiB3ZSBoYXZlIGVsZW1lbnRzIHRvIG1vZGlmeSwgbWFrZSB0aGUgcmVxdWVzdFxyXG4gICAgICAgIGlmIChzZWxmLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgalF1ZXJ5LmFqYXgoe1xyXG4gICAgICAgICAgICAgICAgdXJsOiB1cmwsXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gaWYgXCJ0eXBlXCIgdmFyaWFibGUgaXMgdW5kZWZpbmVkLCB0aGVuIFwiR0VUXCIgbWV0aG9kIHdpbGwgYmUgdXNlZFxyXG4gICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcclxuICAgICAgICAgICAgICAgIGRhdGFUeXBlOiBcImh0bWxcIixcclxuICAgICAgICAgICAgICAgIGRhdGE6IHBhcmFtc1xyXG4gICAgICAgICAgICB9KS5kb25lKGZ1bmN0aW9uKHJlc3BvbnNlVGV4dCkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFNhdmUgcmVzcG9uc2UgZm9yIHVzZSBpbiBjb21wbGV0ZSBjYWxsYmFja1xyXG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBhcmd1bWVudHM7XHJcblxyXG4gICAgICAgICAgICAgICAgc2VsZi5odG1sKHNlbGVjdG9yID9cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgYSBzZWxlY3RvciB3YXMgc3BlY2lmaWVkLCBsb2NhdGUgdGhlIHJpZ2h0IGVsZW1lbnRzIGluIGEgZHVtbXkgZGl2XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRXhjbHVkZSBzY3JpcHRzIHRvIGF2b2lkIElFICdQZXJtaXNzaW9uIERlbmllZCcgZXJyb3JzXHJcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KFwiPGRpdj5cIikuYXBwZW5kKGpRdWVyeS5wYXJzZUhUTUwocmVzcG9uc2VUZXh0KSkuZmluZChzZWxlY3RvcikgOlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UgdXNlIHRoZSBmdWxsIHJlc3VsdFxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlVGV4dCk7XHJcblxyXG4gICAgICAgICAgICB9KS5jb21wbGV0ZShjYWxsYmFjayAmJiBmdW5jdGlvbihqcVhIUiwgc3RhdHVzKSB7XHJcbiAgICAgICAgICAgICAgICBzZWxmLmVhY2goY2FsbGJhY2ssIHJlc3BvbnNlIHx8IFtqcVhIUi5yZXNwb25zZVRleHQsIHN0YXR1cywganFYSFJdKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcblxyXG5cclxuXHJcblxyXG4gICAgalF1ZXJ5LmV4cHIuZmlsdGVycy5hbmltYXRlZCA9IGZ1bmN0aW9uKGVsZW0pIHtcclxuICAgICAgICByZXR1cm4galF1ZXJ5LmdyZXAoalF1ZXJ5LnRpbWVycywgZnVuY3Rpb24oZm4pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGVsZW0gPT09IGZuLmVsZW07XHJcbiAgICAgICAgfSkubGVuZ3RoO1xyXG4gICAgfTtcclxuXHJcblxyXG5cclxuXHJcbiAgICB2YXIgZG9jRWxlbSA9IHdpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGEgd2luZG93IGZyb20gYW4gZWxlbWVudFxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRXaW5kb3coZWxlbSkge1xyXG4gICAgICAgIHJldHVybiBqUXVlcnkuaXNXaW5kb3coZWxlbSkgPyBlbGVtIDogZWxlbS5ub2RlVHlwZSA9PT0gOSAmJiBlbGVtLmRlZmF1bHRWaWV3O1xyXG4gICAgfVxyXG5cclxuICAgIGpRdWVyeS5vZmZzZXQgPSB7XHJcbiAgICAgICAgc2V0T2Zmc2V0OiBmdW5jdGlvbihlbGVtLCBvcHRpb25zLCBpKSB7XHJcbiAgICAgICAgICAgIHZhciBjdXJQb3NpdGlvbiwgY3VyTGVmdCwgY3VyQ1NTVG9wLCBjdXJUb3AsIGN1ck9mZnNldCwgY3VyQ1NTTGVmdCwgY2FsY3VsYXRlUG9zaXRpb24sXHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IGpRdWVyeS5jc3MoZWxlbSwgXCJwb3NpdGlvblwiKSxcclxuICAgICAgICAgICAgICAgIGN1ckVsZW0gPSBqUXVlcnkoZWxlbSksXHJcbiAgICAgICAgICAgICAgICBwcm9wcyA9IHt9O1xyXG5cclxuICAgICAgICAgICAgLy8gU2V0IHBvc2l0aW9uIGZpcnN0LCBpbi1jYXNlIHRvcC9sZWZ0IGFyZSBzZXQgZXZlbiBvbiBzdGF0aWMgZWxlbVxyXG4gICAgICAgICAgICBpZiAocG9zaXRpb24gPT09IFwic3RhdGljXCIpIHtcclxuICAgICAgICAgICAgICAgIGVsZW0uc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGN1ck9mZnNldCA9IGN1ckVsZW0ub2Zmc2V0KCk7XHJcbiAgICAgICAgICAgIGN1ckNTU1RvcCA9IGpRdWVyeS5jc3MoZWxlbSwgXCJ0b3BcIik7XHJcbiAgICAgICAgICAgIGN1ckNTU0xlZnQgPSBqUXVlcnkuY3NzKGVsZW0sIFwibGVmdFwiKTtcclxuICAgICAgICAgICAgY2FsY3VsYXRlUG9zaXRpb24gPSAocG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiB8fCBwb3NpdGlvbiA9PT0gXCJmaXhlZFwiKSAmJlxyXG4gICAgICAgICAgICAgICAgKGN1ckNTU1RvcCArIGN1ckNTU0xlZnQpLmluZGV4T2YoXCJhdXRvXCIpID4gLTE7XHJcblxyXG4gICAgICAgICAgICAvLyBOZWVkIHRvIGJlIGFibGUgdG8gY2FsY3VsYXRlIHBvc2l0aW9uIGlmIGVpdGhlciB0b3Agb3IgbGVmdCBpcyBhdXRvIGFuZCBwb3NpdGlvbiBpcyBlaXRoZXIgYWJzb2x1dGUgb3IgZml4ZWRcclxuICAgICAgICAgICAgaWYgKGNhbGN1bGF0ZVBvc2l0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJQb3NpdGlvbiA9IGN1ckVsZW0ucG9zaXRpb24oKTtcclxuICAgICAgICAgICAgICAgIGN1clRvcCA9IGN1clBvc2l0aW9uLnRvcDtcclxuICAgICAgICAgICAgICAgIGN1ckxlZnQgPSBjdXJQb3NpdGlvbi5sZWZ0O1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGN1clRvcCA9IHBhcnNlRmxvYXQoY3VyQ1NTVG9wKSB8fCAwO1xyXG4gICAgICAgICAgICAgICAgY3VyTGVmdCA9IHBhcnNlRmxvYXQoY3VyQ1NTTGVmdCkgfHwgMDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGpRdWVyeS5pc0Z1bmN0aW9uKG9wdGlvbnMpKSB7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucy5jYWxsKGVsZW0sIGksIGN1ck9mZnNldCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnRvcCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBwcm9wcy50b3AgPSAob3B0aW9ucy50b3AgLSBjdXJPZmZzZXQudG9wKSArIGN1clRvcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5sZWZ0ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHByb3BzLmxlZnQgPSAob3B0aW9ucy5sZWZ0IC0gY3VyT2Zmc2V0LmxlZnQpICsgY3VyTGVmdDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKFwidXNpbmdcIiBpbiBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLnVzaW5nLmNhbGwoZWxlbSwgcHJvcHMpO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGN1ckVsZW0uY3NzKHByb3BzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgalF1ZXJ5LmZuLmV4dGVuZCh7XHJcbiAgICAgICAgb2Zmc2V0OiBmdW5jdGlvbihvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucyA9PT0gdW5kZWZpbmVkID9cclxuICAgICAgICAgICAgICAgICAgICB0aGlzIDpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24oaSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkub2Zmc2V0LnNldE9mZnNldCh0aGlzLCBvcHRpb25zLCBpKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGRvY0VsZW0sIHdpbixcclxuICAgICAgICAgICAgICAgIGVsZW0gPSB0aGlzWzBdLFxyXG4gICAgICAgICAgICAgICAgYm94ID0geyB0b3A6IDAsIGxlZnQ6IDAgfSxcclxuICAgICAgICAgICAgICAgIGRvYyA9IGVsZW0gJiYgZWxlbS5vd25lckRvY3VtZW50O1xyXG5cclxuICAgICAgICAgICAgaWYgKCFkb2MpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZG9jRWxlbSA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XHJcblxyXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgaXQncyBub3QgYSBkaXNjb25uZWN0ZWQgRE9NIG5vZGVcclxuICAgICAgICAgICAgaWYgKCFqUXVlcnkuY29udGFpbnMoZG9jRWxlbSwgZWxlbSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBib3g7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgZ0JDUiwganVzdCB1c2UgMCwwIHJhdGhlciB0aGFuIGVycm9yXHJcbiAgICAgICAgICAgIC8vIEJsYWNrQmVycnkgNSwgaU9TIDMgKG9yaWdpbmFsIGlQaG9uZSlcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCAhPT0gc3RydW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBib3ggPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHdpbiA9IGdldFdpbmRvdyhkb2MpO1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgdG9wOiBib3gudG9wICsgd2luLnBhZ2VZT2Zmc2V0IC0gZG9jRWxlbS5jbGllbnRUb3AsXHJcbiAgICAgICAgICAgICAgICBsZWZ0OiBib3gubGVmdCArIHdpbi5wYWdlWE9mZnNldCAtIGRvY0VsZW0uY2xpZW50TGVmdFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHBvc2l0aW9uOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzWzBdKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBvZmZzZXRQYXJlbnQsIG9mZnNldCxcclxuICAgICAgICAgICAgICAgIGVsZW0gPSB0aGlzWzBdLFxyXG4gICAgICAgICAgICAgICAgcGFyZW50T2Zmc2V0ID0geyB0b3A6IDAsIGxlZnQ6IDAgfTtcclxuXHJcbiAgICAgICAgICAgIC8vIEZpeGVkIGVsZW1lbnRzIGFyZSBvZmZzZXQgZnJvbSB3aW5kb3cgKHBhcmVudE9mZnNldCA9IHt0b3A6MCwgbGVmdDogMH0sIGJlY2F1c2UgaXQgaXMgaXRzIG9ubHkgb2Zmc2V0IHBhcmVudFxyXG4gICAgICAgICAgICBpZiAoalF1ZXJ5LmNzcyhlbGVtLCBcInBvc2l0aW9uXCIpID09PSBcImZpeGVkXCIpIHtcclxuICAgICAgICAgICAgICAgIC8vIFdlIGFzc3VtZSB0aGF0IGdldEJvdW5kaW5nQ2xpZW50UmVjdCBpcyBhdmFpbGFibGUgd2hlbiBjb21wdXRlZCBwb3NpdGlvbiBpcyBmaXhlZFxyXG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBHZXQgKnJlYWwqIG9mZnNldFBhcmVudFxyXG4gICAgICAgICAgICAgICAgb2Zmc2V0UGFyZW50ID0gdGhpcy5vZmZzZXRQYXJlbnQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBHZXQgY29ycmVjdCBvZmZzZXRzXHJcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSB0aGlzLm9mZnNldCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFqUXVlcnkubm9kZU5hbWUob2Zmc2V0UGFyZW50WzBdLCBcImh0bWxcIikpIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRPZmZzZXQgPSBvZmZzZXRQYXJlbnQub2Zmc2V0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQWRkIG9mZnNldFBhcmVudCBib3JkZXJzXHJcbiAgICAgICAgICAgICAgICBwYXJlbnRPZmZzZXQudG9wICs9IGpRdWVyeS5jc3Mob2Zmc2V0UGFyZW50WzBdLCBcImJvcmRlclRvcFdpZHRoXCIsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgcGFyZW50T2Zmc2V0LmxlZnQgKz0galF1ZXJ5LmNzcyhvZmZzZXRQYXJlbnRbMF0sIFwiYm9yZGVyTGVmdFdpZHRoXCIsIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBTdWJ0cmFjdCBwYXJlbnQgb2Zmc2V0cyBhbmQgZWxlbWVudCBtYXJnaW5zXHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB0b3A6IG9mZnNldC50b3AgLSBwYXJlbnRPZmZzZXQudG9wIC0galF1ZXJ5LmNzcyhlbGVtLCBcIm1hcmdpblRvcFwiLCB0cnVlKSxcclxuICAgICAgICAgICAgICAgIGxlZnQ6IG9mZnNldC5sZWZ0IC0gcGFyZW50T2Zmc2V0LmxlZnQgLSBqUXVlcnkuY3NzKGVsZW0sIFwibWFyZ2luTGVmdFwiLCB0cnVlKVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIG9mZnNldFBhcmVudDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHZhciBvZmZzZXRQYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudCB8fCBkb2NFbGVtO1xyXG5cclxuICAgICAgICAgICAgICAgIHdoaWxlIChvZmZzZXRQYXJlbnQgJiYgKCFqUXVlcnkubm9kZU5hbWUob2Zmc2V0UGFyZW50LCBcImh0bWxcIikgJiYgalF1ZXJ5LmNzcyhvZmZzZXRQYXJlbnQsIFwicG9zaXRpb25cIikgPT09IFwic3RhdGljXCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50Lm9mZnNldFBhcmVudDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb2Zmc2V0UGFyZW50IHx8IGRvY0VsZW07XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIENyZWF0ZSBzY3JvbGxMZWZ0IGFuZCBzY3JvbGxUb3AgbWV0aG9kc1xyXG4gICAgalF1ZXJ5LmVhY2goeyBzY3JvbGxMZWZ0OiBcInBhZ2VYT2Zmc2V0XCIsIHNjcm9sbFRvcDogXCJwYWdlWU9mZnNldFwiIH0sIGZ1bmN0aW9uKG1ldGhvZCwgcHJvcCkge1xyXG4gICAgICAgIHZhciB0b3AgPSBcInBhZ2VZT2Zmc2V0XCIgPT09IHByb3A7XHJcblxyXG4gICAgICAgIGpRdWVyeS5mblttZXRob2RdID0gZnVuY3Rpb24odmFsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhY2Nlc3ModGhpcywgZnVuY3Rpb24oZWxlbSwgbWV0aG9kLCB2YWwpIHtcclxuICAgICAgICAgICAgICAgIHZhciB3aW4gPSBnZXRXaW5kb3coZWxlbSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpbiA/IHdpbltwcm9wXSA6IGVsZW1bbWV0aG9kXTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAod2luKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2luLnNjcm9sbFRvKCF0b3AgPyB2YWwgOiB3aW5kb3cucGFnZVhPZmZzZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcCA/IHZhbCA6IHdpbmRvdy5wYWdlWU9mZnNldFxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtW21ldGhvZF0gPSB2YWw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIG1ldGhvZCwgdmFsLCBhcmd1bWVudHMubGVuZ3RoLCBudWxsKTtcclxuICAgICAgICB9O1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gQWRkIHRoZSB0b3AvbGVmdCBjc3NIb29rcyB1c2luZyBqUXVlcnkuZm4ucG9zaXRpb25cclxuICAgIC8vIFdlYmtpdCBidWc6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yOTA4NFxyXG4gICAgLy8gZ2V0Q29tcHV0ZWRTdHlsZSByZXR1cm5zIHBlcmNlbnQgd2hlbiBzcGVjaWZpZWQgZm9yIHRvcC9sZWZ0L2JvdHRvbS9yaWdodFxyXG4gICAgLy8gcmF0aGVyIHRoYW4gbWFrZSB0aGUgY3NzIG1vZHVsZSBkZXBlbmQgb24gdGhlIG9mZnNldCBtb2R1bGUsIHdlIGp1c3QgY2hlY2sgZm9yIGl0IGhlcmVcclxuICAgIGpRdWVyeS5lYWNoKFtcInRvcFwiLCBcImxlZnRcIl0sIGZ1bmN0aW9uKGksIHByb3ApIHtcclxuICAgICAgICBqUXVlcnkuY3NzSG9va3NbcHJvcF0gPSBhZGRHZXRIb29rSWYoc3VwcG9ydC5waXhlbFBvc2l0aW9uLFxyXG4gICAgICAgICAgICBmdW5jdGlvbihlbGVtLCBjb21wdXRlZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbXB1dGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29tcHV0ZWQgPSBjdXJDU1MoZWxlbSwgcHJvcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgY3VyQ1NTIHJldHVybnMgcGVyY2VudGFnZSwgZmFsbGJhY2sgdG8gb2Zmc2V0XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJudW1ub25weC50ZXN0KGNvbXB1dGVkKSA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeShlbGVtKS5wb3NpdGlvbigpW3Byb3BdICsgXCJweFwiIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcHV0ZWQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICApO1xyXG4gICAgfSk7XHJcblxyXG5cclxuICAgIC8vIENyZWF0ZSBpbm5lckhlaWdodCwgaW5uZXJXaWR0aCwgaGVpZ2h0LCB3aWR0aCwgb3V0ZXJIZWlnaHQgYW5kIG91dGVyV2lkdGggbWV0aG9kc1xyXG4gICAgalF1ZXJ5LmVhY2goeyBIZWlnaHQ6IFwiaGVpZ2h0XCIsIFdpZHRoOiBcIndpZHRoXCIgfSwgZnVuY3Rpb24obmFtZSwgdHlwZSkge1xyXG4gICAgICAgIGpRdWVyeS5lYWNoKHsgcGFkZGluZzogXCJpbm5lclwiICsgbmFtZSwgY29udGVudDogdHlwZSwgXCJcIjogXCJvdXRlclwiICsgbmFtZSB9LCBmdW5jdGlvbihkZWZhdWx0RXh0cmEsIGZ1bmNOYW1lKSB7XHJcbiAgICAgICAgICAgIC8vIG1hcmdpbiBpcyBvbmx5IGZvciBvdXRlckhlaWdodCwgb3V0ZXJXaWR0aFxyXG4gICAgICAgICAgICBqUXVlcnkuZm5bZnVuY05hbWVdID0gZnVuY3Rpb24obWFyZ2luLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNoYWluYWJsZSA9IGFyZ3VtZW50cy5sZW5ndGggJiYgKGRlZmF1bHRFeHRyYSB8fCB0eXBlb2YgbWFyZ2luICE9PSBcImJvb2xlYW5cIiksXHJcbiAgICAgICAgICAgICAgICAgICAgZXh0cmEgPSBkZWZhdWx0RXh0cmEgfHwgKG1hcmdpbiA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gdHJ1ZSA/IFwibWFyZ2luXCIgOiBcImJvcmRlclwiKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjZXNzKHRoaXMsIGZ1bmN0aW9uKGVsZW0sIHR5cGUsIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRvYztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGpRdWVyeS5pc1dpbmRvdyhlbGVtKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBcyBvZiA1LzgvMjAxMiB0aGlzIHdpbGwgeWllbGQgaW5jb3JyZWN0IHJlc3VsdHMgZm9yIE1vYmlsZSBTYWZhcmksIGJ1dCB0aGVyZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpc24ndCBhIHdob2xlIGxvdCB3ZSBjYW4gZG8uIFNlZSBwdWxsIHJlcXVlc3QgYXQgdGhpcyBVUkwgZm9yIGRpc2N1c3Npb246XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L3B1bGwvNzY0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudFtcImNsaWVudFwiICsgbmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgZG9jdW1lbnQgd2lkdGggb3IgaGVpZ2h0XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW0ubm9kZVR5cGUgPT09IDkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZG9jID0gZWxlbS5kb2N1bWVudEVsZW1lbnQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFaXRoZXIgc2Nyb2xsW1dpZHRoL0hlaWdodF0gb3Igb2Zmc2V0W1dpZHRoL0hlaWdodF0gb3IgY2xpZW50W1dpZHRoL0hlaWdodF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoaWNoZXZlciBpcyBncmVhdGVzdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmJvZHlbXCJzY3JvbGxcIiArIG5hbWVdLCBkb2NbXCJzY3JvbGxcIiArIG5hbWVdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5ib2R5W1wib2Zmc2V0XCIgKyBuYW1lXSwgZG9jW1wib2Zmc2V0XCIgKyBuYW1lXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY1tcImNsaWVudFwiICsgbmFtZV1cclxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudCwgcmVxdWVzdGluZyBidXQgbm90IGZvcmNpbmcgcGFyc2VGbG9hdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuY3NzKGVsZW0sIHR5cGUsIGV4dHJhKSA6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5zdHlsZShlbGVtLCB0eXBlLCB2YWx1ZSwgZXh0cmEpO1xyXG4gICAgICAgICAgICAgICAgfSwgdHlwZSwgY2hhaW5hYmxlID8gbWFyZ2luIDogdW5kZWZpbmVkLCBjaGFpbmFibGUsIG51bGwpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG5cclxuICAgIC8vIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgY29udGFpbmVkIGluIHRoZSBtYXRjaGVkIGVsZW1lbnQgc2V0XHJcbiAgICBqUXVlcnkuZm4uc2l6ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxlbmd0aDtcclxuICAgIH07XHJcblxyXG4gICAgalF1ZXJ5LmZuLmFuZFNlbGYgPSBqUXVlcnkuZm4uYWRkQmFjaztcclxuXHJcblxyXG5cclxuXHJcbiAgICAvLyBSZWdpc3RlciBhcyBhIG5hbWVkIEFNRCBtb2R1bGUsIHNpbmNlIGpRdWVyeSBjYW4gYmUgY29uY2F0ZW5hdGVkIHdpdGggb3RoZXJcclxuICAgIC8vIGZpbGVzIHRoYXQgbWF5IHVzZSBkZWZpbmUsIGJ1dCBub3QgdmlhIGEgcHJvcGVyIGNvbmNhdGVuYXRpb24gc2NyaXB0IHRoYXRcclxuICAgIC8vIHVuZGVyc3RhbmRzIGFub255bW91cyBBTUQgbW9kdWxlcy4gQSBuYW1lZCBBTUQgaXMgc2FmZXN0IGFuZCBtb3N0IHJvYnVzdFxyXG4gICAgLy8gd2F5IHRvIHJlZ2lzdGVyLiBMb3dlcmNhc2UganF1ZXJ5IGlzIHVzZWQgYmVjYXVzZSBBTUQgbW9kdWxlIG5hbWVzIGFyZVxyXG4gICAgLy8gZGVyaXZlZCBmcm9tIGZpbGUgbmFtZXMsIGFuZCBqUXVlcnkgaXMgbm9ybWFsbHkgZGVsaXZlcmVkIGluIGEgbG93ZXJjYXNlXHJcbiAgICAvLyBmaWxlIG5hbWUuIERvIHRoaXMgYWZ0ZXIgY3JlYXRpbmcgdGhlIGdsb2JhbCBzbyB0aGF0IGlmIGFuIEFNRCBtb2R1bGUgd2FudHNcclxuICAgIC8vIHRvIGNhbGwgbm9Db25mbGljdCB0byBoaWRlIHRoaXMgdmVyc2lvbiBvZiBqUXVlcnksIGl0IHdpbGwgd29yay5cclxuXHJcbiAgICAvLyBOb3RlIHRoYXQgZm9yIG1heGltdW0gcG9ydGFiaWxpdHksIGxpYnJhcmllcyB0aGF0IGFyZSBub3QgalF1ZXJ5IHNob3VsZFxyXG4gICAgLy8gZGVjbGFyZSB0aGVtc2VsdmVzIGFzIGFub255bW91cyBtb2R1bGVzLCBhbmQgYXZvaWQgc2V0dGluZyBhIGdsb2JhbCBpZiBhblxyXG4gICAgLy8gQU1EIGxvYWRlciBpcyBwcmVzZW50LiBqUXVlcnkgaXMgYSBzcGVjaWFsIGNhc2UuIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWVcclxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qcmJ1cmtlL3JlcXVpcmVqcy93aWtpL1VwZGF0aW5nLWV4aXN0aW5nLWxpYnJhcmllcyN3aWtpLWFub25cclxuXHJcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcclxuICAgICAgICBkZWZpbmUoXCJqcXVlcnlcIiwgW10sIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuXHJcblxyXG5cclxuICAgIHZhclxyXG4gICAgLy8gTWFwIG92ZXIgalF1ZXJ5IGluIGNhc2Ugb2Ygb3ZlcndyaXRlXHJcbiAgICAgICAgX2pRdWVyeSA9IHdpbmRvdy5qUXVlcnksXHJcblxyXG4gICAgICAgIC8vIE1hcCBvdmVyIHRoZSAkIGluIGNhc2Ugb2Ygb3ZlcndyaXRlXHJcbiAgICAgICAgXyQgPSB3aW5kb3cuJDtcclxuXHJcbiAgICBqUXVlcnkubm9Db25mbGljdCA9IGZ1bmN0aW9uKGRlZXApIHtcclxuICAgICAgICBpZiAod2luZG93LiQgPT09IGpRdWVyeSkge1xyXG4gICAgICAgICAgICB3aW5kb3cuJCA9IF8kO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGRlZXAgJiYgd2luZG93LmpRdWVyeSA9PT0galF1ZXJ5KSB7XHJcbiAgICAgICAgICAgIHdpbmRvdy5qUXVlcnkgPSBfalF1ZXJ5O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGpRdWVyeTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gRXhwb3NlIGpRdWVyeSBhbmQgJCBpZGVudGlmaWVycywgZXZlbiBpblxyXG4gICAgLy8gQU1EICgjNzEwMiNjb21tZW50OjEwLCBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9wdWxsLzU1NylcclxuICAgIC8vIGFuZCBDb21tb25KUyBmb3IgYnJvd3NlciBlbXVsYXRvcnMgKCMxMzU2NilcclxuICAgIGlmICh0eXBlb2Ygbm9HbG9iYWwgPT09IHN0cnVuZGVmaW5lZCkge1xyXG4gICAgICAgIHdpbmRvdy5qUXVlcnkgPSB3aW5kb3cuJCA9IGpRdWVyeTtcclxuICAgIH1cclxuXHJcblxyXG5cclxuXHJcbiAgICByZXR1cm4galF1ZXJ5O1xyXG5cclxufSkpOyJdLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///2\\n')},function(module,exports,__webpack_require__){\"use strict\";eval('var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\\n\\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2)], __WEBPACK_AMD_DEFINE_RESULT__ = (function ($) {\\n    // require([\\'./move\\']);\\n\\n    function showplan() {\\n        var data = localStorage.getItem(\"myplan\");\\n        data = JSON.parse(data);\\n        $(\\'<li id=\\' + data[data.length - 1].id + \\' ondrop=\"drop(event,this)\" ondragover=\"allowDrop(event)\" draggable=\"true\" ondragstart=\"drag(event, this)\"><span><span></span><input type=\"checkbox\" style=\"zoom:200%\"/><span>\\' + data[data.length - 1].content + \\'</span></span><span class=\"del\">X</span></li>\\').appendTo($(\".todolist .list1>ul\"));\\n    }\\n    var sHtml = \\'\\';\\n\\n    function showplans() {\\n        var data = localStorage.getItem(\"myplan\");\\n        data = JSON.parse(data);\\n        for (var i = data.length - 1000; i < data.length; i++) {\\n            if (data[i].done == false) {\\n                sHtml += \\'<li id=\\' + data[i].id + \\' ondrop=\"drop(event,this)\" ondragover=\"allowDrop(event)\" draggable=\"true\" ondragstart=\"drag(event, this)\"><span><span></span><input type=\"checkbox\" style=\"zoom:200%\"/><span>\\' + data[i].content + \\'</span></span><span class=\"del\">X</span></li>\\'; // 构造需要添加元素的字符串  \\n            }\\n        };\\n        $(\\'.todolist .list1>ul\\').append(sHtml);\\n    }\\n\\n    function showallplan() {\\n\\n        var data = localStorage.getItem(\"myplan\");\\n\\n        data = JSON.parse(data);\\n\\n        var txt = \"\";\\n        var txt2 = \"\";\\n        for (var i = 0; i < data.length; i++) {\\n            if (data[i].done == false) {\\n                txt += \\'<li id=\\' + data[i].id + \\'  ondrop=\"drop(event,this)\" ondragover=\"allowDrop(event)\" draggable=\"true\" ondragstart=\"drag(event, this)\"><span><span></span><input type=\"checkbox\" style=\"zoom:200%\"/><span>\\';\\n                txt += data[i].content;\\n                txt += \\'</span></span><span class=\"del\">X</span></li>\\';\\n            } else {\\n                txt2 += \\'<li id=\\' + data[i].id + \\'><span><span></span><input type=\"checkbox\" checked=\"checked\" style=\"zoom:200%\"/><span>\\';\\n                txt2 += data[i].content;\\n                txt2 += \\'</span></span><span class=\"del\">X</span></li>\\';\\n            }\\n        }\\n        $(\".list2 ul\").html(txt2);\\n        $(\".list1 ul\").html(txt);\\n    }\\n    return {\\n        \\'showplan\\': showplan,\\n        \\'showallplan\\': showallplan,\\n        \\'showplans\\': showplans\\n    };\\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\\n\\t\\t\\t\\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wdWJsaWMvamF2YXNjcmlwdHMvc2hvdy5qcz84OGFiIl0sIm5hbWVzIjpbIiQiLCJzaG93cGxhbiIsImRhdGEiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwiSlNPTiIsInBhcnNlIiwibGVuZ3RoIiwiaWQiLCJjb250ZW50IiwiYXBwZW5kVG8iLCJzSHRtbCIsInNob3dwbGFucyIsImkiLCJkb25lIiwiYXBwZW5kIiwic2hvd2FsbHBsYW4iLCJ0eHQiLCJ0eHQyIiwiaHRtbCJdLCJtYXBwaW5ncyI6Ijs7QUFBQSxpQ0FBTyxDQUFDLHNCQUFELENBQVAsbUNBQXFCLFVBQVNBLENBQVQsRUFBWTtBQUM3Qjs7QUFFQSxhQUFTQyxRQUFULEdBQW9CO0FBQ2hCLFlBQUlDLE9BQU9DLGFBQWFDLE9BQWIsQ0FBcUIsUUFBckIsQ0FBWDtBQUNBRixlQUFPRyxLQUFLQyxLQUFMLENBQVdKLElBQVgsQ0FBUDtBQUNBRixVQUFFLFlBQVlFLEtBQUtBLEtBQUtLLE1BQUwsR0FBYyxDQUFuQixFQUFzQkMsRUFBbEMsR0FBdUMsK0tBQXZDLEdBQXlOTixLQUFLQSxLQUFLSyxNQUFMLEdBQWMsQ0FBbkIsRUFBc0JFLE9BQS9PLEdBQXlQLCtDQUEzUCxFQUE0U0MsUUFBNVMsQ0FBcVRWLEVBQUUscUJBQUYsQ0FBclQ7QUFDSDtBQUNELFFBQUlXLFFBQVEsRUFBWjs7QUFFQSxhQUFTQyxTQUFULEdBQXFCO0FBQ2pCLFlBQUlWLE9BQU9DLGFBQWFDLE9BQWIsQ0FBcUIsUUFBckIsQ0FBWDtBQUNBRixlQUFPRyxLQUFLQyxLQUFMLENBQVdKLElBQVgsQ0FBUDtBQUNBLGFBQUssSUFBSVcsSUFBSVgsS0FBS0ssTUFBTCxHQUFjLElBQTNCLEVBQWlDTSxJQUFJWCxLQUFLSyxNQUExQyxFQUFrRE0sR0FBbEQsRUFBdUQ7QUFDbkQsZ0JBQUlYLEtBQUtXLENBQUwsRUFBUUMsSUFBUixJQUFnQixLQUFwQixFQUEyQjtBQUN2QkgseUJBQVMsWUFBWVQsS0FBS1csQ0FBTCxFQUFRTCxFQUFwQixHQUF5QiwrS0FBekIsR0FBMk1OLEtBQUtXLENBQUwsRUFBUUosT0FBbk4sR0FBNk4sK0NBQXRPLENBRHVCLENBQ2dRO0FBQzFSO0FBQ0o7QUFDRFQsVUFBRSxxQkFBRixFQUF5QmUsTUFBekIsQ0FBZ0NKLEtBQWhDO0FBRUg7O0FBR0QsYUFBU0ssV0FBVCxHQUF1Qjs7QUFFbkIsWUFBSWQsT0FBT0MsYUFBYUMsT0FBYixDQUFxQixRQUFyQixDQUFYOztBQUVBRixlQUFPRyxLQUFLQyxLQUFMLENBQVdKLElBQVgsQ0FBUDs7QUFFQSxZQUFJZSxNQUFNLEVBQVY7QUFDQSxZQUFJQyxPQUFPLEVBQVg7QUFDQSxhQUFLLElBQUlMLElBQUksQ0FBYixFQUFnQkEsSUFBSVgsS0FBS0ssTUFBekIsRUFBaUNNLEdBQWpDLEVBQXNDO0FBQ2xDLGdCQUFJWCxLQUFLVyxDQUFMLEVBQVFDLElBQVIsSUFBZ0IsS0FBcEIsRUFBMkI7QUFDdkJHLHVCQUFPLFlBQVlmLEtBQUtXLENBQUwsRUFBUUwsRUFBcEIsR0FBeUIsZ0xBQWhDO0FBQ0FTLHVCQUFPZixLQUFLVyxDQUFMLEVBQVFKLE9BQWY7QUFDQVEsdUJBQU8sK0NBQVA7QUFDSCxhQUpELE1BSU87QUFDSEMsd0JBQVEsWUFBWWhCLEtBQUtXLENBQUwsRUFBUUwsRUFBcEIsR0FBeUIsd0ZBQWpDO0FBQ0FVLHdCQUFRaEIsS0FBS1csQ0FBTCxFQUFRSixPQUFoQjtBQUNBUyx3QkFBUSwrQ0FBUjtBQUVIO0FBQ0o7QUFDRGxCLFVBQUUsV0FBRixFQUFlbUIsSUFBZixDQUFvQkQsSUFBcEI7QUFDQWxCLFVBQUUsV0FBRixFQUFlbUIsSUFBZixDQUFvQkYsR0FBcEI7QUFFSDtBQUNELFdBQU87QUFDSCxvQkFBWWhCLFFBRFQ7QUFFSCx1QkFBZWUsV0FGWjtBQUdILHFCQUFhSjtBQUhWLEtBQVA7QUFNSCxDQXJERDtBQUFBIiwiZmlsZSI6IjMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJkZWZpbmUoWycuL2pxdWVyeSddLCBmdW5jdGlvbigkKSB7XHJcbiAgICAvLyByZXF1aXJlKFsnLi9tb3ZlJ10pO1xyXG5cclxuICAgIGZ1bmN0aW9uIHNob3dwbGFuKCkge1xyXG4gICAgICAgIHZhciBkYXRhID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJteXBsYW5cIik7XHJcbiAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XHJcbiAgICAgICAgJCgnPGxpIGlkPScgKyBkYXRhW2RhdGEubGVuZ3RoIC0gMV0uaWQgKyAnIG9uZHJvcD1cImRyb3AoZXZlbnQsdGhpcylcIiBvbmRyYWdvdmVyPVwiYWxsb3dEcm9wKGV2ZW50KVwiIGRyYWdnYWJsZT1cInRydWVcIiBvbmRyYWdzdGFydD1cImRyYWcoZXZlbnQsIHRoaXMpXCI+PHNwYW4+PHNwYW4+PC9zcGFuPjxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBzdHlsZT1cInpvb206MjAwJVwiLz48c3Bhbj4nICsgZGF0YVtkYXRhLmxlbmd0aCAtIDFdLmNvbnRlbnQgKyAnPC9zcGFuPjwvc3Bhbj48c3BhbiBjbGFzcz1cImRlbFwiPlg8L3NwYW4+PC9saT4nKS5hcHBlbmRUbygkKFwiLnRvZG9saXN0IC5saXN0MT51bFwiKSlcclxuICAgIH1cclxuICAgIHZhciBzSHRtbCA9ICcnO1xyXG5cclxuICAgIGZ1bmN0aW9uIHNob3dwbGFucygpIHtcclxuICAgICAgICB2YXIgZGF0YSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwibXlwbGFuXCIpO1xyXG4gICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSBkYXRhLmxlbmd0aCAtIDEwMDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChkYXRhW2ldLmRvbmUgPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIHNIdG1sICs9ICc8bGkgaWQ9JyArIGRhdGFbaV0uaWQgKyAnIG9uZHJvcD1cImRyb3AoZXZlbnQsdGhpcylcIiBvbmRyYWdvdmVyPVwiYWxsb3dEcm9wKGV2ZW50KVwiIGRyYWdnYWJsZT1cInRydWVcIiBvbmRyYWdzdGFydD1cImRyYWcoZXZlbnQsIHRoaXMpXCI+PHNwYW4+PHNwYW4+PC9zcGFuPjxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBzdHlsZT1cInpvb206MjAwJVwiLz48c3Bhbj4nICsgZGF0YVtpXS5jb250ZW50ICsgJzwvc3Bhbj48L3NwYW4+PHNwYW4gY2xhc3M9XCJkZWxcIj5YPC9zcGFuPjwvbGk+JzsgLy8g5p6E6YCg6ZyA6KaB5re75Yqg5YWD57Sg55qE5a2X56ym5LiyICBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgJCgnLnRvZG9saXN0IC5saXN0MT51bCcpLmFwcGVuZChzSHRtbCk7XHJcblxyXG4gICAgfVxyXG5cclxuXHJcbiAgICBmdW5jdGlvbiBzaG93YWxscGxhbigpIHtcclxuXHJcbiAgICAgICAgdmFyIGRhdGEgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcIm15cGxhblwiKTtcclxuXHJcbiAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XHJcblxyXG4gICAgICAgIHZhciB0eHQgPSBcIlwiO1xyXG4gICAgICAgIHZhciB0eHQyID0gXCJcIjtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGRhdGFbaV0uZG9uZSA9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgdHh0ICs9ICc8bGkgaWQ9JyArIGRhdGFbaV0uaWQgKyAnICBvbmRyb3A9XCJkcm9wKGV2ZW50LHRoaXMpXCIgb25kcmFnb3Zlcj1cImFsbG93RHJvcChldmVudClcIiBkcmFnZ2FibGU9XCJ0cnVlXCIgb25kcmFnc3RhcnQ9XCJkcmFnKGV2ZW50LCB0aGlzKVwiPjxzcGFuPjxzcGFuPjwvc3Bhbj48aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgc3R5bGU9XCJ6b29tOjIwMCVcIi8+PHNwYW4+JztcclxuICAgICAgICAgICAgICAgIHR4dCArPSBkYXRhW2ldLmNvbnRlbnQ7XHJcbiAgICAgICAgICAgICAgICB0eHQgKz0gJzwvc3Bhbj48L3NwYW4+PHNwYW4gY2xhc3M9XCJkZWxcIj5YPC9zcGFuPjwvbGk+JztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHR4dDIgKz0gJzxsaSBpZD0nICsgZGF0YVtpXS5pZCArICc+PHNwYW4+PHNwYW4+PC9zcGFuPjxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBjaGVja2VkPVwiY2hlY2tlZFwiIHN0eWxlPVwiem9vbToyMDAlXCIvPjxzcGFuPic7XHJcbiAgICAgICAgICAgICAgICB0eHQyICs9IGRhdGFbaV0uY29udGVudDtcclxuICAgICAgICAgICAgICAgIHR4dDIgKz0gJzwvc3Bhbj48L3NwYW4+PHNwYW4gY2xhc3M9XCJkZWxcIj5YPC9zcGFuPjwvbGk+JztcclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgJChcIi5saXN0MiB1bFwiKS5odG1sKHR4dDIpO1xyXG4gICAgICAgICQoXCIubGlzdDEgdWxcIikuaHRtbCh0eHQpO1xyXG5cclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgJ3Nob3dwbGFuJzogc2hvd3BsYW4sXHJcbiAgICAgICAgJ3Nob3dhbGxwbGFuJzogc2hvd2FsbHBsYW4sXHJcbiAgICAgICAgJ3Nob3dwbGFucyc6IHNob3dwbGFuc1xyXG4gICAgfVxyXG5cclxufSkiXSwic291cmNlUm9vdCI6IiJ9\\n//# sourceURL=webpack-internal:///3\\n')},function(module,exports,__webpack_require__){\"use strict\";eval('var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\\n\\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2)], __WEBPACK_AMD_DEFINE_RESULT__ = (function ($) {\\n    function count() {\\n        var data = localStorage.getItem(\"myplan\");\\n        data = JSON.parse(data);\\n        var len1 = 0;\\n        var len2 = 0;\\n        for (var i = 0; i < data.length; i++) {\\n\\n            if (data[i].done == false) {\\n                len1 += 1;\\n            } else {\\n                len2 += 1;\\n            }\\n        }\\n        $(\".ongoing .listtop span:nth-child(2)\").text(len1);\\n        $(\".done .listtop span:nth-child(2)\").text(len2);\\n    }\\n    return {\\n        \\'count\\': count\\n    };\\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\\n\\t\\t\\t\\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wdWJsaWMvamF2YXNjcmlwdHMvY291bnQuanM/MDMzMSJdLCJuYW1lcyI6WyIkIiwiY291bnQiLCJkYXRhIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsIkpTT04iLCJwYXJzZSIsImxlbjEiLCJsZW4yIiwiaSIsImxlbmd0aCIsImRvbmUiLCJ0ZXh0Il0sIm1hcHBpbmdzIjoiOztBQUFBLGlDQUFPLENBQUMsc0JBQUQsQ0FBUCxtQ0FBcUIsVUFBU0EsQ0FBVCxFQUFZO0FBQzdCLGFBQVNDLEtBQVQsR0FBaUI7QUFDYixZQUFJQyxPQUFPQyxhQUFhQyxPQUFiLENBQXFCLFFBQXJCLENBQVg7QUFDQUYsZUFBT0csS0FBS0MsS0FBTCxDQUFXSixJQUFYLENBQVA7QUFDQSxZQUFJSyxPQUFPLENBQVg7QUFDQSxZQUFJQyxPQUFPLENBQVg7QUFDQSxhQUFLLElBQUlDLElBQUksQ0FBYixFQUFnQkEsSUFBSVAsS0FBS1EsTUFBekIsRUFBaUNELEdBQWpDLEVBQXNDOztBQUVsQyxnQkFBSVAsS0FBS08sQ0FBTCxFQUFRRSxJQUFSLElBQWdCLEtBQXBCLEVBQTJCO0FBQ3ZCSix3QkFBUSxDQUFSO0FBQ0gsYUFGRCxNQUVPO0FBQ0hDLHdCQUFRLENBQVI7QUFDSDtBQUNKO0FBQ0RSLFVBQUUscUNBQUYsRUFBeUNZLElBQXpDLENBQThDTCxJQUE5QztBQUNBUCxVQUFFLGtDQUFGLEVBQXNDWSxJQUF0QyxDQUEyQ0osSUFBM0M7QUFDSDtBQUNELFdBQU87QUFDSCxpQkFBU1A7QUFETixLQUFQO0FBR0gsQ0FwQkQ7QUFBQSIsImZpbGUiOiI0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiZGVmaW5lKFsnLi9qcXVlcnknXSwgZnVuY3Rpb24oJCkge1xyXG4gICAgZnVuY3Rpb24gY291bnQoKSB7XHJcbiAgICAgICAgdmFyIGRhdGEgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcIm15cGxhblwiKTtcclxuICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcclxuICAgICAgICB2YXIgbGVuMSA9IDA7XHJcbiAgICAgICAgdmFyIGxlbjIgPSAwO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xyXG5cclxuICAgICAgICAgICAgaWYgKGRhdGFbaV0uZG9uZSA9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgbGVuMSArPSAxO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbGVuMiArPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgICQoXCIub25nb2luZyAubGlzdHRvcCBzcGFuOm50aC1jaGlsZCgyKVwiKS50ZXh0KGxlbjEpO1xyXG4gICAgICAgICQoXCIuZG9uZSAubGlzdHRvcCBzcGFuOm50aC1jaGlsZCgyKVwiKS50ZXh0KGxlbjIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICAnY291bnQnOiBjb3VudFxyXG4gICAgfVxyXG59KSJdLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///4\\n')},function(module,exports){eval('module.exports = function(module) {\\r\\n\\tif (!module.webpackPolyfill) {\\r\\n\\t\\tmodule.deprecate = function() {};\\r\\n\\t\\tmodule.paths = [];\\r\\n\\t\\t// module.parent = undefined by default\\r\\n\\t\\tif (!module.children) module.children = [];\\r\\n\\t\\tObject.defineProperty(module, \"loaded\", {\\r\\n\\t\\t\\tenumerable: true,\\r\\n\\t\\t\\tget: function() {\\r\\n\\t\\t\\t\\treturn module.l;\\r\\n\\t\\t\\t}\\r\\n\\t\\t});\\r\\n\\t\\tObject.defineProperty(module, \"id\", {\\r\\n\\t\\t\\tenumerable: true,\\r\\n\\t\\t\\tget: function() {\\r\\n\\t\\t\\t\\treturn module.i;\\r\\n\\t\\t\\t}\\r\\n\\t\\t});\\r\\n\\t\\tmodule.webpackPolyfill = 1;\\r\\n\\t}\\r\\n\\treturn module;\\r\\n};\\r\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzP2NlZDIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xyXG5cdGlmICghbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xyXG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XHJcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcclxuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxyXG5cdFx0aWYgKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XHJcblx0fVxyXG5cdHJldHVybiBtb2R1bGU7XHJcbn07XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///5\\n')}]]);","extractedComments":[]}